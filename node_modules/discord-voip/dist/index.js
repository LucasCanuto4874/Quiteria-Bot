"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  AudioPlayer: () => AudioPlayer,
  AudioPlayerError: () => AudioPlayerError,
  AudioPlayerStatus: () => AudioPlayerStatus,
  AudioResource: () => AudioResource,
  NoSubscriberBehavior: () => NoSubscriberBehavior,
  PlayerSubscription: () => PlayerSubscription,
  StreamType: () => StreamType,
  VoiceConnection: () => VoiceConnection,
  VoiceConnectionDisconnectReason: () => VoiceConnectionDisconnectReason,
  VoiceConnectionStatus: () => VoiceConnectionStatus,
  createAudioPlayer: () => createAudioPlayer,
  createAudioResource: () => createAudioResource,
  entersState: () => entersState,
  getGroups: () => getGroups,
  getVoiceConnection: () => getVoiceConnection,
  getVoiceConnections: () => getVoiceConnections,
  joinVoiceChannel: () => joinVoiceChannel,
  version: () => version
});
module.exports = __toCommonJS(src_exports);

// src/VoiceConnection.ts
var import_node_events4 = require("events");

// src/DataStore.ts
var import_v10 = require("discord-api-types/v10");
function createJoinVoiceChannelPayload(config) {
  return {
    op: import_v10.GatewayOpcodes.VoiceStateUpdate,
    // eslint-disable-next-line id-length
    d: {
      guild_id: config.guildId,
      channel_id: config.channelId,
      self_deaf: config.selfDeaf,
      self_mute: config.selfMute
    }
  };
}
__name(createJoinVoiceChannelPayload, "createJoinVoiceChannelPayload");
var groups = /* @__PURE__ */ new Map();
groups.set("default", /* @__PURE__ */ new Map());
function getOrCreateGroup(group) {
  const existing = groups.get(group);
  if (existing) return existing;
  const map = /* @__PURE__ */ new Map();
  groups.set(group, map);
  return map;
}
__name(getOrCreateGroup, "getOrCreateGroup");
function getGroups() {
  return groups;
}
__name(getGroups, "getGroups");
function getVoiceConnections(group = "default") {
  return groups.get(group);
}
__name(getVoiceConnections, "getVoiceConnections");
function getVoiceConnection(guildId, group = "default") {
  return getVoiceConnections(group)?.get(guildId);
}
__name(getVoiceConnection, "getVoiceConnection");
function untrackVoiceConnection(voiceConnection) {
  return getVoiceConnections(voiceConnection.joinConfig.group)?.delete(voiceConnection.joinConfig.guildId);
}
__name(untrackVoiceConnection, "untrackVoiceConnection");
function trackVoiceConnection(voiceConnection) {
  return getOrCreateGroup(voiceConnection.joinConfig.group).set(voiceConnection.joinConfig.guildId, voiceConnection);
}
__name(trackVoiceConnection, "trackVoiceConnection");
var FRAME_LENGTH = 20;
var audioCycleInterval;
var nextTime = -1;
var audioPlayers = [];
function audioCycleStep() {
  if (nextTime === -1) return;
  nextTime += FRAME_LENGTH;
  const available = audioPlayers.filter((player) => player.checkPlayable());
  for (const player of available) {
    player["_stepDispatch"]();
  }
  prepareNextAudioFrame(available);
}
__name(audioCycleStep, "audioCycleStep");
function prepareNextAudioFrame(players) {
  const nextPlayer = players.shift();
  if (!nextPlayer) {
    if (nextTime !== -1) {
      audioCycleInterval = setTimeout(() => audioCycleStep(), nextTime - Date.now());
    }
    return;
  }
  nextPlayer["_stepPrepare"]();
  setImmediate(() => prepareNextAudioFrame(players));
}
__name(prepareNextAudioFrame, "prepareNextAudioFrame");
function hasAudioPlayer(target) {
  return audioPlayers.includes(target);
}
__name(hasAudioPlayer, "hasAudioPlayer");
function addAudioPlayer(player) {
  if (hasAudioPlayer(player)) return player;
  audioPlayers.push(player);
  if (audioPlayers.length === 1) {
    nextTime = Date.now();
    setImmediate(() => audioCycleStep());
  }
  return player;
}
__name(addAudioPlayer, "addAudioPlayer");
function deleteAudioPlayer(player) {
  const index = audioPlayers.indexOf(player);
  if (index === -1) return;
  audioPlayers.splice(index, 1);
  if (audioPlayers.length === 0) {
    nextTime = -1;
    if (audioCycleInterval !== void 0) clearTimeout(audioCycleInterval);
  }
}
__name(deleteAudioPlayer, "deleteAudioPlayer");

// src/networking/Networking.ts
var import_node_buffer3 = require("buffer");
var import_node_events3 = require("events");
var import_node_crypto = __toESM(require("crypto"));
var import_v42 = require("discord-api-types/voice/v4");

// src/util/Secretbox.ts
var import_node_buffer = require("buffer");
var libs = {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  "sodium-native": /* @__PURE__ */ __name((sodium) => ({
    crypto_aead_xchacha20poly1305_ietf_encrypt: /* @__PURE__ */ __name((plaintext, additionalData, nonce2, key) => {
      const cipherText = import_node_buffer.Buffer.alloc(plaintext.length + sodium.crypto_aead_xchacha20poly1305_ietf_ABYTES);
      sodium.crypto_aead_xchacha20poly1305_ietf_encrypt(cipherText, plaintext, additionalData, null, nonce2, key);
      return cipherText;
    }, "crypto_aead_xchacha20poly1305_ietf_encrypt")
  }), "sodium-native"),
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  sodium: /* @__PURE__ */ __name((sodium) => ({
    crypto_aead_xchacha20poly1305_ietf_encrypt: /* @__PURE__ */ __name((plaintext, additionalData, nonce2, key) => {
      return sodium.api.crypto_aead_xchacha20poly1305_ietf_encrypt(plaintext, additionalData, null, nonce2, key);
    }, "crypto_aead_xchacha20poly1305_ietf_encrypt")
  }), "sodium"),
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  "libsodium-wrappers": /* @__PURE__ */ __name((sodium) => ({
    crypto_aead_xchacha20poly1305_ietf_encrypt: /* @__PURE__ */ __name((plaintext, additionalData, nonce2, key) => {
      return sodium.crypto_aead_xchacha20poly1305_ietf_encrypt(plaintext, additionalData, null, nonce2, key);
    }, "crypto_aead_xchacha20poly1305_ietf_encrypt")
  }), "libsodium-wrappers"),
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  "@stablelib/xchacha20poly1305": /* @__PURE__ */ __name((stablelib) => ({
    crypto_aead_xchacha20poly1305_ietf_encrypt(cipherText, additionalData, nonce2, key) {
      const crypto2 = new stablelib.XChaCha20Poly1305(key);
      return crypto2.seal(nonce2, cipherText, additionalData);
    }
  }), "@stablelib/xchacha20poly1305"),
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  "@noble/ciphers/chacha": /* @__PURE__ */ __name((noble) => ({
    crypto_aead_xchacha20poly1305_ietf_encrypt(plaintext, additionalData, nonce2, key) {
      const chacha = noble.xchacha20poly1305(key, nonce2, additionalData);
      return chacha.encrypt(plaintext);
    }
  }), "@noble/ciphers/chacha")
};
libs["sodium-javascript"] = libs["sodium-native"];
var validLibs = Object.keys(libs);
var fallbackError = /* @__PURE__ */ __name(() => {
  throw new Error(
    `Cannot play audio as no valid encryption package is installed.
- Install one of the following packages: ${validLibs.join(", ")}
- Use the generateDependencyReport() function for more information.
`
  );
}, "fallbackError");
var methods = {
  crypto_aead_xchacha20poly1305_ietf_encrypt: fallbackError
};
void (async () => {
  for (const libName of Object.keys(libs)) {
    try {
      const lib = await import(libName);
      if (libName === "libsodium-wrappers" && lib.ready) await lib.ready;
      Object.assign(methods, libs[libName](lib));
      break;
    } catch {
    }
  }
})();

// src/util/util.ts
var noop = /* @__PURE__ */ __name(() => {
}, "noop");

// src/networking/VoiceUDPSocket.ts
var import_node_buffer2 = require("buffer");
var import_node_dgram = require("dgram");
var import_node_events = require("events");
var import_node_net = require("net");
function parseLocalPacket(message) {
  const packet = import_node_buffer2.Buffer.from(message);
  const ip = packet.slice(8, packet.indexOf(0, 8)).toString("utf8");
  if (!(0, import_node_net.isIPv4)(ip)) {
    throw new Error("Malformed IP address");
  }
  const port = packet.readUInt16BE(packet.length - 2);
  return { ip, port };
}
__name(parseLocalPacket, "parseLocalPacket");
var KEEP_ALIVE_INTERVAL = 5e3;
var MAX_COUNTER_VALUE = 2 ** 32 - 1;
var _VoiceUDPSocket = class _VoiceUDPSocket extends import_node_events.EventEmitter {
  /**
   * Creates a new VoiceUDPSocket.
   *
   * @param remote - Details of the remote socket
   */
  constructor(remote) {
    super();
    /**
     * The underlying network Socket for the VoiceUDPSocket.
     */
    __publicField(this, "socket");
    /**
     * The socket details for Discord (remote)
     */
    __publicField(this, "remote");
    /**
     * The counter used in the keep alive mechanism.
     */
    __publicField(this, "keepAliveCounter", 0);
    /**
     * The buffer used to write the keep alive counter into.
     */
    __publicField(this, "keepAliveBuffer");
    /**
     * The Node.js interval for the keep-alive mechanism.
     */
    __publicField(this, "keepAliveInterval");
    /**
     * The time taken to receive a response to keep alive messages.
     *
     * @deprecated This field is no longer updated as keep alive messages are no longer tracked.
     */
    __publicField(this, "ping");
    this.socket = (0, import_node_dgram.createSocket)("udp4");
    this.socket.on("error", (error) => this.emit("error", error));
    this.socket.on("message", (buffer) => this.onMessage(buffer));
    this.socket.on("close", () => this.emit("close"));
    this.remote = remote;
    this.keepAliveBuffer = import_node_buffer2.Buffer.alloc(8);
    this.keepAliveInterval = setInterval(() => this.keepAlive(), KEEP_ALIVE_INTERVAL);
    setImmediate(() => this.keepAlive());
  }
  /**
   * Called when a message is received on the UDP socket.
   *
   * @param buffer - The received buffer
   */
  onMessage(buffer) {
    this.emit("message", buffer);
  }
  /**
   * Called at a regular interval to check whether we are still able to send datagrams to Discord.
   */
  keepAlive() {
    this.keepAliveBuffer.writeUInt32LE(this.keepAliveCounter, 0);
    this.send(this.keepAliveBuffer);
    this.keepAliveCounter++;
    if (this.keepAliveCounter > MAX_COUNTER_VALUE) {
      this.keepAliveCounter = 0;
    }
  }
  /**
   * Sends a buffer to Discord.
   *
   * @param buffer - The buffer to send
   */
  send(buffer) {
    this.socket.send(buffer, this.remote.port, this.remote.ip);
  }
  /**
   * Closes the socket, the instance will not be able to be reused.
   */
  destroy() {
    try {
      this.socket.close();
    } catch {
    }
    clearInterval(this.keepAliveInterval);
  }
  /**
   * Performs IP discovery to discover the local address and port to be used for the voice connection.
   *
   * @param ssrc - The SSRC received from Discord
   */
  async performIPDiscovery(ssrc) {
    return new Promise((resolve, reject) => {
      const listener = /* @__PURE__ */ __name((message) => {
        try {
          if (message.readUInt16BE(0) !== 2) return;
          const packet = parseLocalPacket(message);
          this.socket.off("message", listener);
          resolve(packet);
        } catch {
        }
      }, "listener");
      this.socket.on("message", listener);
      this.socket.once("close", () => reject(new Error("Cannot perform IP discovery - socket closed")));
      const discoveryBuffer = import_node_buffer2.Buffer.alloc(74);
      discoveryBuffer.writeUInt16BE(1, 0);
      discoveryBuffer.writeUInt16BE(70, 2);
      discoveryBuffer.writeUInt32BE(ssrc, 4);
      this.send(discoveryBuffer);
    });
  }
};
__name(_VoiceUDPSocket, "VoiceUDPSocket");
var VoiceUDPSocket = _VoiceUDPSocket;

// src/networking/VoiceWebSocket.ts
var import_node_events2 = require("events");
var import_v4 = require("discord-api-types/voice/v4");
var import_ws = require("ws");
var _VoiceWebSocket = class _VoiceWebSocket extends import_node_events2.EventEmitter {
  /**
   * Creates a new VoiceWebSocket.
   *
   * @param address - The address to connect to
   */
  constructor(address, debug) {
    super();
    /**
     * The current heartbeat interval, if any.
     */
    __publicField(this, "heartbeatInterval");
    /**
     * The time (milliseconds since UNIX epoch) that the last heartbeat acknowledgement packet was received.
     * This is set to 0 if an acknowledgement packet hasn't been received yet.
     */
    __publicField(this, "lastHeartbeatAck");
    /**
     * The time (milliseconds since UNIX epoch) that the last heartbeat was sent. This is set to 0 if a heartbeat
     * hasn't been sent yet.
     */
    __publicField(this, "lastHeartbeatSend");
    /**
     * The number of consecutively missed heartbeats.
     */
    __publicField(this, "missedHeartbeats", 0);
    /**
     * The last recorded ping.
     */
    __publicField(this, "ping");
    /**
     * The debug logger function, if debugging is enabled.
     */
    __publicField(this, "debug");
    /**
     * The underlying WebSocket of this wrapper.
     */
    __publicField(this, "ws");
    this.ws = new import_ws.WebSocket(address);
    this.ws.onmessage = (err) => this.onMessage(err);
    this.ws.onopen = (err) => this.emit("open", err);
    this.ws.onerror = (err) => this.emit("error", err instanceof Error ? err : err.error);
    this.ws.onclose = (err) => this.emit("close", err);
    this.lastHeartbeatAck = 0;
    this.lastHeartbeatSend = 0;
    this.debug = debug ? (message) => this.emit("debug", message) : null;
  }
  /**
   * Destroys the VoiceWebSocket. The heartbeat interval is cleared, and the connection is closed.
   */
  destroy() {
    try {
      this.debug?.("destroyed");
      this.setHeartbeatInterval(-1);
      this.ws.close(1e3);
    } catch (error) {
      const err = error;
      this.emit("error", err);
    }
  }
  /**
   * Handles message events on the WebSocket. Attempts to JSON parse the messages and emit them
   * as packets.
   *
   * @param event - The message event
   */
  onMessage(event) {
    if (typeof event.data !== "string") return;
    this.debug?.(`<< ${event.data}`);
    let packet;
    try {
      packet = JSON.parse(event.data);
    } catch (error) {
      const err = error;
      this.emit("error", err);
      return;
    }
    if (packet.op === import_v4.VoiceOpcodes.HeartbeatAck) {
      this.lastHeartbeatAck = Date.now();
      this.missedHeartbeats = 0;
      this.ping = this.lastHeartbeatAck - this.lastHeartbeatSend;
    }
    this.emit("packet", packet);
  }
  /**
   * Sends a JSON-stringifiable packet over the WebSocket.
   *
   * @param packet - The packet to send
   */
  sendPacket(packet) {
    try {
      const stringified = JSON.stringify(packet);
      this.debug?.(`>> ${stringified}`);
      this.ws.send(stringified);
    } catch (error) {
      const err = error;
      this.emit("error", err);
    }
  }
  /**
   * Sends a heartbeat over the WebSocket.
   */
  sendHeartbeat() {
    this.lastHeartbeatSend = Date.now();
    this.missedHeartbeats++;
    const nonce2 = this.lastHeartbeatSend;
    this.sendPacket({
      op: import_v4.VoiceOpcodes.Heartbeat,
      // eslint-disable-next-line id-length
      d: nonce2
    });
  }
  /**
   * Sets/clears an interval to send heartbeats over the WebSocket.
   *
   * @param ms - The interval in milliseconds. If negative, the interval will be unset
   */
  setHeartbeatInterval(ms) {
    if (this.heartbeatInterval !== void 0) clearInterval(this.heartbeatInterval);
    if (ms > 0) {
      this.heartbeatInterval = setInterval(() => {
        if (this.lastHeartbeatSend !== 0 && this.missedHeartbeats >= 3) {
          this.ws.close();
          this.setHeartbeatInterval(-1);
        }
        this.sendHeartbeat();
      }, ms);
    }
  }
};
__name(_VoiceWebSocket, "VoiceWebSocket");
var VoiceWebSocket = _VoiceWebSocket;

// src/networking/Networking.ts
var CHANNELS = 2;
var TIMESTAMP_INC = 48e3 / 100 * CHANNELS;
var MAX_NONCE_SIZE = 2 ** 32 - 1;
var SUPPORTED_ENCRYPTION_MODES = ["aead_xchacha20_poly1305_rtpsize"];
if (import_node_crypto.default.getCiphers().includes("aes-256-gcm")) {
  SUPPORTED_ENCRYPTION_MODES.unshift("aead_aes256_gcm_rtpsize");
}
var nonce = import_node_buffer3.Buffer.alloc(24);
function stringifyState(state) {
  return JSON.stringify({
    ...state,
    ws: Reflect.has(state, "ws"),
    udp: Reflect.has(state, "udp")
  });
}
__name(stringifyState, "stringifyState");
function chooseEncryptionMode(options) {
  const option = options.find((option2) => SUPPORTED_ENCRYPTION_MODES.includes(option2));
  if (!option) {
    throw new Error(`No compatible encryption modes. Available include: ${options.join(", ")}`);
  }
  return option;
}
__name(chooseEncryptionMode, "chooseEncryptionMode");
function randomNBit(numberOfBits) {
  return Math.floor(Math.random() * 2 ** numberOfBits);
}
__name(randomNBit, "randomNBit");
var _Networking = class _Networking extends import_node_events3.EventEmitter {
  /**
   * Creates a new Networking instance.
   */
  constructor(options, debug) {
    super();
    __publicField(this, "_state");
    /**
     * The debug logger function, if debugging is enabled.
     */
    __publicField(this, "debug");
    this.onWsOpen = this.onWsOpen.bind(this);
    this.onChildError = this.onChildError.bind(this);
    this.onWsPacket = this.onWsPacket.bind(this);
    this.onWsClose = this.onWsClose.bind(this);
    this.onWsDebug = this.onWsDebug.bind(this);
    this.onUdpDebug = this.onUdpDebug.bind(this);
    this.onUdpClose = this.onUdpClose.bind(this);
    this.debug = debug ? (message) => this.emit("debug", message) : null;
    this._state = {
      code: 0 /* OpeningWs */,
      ws: this.createWebSocket(options.endpoint),
      connectionOptions: options
    };
  }
  /**
   * Destroys the Networking instance, transitioning it into the Closed state.
   */
  destroy() {
    this.state = {
      code: 6 /* Closed */
    };
  }
  /**
   * The current state of the networking instance.
   */
  get state() {
    return this._state;
  }
  /**
   * Sets a new state for the networking instance, performing clean-up operations where necessary.
   */
  set state(newState) {
    const oldWs = Reflect.get(this._state, "ws");
    const newWs = Reflect.get(newState, "ws");
    if (oldWs && oldWs !== newWs) {
      oldWs.off("debug", this.onWsDebug);
      oldWs.on("error", noop);
      oldWs.off("error", this.onChildError);
      oldWs.off("open", this.onWsOpen);
      oldWs.off("packet", this.onWsPacket);
      oldWs.off("close", this.onWsClose);
      oldWs.destroy();
    }
    const oldUdp = Reflect.get(this._state, "udp");
    const newUdp = Reflect.get(newState, "udp");
    if (oldUdp && oldUdp !== newUdp) {
      oldUdp.on("error", noop);
      oldUdp.off("error", this.onChildError);
      oldUdp.off("close", this.onUdpClose);
      oldUdp.off("debug", this.onUdpDebug);
      oldUdp.destroy();
    }
    const oldState = this._state;
    this._state = newState;
    this.emit("stateChange", oldState, newState);
    this.debug?.(`state change:
from ${stringifyState(oldState)}
to ${stringifyState(newState)}`);
  }
  /**
   * Creates a new WebSocket to a Discord Voice gateway.
   *
   * @param endpoint - The endpoint to connect to
   */
  createWebSocket(endpoint) {
    const ws = new VoiceWebSocket(`wss://${endpoint}?v=4`, Boolean(this.debug));
    ws.on("error", this.onChildError);
    ws.once("open", this.onWsOpen);
    ws.on("packet", this.onWsPacket);
    ws.once("close", this.onWsClose);
    ws.on("debug", this.onWsDebug);
    return ws;
  }
  /**
   * Propagates errors from the children VoiceWebSocket and VoiceUDPSocket.
   *
   * @param error - The error that was emitted by a child
   */
  onChildError(error) {
    this.emit("error", error);
  }
  /**
   * Called when the WebSocket opens. Depending on the state that the instance is in,
   * it will either identify with a new session, or it will attempt to resume an existing session.
   */
  onWsOpen() {
    if (this.state.code === 0 /* OpeningWs */) {
      const packet = {
        op: import_v42.VoiceOpcodes.Identify,
        d: {
          server_id: this.state.connectionOptions.serverId,
          user_id: this.state.connectionOptions.userId,
          session_id: this.state.connectionOptions.sessionId,
          token: this.state.connectionOptions.token
        }
      };
      this.state.ws.sendPacket(packet);
      this.state = {
        ...this.state,
        code: 1 /* Identifying */
      };
    } else if (this.state.code === 5 /* Resuming */) {
      const packet = {
        op: import_v42.VoiceOpcodes.Resume,
        d: {
          server_id: this.state.connectionOptions.serverId,
          session_id: this.state.connectionOptions.sessionId,
          token: this.state.connectionOptions.token
        }
      };
      this.state.ws.sendPacket(packet);
    }
  }
  /**
   * Called when the WebSocket closes. Based on the reason for closing (given by the code parameter),
   * the instance will either attempt to resume, or enter the closed state and emit a 'close' event
   * with the close code, allowing the user to decide whether or not they would like to reconnect.
   *
   * @param code - The close code
   */
  onWsClose({ code }) {
    const canResume = code === 4015 || code < 4e3;
    if (canResume && this.state.code === 4 /* Ready */) {
      this.state = {
        ...this.state,
        code: 5 /* Resuming */,
        ws: this.createWebSocket(this.state.connectionOptions.endpoint)
      };
    } else if (this.state.code !== 6 /* Closed */) {
      this.destroy();
      this.emit("close", code);
    }
  }
  /**
   * Called when the UDP socket has closed itself if it has stopped receiving replies from Discord.
   */
  onUdpClose() {
    if (this.state.code === 4 /* Ready */) {
      this.state = {
        ...this.state,
        code: 5 /* Resuming */,
        ws: this.createWebSocket(this.state.connectionOptions.endpoint)
      };
    }
  }
  /**
   * Called when a packet is received on the connection's WebSocket.
   *
   * @param packet - The received packet
   */
  onWsPacket(packet) {
    if (packet.op === import_v42.VoiceOpcodes.Hello && this.state.code !== 6 /* Closed */) {
      this.state.ws.setHeartbeatInterval(packet.d.heartbeat_interval);
    } else if (packet.op === import_v42.VoiceOpcodes.Ready && this.state.code === 1 /* Identifying */) {
      const { ip, port, ssrc, modes } = packet.d;
      const udp = new VoiceUDPSocket({ ip, port });
      udp.on("error", this.onChildError);
      udp.on("debug", this.onUdpDebug);
      udp.once("close", this.onUdpClose);
      udp.performIPDiscovery(ssrc).then((localConfig) => {
        if (this.state.code !== 2 /* UdpHandshaking */) return;
        this.state.ws.sendPacket({
          op: import_v42.VoiceOpcodes.SelectProtocol,
          d: {
            protocol: "udp",
            data: {
              address: localConfig.ip,
              port: localConfig.port,
              mode: chooseEncryptionMode(modes)
            }
          }
        });
        this.state = {
          ...this.state,
          code: 3 /* SelectingProtocol */
        };
      }).catch((error) => this.emit("error", error));
      this.state = {
        ...this.state,
        code: 2 /* UdpHandshaking */,
        udp,
        connectionData: {
          ssrc
        }
      };
    } else if (packet.op === import_v42.VoiceOpcodes.SessionDescription && this.state.code === 3 /* SelectingProtocol */) {
      const { mode: encryptionMode, secret_key: secretKey } = packet.d;
      this.state = {
        ...this.state,
        code: 4 /* Ready */,
        connectionData: {
          ...this.state.connectionData,
          encryptionMode,
          secretKey: new Uint8Array(secretKey),
          sequence: randomNBit(16),
          timestamp: randomNBit(32),
          nonce: 0,
          nonceBuffer: encryptionMode === "aead_aes256_gcm_rtpsize" ? import_node_buffer3.Buffer.alloc(12) : import_node_buffer3.Buffer.alloc(24),
          speaking: false,
          packetsPlayed: 0
        }
      };
    } else if (packet.op === import_v42.VoiceOpcodes.Resumed && this.state.code === 5 /* Resuming */) {
      this.state = {
        ...this.state,
        code: 4 /* Ready */
      };
      this.state.connectionData.speaking = false;
    }
  }
  /**
   * Propagates debug messages from the child WebSocket.
   *
   * @param message - The emitted debug message
   */
  onWsDebug(message) {
    this.debug?.(`[WS] ${message}`);
  }
  /**
   * Propagates debug messages from the child UDPSocket.
   *
   * @param message - The emitted debug message
   */
  onUdpDebug(message) {
    this.debug?.(`[UDP] ${message}`);
  }
  /**
   * Prepares an Opus packet for playback. This includes attaching metadata to it and encrypting it.
   * It will be stored within the instance, and can be played by dispatchAudio()
   *
   * @remarks
   * Calling this method while there is already a prepared audio packet that has not yet been dispatched
   * will overwrite the existing audio packet. This should be avoided.
   * @param opusPacket - The Opus packet to encrypt
   * @returns The audio packet that was prepared
   */
  prepareAudioPacket(opusPacket) {
    const state = this.state;
    if (state.code !== 4 /* Ready */) return;
    state.preparedPacket = this.createAudioPacket(opusPacket, state.connectionData);
    return state.preparedPacket;
  }
  /**
   * Dispatches the audio packet previously prepared by prepareAudioPacket(opusPacket). The audio packet
   * is consumed and cannot be dispatched again.
   */
  dispatchAudio() {
    const state = this.state;
    if (state.code !== 4 /* Ready */) return false;
    if (state.preparedPacket !== void 0) {
      this.playAudioPacket(state.preparedPacket);
      state.preparedPacket = void 0;
      return true;
    }
    return false;
  }
  /**
   * Plays an audio packet, updating timing metadata used for playback.
   *
   * @param audioPacket - The audio packet to play
   */
  playAudioPacket(audioPacket) {
    const state = this.state;
    if (state.code !== 4 /* Ready */) return;
    const { connectionData } = state;
    connectionData.packetsPlayed++;
    connectionData.sequence++;
    connectionData.timestamp += TIMESTAMP_INC;
    if (connectionData.sequence >= 2 ** 16) connectionData.sequence = 0;
    if (connectionData.timestamp >= 2 ** 32) connectionData.timestamp = 0;
    this.setSpeaking(true);
    state.udp.send(audioPacket);
  }
  /**
   * Sends a packet to the voice gateway indicating that the client has start/stopped sending
   * audio.
   *
   * @param speaking - Whether or not the client should be shown as speaking
   */
  setSpeaking(speaking) {
    const state = this.state;
    if (state.code !== 4 /* Ready */) return;
    if (state.connectionData.speaking === speaking) return;
    state.connectionData.speaking = speaking;
    state.ws.sendPacket({
      op: import_v42.VoiceOpcodes.Speaking,
      d: {
        speaking: speaking ? 1 : 0,
        delay: 0,
        ssrc: state.connectionData.ssrc
      }
    });
  }
  /**
   * Creates a new audio packet from an Opus packet. This involves encrypting the packet,
   * then prepending a header that includes metadata.
   *
   * @param opusPacket - The Opus packet to prepare
   * @param connectionData - The current connection data of the instance
   */
  createAudioPacket(opusPacket, connectionData) {
    const packetBuffer = import_node_buffer3.Buffer.alloc(12);
    packetBuffer[0] = 128;
    packetBuffer[1] = 120;
    const { sequence, timestamp, ssrc } = connectionData;
    packetBuffer.writeUIntBE(sequence, 2, 2);
    packetBuffer.writeUIntBE(timestamp, 4, 4);
    packetBuffer.writeUIntBE(ssrc, 8, 4);
    packetBuffer.copy(nonce, 0, 0, 12);
    return import_node_buffer3.Buffer.concat([packetBuffer, ...this.encryptOpusPacket(opusPacket, connectionData, packetBuffer)]);
  }
  /**
   * Encrypts an Opus packet using the format agreed upon by the instance and Discord.
   *
   * @param opusPacket - The Opus packet to encrypt
   * @param connectionData - The current connection data of the instance
   */
  encryptOpusPacket(opusPacket, connectionData, data) {
    const { secretKey, encryptionMode } = connectionData;
    connectionData.nonce++;
    if (connectionData.nonce > MAX_NONCE_SIZE) connectionData.nonce = 0;
    connectionData.nonceBuffer.writeUInt32BE(connectionData.nonce, 0);
    const noncePadding = connectionData.nonceBuffer.subarray(0, 4);
    let encrypted;
    switch (encryptionMode) {
      case "aead_aes256_gcm_rtpsize": {
        const cipher = import_node_crypto.default.createCipheriv("aes-256-gcm", secretKey, connectionData.nonceBuffer);
        cipher.setAAD(data);
        encrypted = import_node_buffer3.Buffer.concat([cipher.update(opusPacket), cipher.final(), cipher.getAuthTag()]);
        return [encrypted, noncePadding];
      }
      case "aead_xchacha20_poly1305_rtpsize": {
        encrypted = methods.crypto_aead_xchacha20poly1305_ietf_encrypt(
          opusPacket,
          data,
          connectionData.nonceBuffer,
          secretKey
        );
        return [encrypted, noncePadding];
      }
      default: {
        throw new RangeError(`Unsupported encryption method: ${encryptionMode}`);
      }
    }
  }
};
__name(_Networking, "Networking");
var Networking = _Networking;

// src/VoiceConnection.ts
var VoiceConnectionStatus = /* @__PURE__ */ ((VoiceConnectionStatus2) => {
  VoiceConnectionStatus2["Connecting"] = "connecting";
  VoiceConnectionStatus2["Destroyed"] = "destroyed";
  VoiceConnectionStatus2["Disconnected"] = "disconnected";
  VoiceConnectionStatus2["Ready"] = "ready";
  VoiceConnectionStatus2["Signalling"] = "signalling";
  return VoiceConnectionStatus2;
})(VoiceConnectionStatus || {});
var VoiceConnectionDisconnectReason = /* @__PURE__ */ ((VoiceConnectionDisconnectReason2) => {
  VoiceConnectionDisconnectReason2[VoiceConnectionDisconnectReason2["WebSocketClose"] = 0] = "WebSocketClose";
  VoiceConnectionDisconnectReason2[VoiceConnectionDisconnectReason2["AdapterUnavailable"] = 1] = "AdapterUnavailable";
  VoiceConnectionDisconnectReason2[VoiceConnectionDisconnectReason2["EndpointRemoved"] = 2] = "EndpointRemoved";
  VoiceConnectionDisconnectReason2[VoiceConnectionDisconnectReason2["Manual"] = 3] = "Manual";
  return VoiceConnectionDisconnectReason2;
})(VoiceConnectionDisconnectReason || {});
var _VoiceConnection = class _VoiceConnection extends import_node_events4.EventEmitter {
  /**
   * Creates a new voice connection.
   *
   * @param joinConfig - The data required to establish the voice connection
   * @param options - The options used to create this voice connection
   */
  constructor(joinConfig, options) {
    super();
    /**
     * The number of consecutive rejoin attempts. Initially 0, and increments for each rejoin.
     * When a connection is successfully established, it resets to 0.
     */
    __publicField(this, "rejoinAttempts");
    /**
     * The state of the voice connection.
     */
    __publicField(this, "_state");
    /**
     * A configuration storing all the data needed to reconnect to a Guild's voice server.
     *
     * @internal
     */
    __publicField(this, "joinConfig");
    /**
     * The two packets needed to successfully establish a voice connection. They are received
     * from the main Discord gateway after signalling to change the voice state.
     */
    __publicField(this, "packets");
    /**
     * The debug logger function, if debugging is enabled.
     */
    __publicField(this, "debug");
    this.debug = options.debug ? (message) => this.emit("debug", message) : null;
    this.rejoinAttempts = 0;
    this.onNetworkingClose = this.onNetworkingClose.bind(this);
    this.onNetworkingStateChange = this.onNetworkingStateChange.bind(this);
    this.onNetworkingError = this.onNetworkingError.bind(this);
    this.onNetworkingDebug = this.onNetworkingDebug.bind(this);
    const adapter = options.adapterCreator({
      onVoiceServerUpdate: /* @__PURE__ */ __name((data) => this.addServerPacket(data), "onVoiceServerUpdate"),
      onVoiceStateUpdate: /* @__PURE__ */ __name((data) => this.addStatePacket(data), "onVoiceStateUpdate"),
      destroy: /* @__PURE__ */ __name(() => this.destroy(false), "destroy")
    });
    this._state = { status: "signalling" /* Signalling */, adapter };
    this.packets = {
      server: void 0,
      state: void 0
    };
    this.joinConfig = joinConfig;
  }
  /**
   * The current state of the voice connection.
   */
  get state() {
    return this._state;
  }
  /**
   * Updates the state of the voice connection, performing clean-up operations where necessary.
   */
  set state(newState) {
    const oldState = this._state;
    const oldNetworking = Reflect.get(oldState, "networking");
    const newNetworking = Reflect.get(newState, "networking");
    const oldSubscription = Reflect.get(oldState, "subscription");
    const newSubscription = Reflect.get(newState, "subscription");
    if (oldNetworking !== newNetworking) {
      if (oldNetworking) {
        oldNetworking.on("error", noop);
        oldNetworking.off("debug", this.onNetworkingDebug);
        oldNetworking.off("error", this.onNetworkingError);
        oldNetworking.off("close", this.onNetworkingClose);
        oldNetworking.off("stateChange", this.onNetworkingStateChange);
        oldNetworking.destroy();
      }
    }
    if (newState.status === "ready" /* Ready */) {
      this.rejoinAttempts = 0;
    }
    if (oldState.status !== "destroyed" /* Destroyed */ && newState.status === "destroyed" /* Destroyed */) {
      oldState.adapter.destroy();
    }
    this._state = newState;
    if (oldSubscription && oldSubscription !== newSubscription) {
      oldSubscription.unsubscribe();
    }
    this.emit("stateChange", oldState, newState);
    if (oldState.status !== newState.status) {
      this.emit(newState.status, oldState, newState);
    }
  }
  /**
   * Registers a `VOICE_SERVER_UPDATE` packet to the voice connection. This will cause it to reconnect using the
   * new data provided in the packet.
   *
   * @param packet - The received `VOICE_SERVER_UPDATE` packet
   */
  addServerPacket(packet) {
    this.packets.server = packet;
    if (packet.endpoint) {
      this.configureNetworking();
    } else if (this.state.status !== "destroyed" /* Destroyed */) {
      this.state = {
        ...this.state,
        status: "disconnected" /* Disconnected */,
        reason: 2 /* EndpointRemoved */
      };
    }
  }
  /**
   * Registers a `VOICE_STATE_UPDATE` packet to the voice connection. Most importantly, it stores the id of the
   * channel that the client is connected to.
   *
   * @param packet - The received `VOICE_STATE_UPDATE` packet
   */
  addStatePacket(packet) {
    this.packets.state = packet;
    if (packet.self_deaf !== void 0) this.joinConfig.selfDeaf = packet.self_deaf;
    if (packet.self_mute !== void 0) this.joinConfig.selfMute = packet.self_mute;
    if (packet.channel_id) this.joinConfig.channelId = packet.channel_id;
  }
  /**
   * Attempts to configure a networking instance for this voice connection using the received packets.
   * Both packets are required, and any existing networking instance will be destroyed.
   *
   * @remarks
   * This is called when the voice server of the connection changes, e.g. if the bot is moved into a
   * different channel in the same guild but has a different voice server. In this instance, the connection
   * needs to be re-established to the new voice server.
   *
   * The connection will transition to the Connecting state when this is called.
   */
  configureNetworking() {
    const { server, state } = this.packets;
    if (!server || !state || this.state.status === "destroyed" /* Destroyed */ || !server.endpoint) return;
    const networking = new Networking(
      {
        endpoint: server.endpoint,
        serverId: server.guild_id,
        token: server.token,
        sessionId: state.session_id,
        userId: state.user_id
      },
      Boolean(this.debug)
    );
    networking.once("close", this.onNetworkingClose);
    networking.on("stateChange", this.onNetworkingStateChange);
    networking.on("error", this.onNetworkingError);
    networking.on("debug", this.onNetworkingDebug);
    this.state = {
      ...this.state,
      status: "connecting" /* Connecting */,
      networking
    };
  }
  /**
   * Called when the networking instance for this connection closes. If the close code is 4014 (do not reconnect),
   * the voice connection will transition to the Disconnected state which will store the close code. You can
   * decide whether or not to reconnect when this occurs by listening for the state change and calling reconnect().
   *
   * @remarks
   * If the close code was anything other than 4014, it is likely that the closing was not intended, and so the
   * VoiceConnection will signal to Discord that it would like to rejoin the channel. This automatically attempts
   * to re-establish the connection. This would be seen as a transition from the Ready state to the Signalling state.
   * @param code - The close code
   */
  onNetworkingClose(code) {
    if (this.state.status === "destroyed" /* Destroyed */) return;
    if (code === 4014) {
      this.state = {
        ...this.state,
        status: "disconnected" /* Disconnected */,
        reason: 0 /* WebSocketClose */,
        closeCode: code
      };
    } else {
      this.state = {
        ...this.state,
        status: "signalling" /* Signalling */
      };
      this.rejoinAttempts++;
      if (!this.state.adapter.sendPayload(createJoinVoiceChannelPayload(this.joinConfig))) {
        this.state = {
          ...this.state,
          status: "disconnected" /* Disconnected */,
          reason: 1 /* AdapterUnavailable */
        };
      }
    }
  }
  /**
   * Called when the state of the networking instance changes. This is used to derive the state of the voice connection.
   *
   * @param oldState - The previous state
   * @param newState - The new state
   */
  onNetworkingStateChange(oldState, newState) {
    if (oldState.code === newState.code) return;
    if (this.state.status !== "connecting" /* Connecting */ && this.state.status !== "ready" /* Ready */)
      return;
    if (newState.code === 4 /* Ready */) {
      this.state = {
        ...this.state,
        status: "ready" /* Ready */
      };
    } else if (newState.code !== 6 /* Closed */) {
      this.state = {
        ...this.state,
        status: "connecting" /* Connecting */
      };
    }
  }
  /**
   * Propagates errors from the underlying network instance.
   *
   * @param error - The error to propagate
   */
  onNetworkingError(error) {
    this.emit("error", error);
  }
  /**
   * Propagates debug messages from the underlying network instance.
   *
   * @param message - The debug message to propagate
   */
  onNetworkingDebug(message) {
    this.debug?.(`[NW] ${message}`);
  }
  /**
   * Prepares an audio packet for dispatch.
   *
   * @param buffer - The Opus packet to prepare
   */
  prepareAudioPacket(buffer) {
    const state = this.state;
    if (state.status !== "ready" /* Ready */) return;
    return state.networking.prepareAudioPacket(buffer);
  }
  /**
   * Dispatches the previously prepared audio packet (if any)
   */
  dispatchAudio() {
    const state = this.state;
    if (state.status !== "ready" /* Ready */) return;
    return state.networking.dispatchAudio();
  }
  /**
   * Prepares an audio packet and dispatches it immediately.
   *
   * @param buffer - The Opus packet to play
   */
  playOpusPacket(buffer) {
    const state = this.state;
    if (state.status !== "ready" /* Ready */) return;
    state.networking.prepareAudioPacket(buffer);
    return state.networking.dispatchAudio();
  }
  /**
   * Destroys the VoiceConnection, preventing it from connecting to voice again.
   * This method should be called when you no longer require the VoiceConnection to
   * prevent memory leaks.
   *
   * @param adapterAvailable - Whether the adapter can be used
   */
  destroy(adapterAvailable = true) {
    if (this.state.status === "destroyed" /* Destroyed */) {
      throw new Error("Cannot destroy VoiceConnection - it has already been destroyed");
    }
    if (getVoiceConnection(this.joinConfig.guildId, this.joinConfig.group) === this) {
      untrackVoiceConnection(this);
    }
    if (adapterAvailable) {
      this.state.adapter.sendPayload(createJoinVoiceChannelPayload({ ...this.joinConfig, channelId: null }));
    }
    this.state = {
      status: "destroyed" /* Destroyed */
    };
  }
  /**
   * Disconnects the VoiceConnection, allowing the possibility of rejoining later on.
   *
   * @returns `true` if the connection was successfully disconnected
   */
  disconnect() {
    if (this.state.status === "destroyed" /* Destroyed */ || this.state.status === "signalling" /* Signalling */) {
      return false;
    }
    this.joinConfig.channelId = null;
    if (!this.state.adapter.sendPayload(createJoinVoiceChannelPayload(this.joinConfig))) {
      this.state = {
        adapter: this.state.adapter,
        subscription: this.state.subscription,
        status: "disconnected" /* Disconnected */,
        reason: 1 /* AdapterUnavailable */
      };
      return false;
    }
    this.state = {
      adapter: this.state.adapter,
      reason: 3 /* Manual */,
      status: "disconnected" /* Disconnected */
    };
    return true;
  }
  /**
   * Attempts to rejoin (better explanation soon:tm:)
   *
   * @remarks
   * Calling this method successfully will automatically increment the `rejoinAttempts` counter,
   * which you can use to inform whether or not you'd like to keep attempting to reconnect your
   * voice connection.
   *
   * A state transition from Disconnected to Signalling will be observed when this is called.
   */
  rejoin(joinConfig) {
    if (this.state.status === "destroyed" /* Destroyed */) {
      return false;
    }
    const notReady = this.state.status !== "ready" /* Ready */;
    if (notReady) this.rejoinAttempts++;
    Object.assign(this.joinConfig, joinConfig);
    if (this.state.adapter.sendPayload(createJoinVoiceChannelPayload(this.joinConfig))) {
      if (notReady) {
        this.state = {
          ...this.state,
          status: "signalling" /* Signalling */
        };
      }
      return true;
    }
    this.state = {
      adapter: this.state.adapter,
      subscription: this.state.subscription,
      status: "disconnected" /* Disconnected */,
      reason: 1 /* AdapterUnavailable */
    };
    return false;
  }
  /**
   * Updates the speaking status of the voice connection. This is used when audio players are done playing audio,
   * and need to signal that the connection is no longer playing audio.
   *
   * @param enabled - Whether or not to show as speaking
   */
  setSpeaking(enabled) {
    if (this.state.status !== "ready" /* Ready */) return false;
    return this.state.networking.setSpeaking(enabled);
  }
  /**
   * Subscribes to an audio player, allowing the player to play audio on this voice connection.
   *
   * @param player - The audio player to subscribe to
   * @returns The created subscription
   */
  subscribe(player) {
    if (this.state.status === "destroyed" /* Destroyed */) return;
    const subscription = player["subscribe"](this);
    this.state = {
      ...this.state,
      subscription
    };
    return subscription;
  }
  /**
   * The latest ping (in milliseconds) for the WebSocket connection and audio playback for this voice
   * connection, if this data is available.
   *
   * @remarks
   * For this data to be available, the VoiceConnection must be in the Ready state, and its underlying
   * WebSocket connection and UDP socket must have had at least one ping-pong exchange.
   */
  get ping() {
    if (this.state.status === "ready" /* Ready */ && this.state.networking.state.code === 4 /* Ready */) {
      return {
        ws: this.state.networking.state.ws.ping,
        udp: this.state.networking.state.udp.ping
      };
    }
    return {
      ws: void 0,
      udp: void 0
    };
  }
  /**
   * Called when a subscription of this voice connection to an audio player is removed.
   *
   * @param subscription - The removed subscription
   */
  onSubscriptionRemoved(subscription) {
    if (this.state.status !== "destroyed" /* Destroyed */ && this.state.subscription === subscription) {
      this.state = {
        ...this.state,
        subscription: void 0
      };
    }
  }
};
__name(_VoiceConnection, "VoiceConnection");
var VoiceConnection = _VoiceConnection;
function createVoiceConnection(joinConfig, options) {
  const payload = createJoinVoiceChannelPayload(joinConfig);
  const existing = getVoiceConnection(joinConfig.guildId, joinConfig.group);
  if (existing && existing.state.status !== "destroyed" /* Destroyed */) {
    if (existing.state.status === "disconnected" /* Disconnected */) {
      existing.rejoin({
        channelId: joinConfig.channelId,
        selfDeaf: joinConfig.selfDeaf,
        selfMute: joinConfig.selfMute
      });
    } else if (!existing.state.adapter.sendPayload(payload)) {
      existing.state = {
        ...existing.state,
        status: "disconnected" /* Disconnected */,
        reason: 1 /* AdapterUnavailable */
      };
    }
    return existing;
  }
  const voiceConnection = new VoiceConnection(joinConfig, options);
  trackVoiceConnection(voiceConnection);
  if (voiceConnection.state.status !== "destroyed" /* Destroyed */ && !voiceConnection.state.adapter.sendPayload(payload)) {
    voiceConnection.state = {
      ...voiceConnection.state,
      status: "disconnected" /* Disconnected */,
      reason: 1 /* AdapterUnavailable */
    };
  }
  return voiceConnection;
}
__name(createVoiceConnection, "createVoiceConnection");

// src/joinVoiceChannel.ts
function joinVoiceChannel(options) {
  const joinConfig = {
    selfDeaf: true,
    selfMute: false,
    group: "default",
    ...options
  };
  return createVoiceConnection(joinConfig, {
    adapterCreator: options.adapterCreator,
    debug: options.debug
  });
}
__name(joinVoiceChannel, "joinVoiceChannel");

// src/audio/AudioPlayer.ts
var import_node_buffer4 = require("buffer");
var import_node_events5 = require("events");

// src/audio/AudioPlayerError.ts
var _AudioPlayerError = class _AudioPlayerError extends Error {
  constructor(error, resource) {
    super(error.message);
    /**
     * The resource associated with the audio player at the time the error was thrown.
     */
    __publicField(this, "resource");
    this.resource = resource;
    this.name = error.name;
    this.stack = error.stack;
  }
};
__name(_AudioPlayerError, "AudioPlayerError");
var AudioPlayerError = _AudioPlayerError;

// src/audio/PlayerSubscription.ts
var _PlayerSubscription = class _PlayerSubscription {
  constructor(connection, player) {
    /**
     * The voice connection of this subscription.
     */
    __publicField(this, "connection");
    /**
     * The audio player of this subscription.
     */
    __publicField(this, "player");
    this.connection = connection;
    this.player = player;
  }
  /**
   * Unsubscribes the connection from the audio player, meaning that the
   * audio player cannot stream audio to it until a new subscription is made.
   */
  unsubscribe() {
    this.connection["onSubscriptionRemoved"](this);
    this.player["unsubscribe"](this);
  }
};
__name(_PlayerSubscription, "PlayerSubscription");
var PlayerSubscription = _PlayerSubscription;

// src/audio/AudioPlayer.ts
var SILENCE_FRAME = import_node_buffer4.Buffer.from([248, 255, 254]);
var NoSubscriberBehavior = /* @__PURE__ */ ((NoSubscriberBehavior2) => {
  NoSubscriberBehavior2["Pause"] = "pause";
  NoSubscriberBehavior2["Play"] = "play";
  NoSubscriberBehavior2["Stop"] = "stop";
  return NoSubscriberBehavior2;
})(NoSubscriberBehavior || {});
var AudioPlayerStatus = /* @__PURE__ */ ((AudioPlayerStatus2) => {
  AudioPlayerStatus2["AutoPaused"] = "autopaused";
  AudioPlayerStatus2["Buffering"] = "buffering";
  AudioPlayerStatus2["Idle"] = "idle";
  AudioPlayerStatus2["Paused"] = "paused";
  AudioPlayerStatus2["Playing"] = "playing";
  return AudioPlayerStatus2;
})(AudioPlayerStatus || {});
function stringifyState2(state) {
  return JSON.stringify({
    ...state,
    resource: Reflect.has(state, "resource"),
    stepTimeout: Reflect.has(state, "stepTimeout")
  });
}
__name(stringifyState2, "stringifyState");
var _AudioPlayer = class _AudioPlayer extends import_node_events5.EventEmitter {
  /**
   * Creates a new AudioPlayer.
   */
  constructor(options = {}) {
    super();
    /**
     * The state that the AudioPlayer is in.
     */
    __publicField(this, "_state");
    /**
     * A list of VoiceConnections that are registered to this AudioPlayer. The player will attempt to play audio
     * to the streams in this list.
     */
    __publicField(this, "subscribers", []);
    /**
     * The behavior that the player should follow when it enters certain situations.
     */
    __publicField(this, "behaviors");
    /**
     * The debug logger function, if debugging is enabled.
     */
    __publicField(this, "debug");
    this._state = { status: "idle" /* Idle */ };
    this.behaviors = {
      noSubscriber: "pause" /* Pause */,
      maxMissedFrames: 5,
      ...options.behaviors
    };
    this.debug = options.debug === false ? null : (message) => this.emit("debug", message);
  }
  /**
   * A list of subscribed voice connections that can currently receive audio to play.
   */
  get playable() {
    return this.subscribers.filter(({ connection }) => connection.state.status === "ready" /* Ready */).map(({ connection }) => connection);
  }
  /**
   * Subscribes a VoiceConnection to the audio player's play list. If the VoiceConnection is already subscribed,
   * then the existing subscription is used.
   *
   * @remarks
   * This method should not be directly called. Instead, use VoiceConnection#subscribe.
   * @param connection - The connection to subscribe
   * @returns The new subscription if the voice connection is not yet subscribed, otherwise the existing subscription
   */
  // @ts-ignore
  subscribe(connection) {
    const existingSubscription = this.subscribers.find((subscription) => subscription.connection === connection);
    if (!existingSubscription) {
      const subscription = new PlayerSubscription(connection, this);
      this.subscribers.push(subscription);
      setImmediate(() => this.emit("subscribe", subscription));
      return subscription;
    }
    return existingSubscription;
  }
  /**
   * Unsubscribes a subscription - i.e. removes a voice connection from the play list of the audio player.
   *
   * @remarks
   * This method should not be directly called. Instead, use PlayerSubscription#unsubscribe.
   * @param subscription - The subscription to remove
   * @returns Whether or not the subscription existed on the player and was removed
   */
  // @ts-ignore
  unsubscribe(subscription) {
    const index = this.subscribers.indexOf(subscription);
    const exists = index !== -1;
    if (exists) {
      this.subscribers.splice(index, 1);
      subscription.connection.setSpeaking(false);
      this.emit("unsubscribe", subscription);
    }
    return exists;
  }
  /**
   * The state that the player is in.
   */
  get state() {
    return this._state;
  }
  /**
   * Sets a new state for the player, performing clean-up operations where necessary.
   */
  set state(newState) {
    const oldState = this._state;
    const newResource = Reflect.get(newState, "resource");
    if (oldState.status !== "idle" /* Idle */ && oldState.resource !== newResource) {
      oldState.resource.playStream.on("error", noop);
      oldState.resource.playStream.off("error", oldState.onStreamError);
      oldState.resource.audioPlayer = void 0;
      oldState.resource.playStream.destroy();
      oldState.resource.playStream.read();
    }
    if (oldState.status === "buffering" /* Buffering */ && (newState.status !== "buffering" /* Buffering */ || newState.resource !== oldState.resource)) {
      oldState.resource.playStream.off("end", oldState.onFailureCallback);
      oldState.resource.playStream.off("close", oldState.onFailureCallback);
      oldState.resource.playStream.off("finish", oldState.onFailureCallback);
      oldState.resource.playStream.off("readable", oldState.onReadableCallback);
    }
    if (newState.status === "idle" /* Idle */) {
      this._signalStopSpeaking();
      deleteAudioPlayer(this);
    }
    if (newResource) {
      addAudioPlayer(this);
    }
    const didChangeResources = oldState.status !== "idle" /* Idle */ && newState.status === "playing" /* Playing */ && oldState.resource !== newState.resource;
    this._state = newState;
    this.emit("stateChange", oldState, this._state);
    if (oldState.status !== newState.status || didChangeResources) {
      this.emit(newState.status, oldState, this._state);
    }
    this.debug?.(`state change:
from ${stringifyState2(oldState)}
to ${stringifyState2(newState)}`);
  }
  /**
   * Plays a new resource on the player. If the player is already playing a resource, the existing resource is destroyed
   * (it cannot be reused, even in another player) and is replaced with the new resource.
   *
   * @remarks
   * The player will transition to the Playing state once playback begins, and will return to the Idle state once
   * playback is ended.
   *
   * If the player was previously playing a resource and this method is called, the player will not transition to the
   * Idle state during the swap over.
   * @param resource - The resource to play
   * @throws Will throw if attempting to play an audio resource that has already ended, or is being played by another player
   */
  play(resource) {
    if (resource.ended) {
      throw new Error("Cannot play a resource that has already ended.");
    }
    if (resource.audioPlayer) {
      if (resource.audioPlayer === this) {
        return;
      }
      throw new Error("Resource is already being played by another audio player.");
    }
    resource.audioPlayer = this;
    const onStreamError = /* @__PURE__ */ __name((error) => {
      if (this.state.status !== "idle" /* Idle */) {
        this.emit("error", new AudioPlayerError(error, this.state.resource));
      }
      if (this.state.status !== "idle" /* Idle */ && this.state.resource === resource) {
        this.state = {
          status: "idle" /* Idle */
        };
      }
    }, "onStreamError");
    resource.playStream.once("error", onStreamError);
    if (resource.started) {
      this.state = {
        status: "playing" /* Playing */,
        missedFrames: 0,
        playbackDuration: 0,
        resource,
        onStreamError
      };
    } else {
      const onReadableCallback = /* @__PURE__ */ __name(() => {
        if (this.state.status === "buffering" /* Buffering */ && this.state.resource === resource) {
          this.state = {
            status: "playing" /* Playing */,
            missedFrames: 0,
            playbackDuration: 0,
            resource,
            onStreamError
          };
        }
      }, "onReadableCallback");
      const onFailureCallback = /* @__PURE__ */ __name(() => {
        if (this.state.status === "buffering" /* Buffering */ && this.state.resource === resource) {
          this.state = {
            status: "idle" /* Idle */
          };
        }
      }, "onFailureCallback");
      resource.playStream.once("readable", onReadableCallback);
      resource.playStream.once("end", onFailureCallback);
      resource.playStream.once("close", onFailureCallback);
      resource.playStream.once("finish", onFailureCallback);
      this.state = {
        status: "buffering" /* Buffering */,
        resource,
        onReadableCallback,
        onFailureCallback,
        onStreamError
      };
    }
  }
  /**
   * Pauses playback of the current resource, if any.
   *
   * @param interpolateSilence - If true, the player will play 5 packets of silence after pausing to prevent audio glitches
   * @returns `true` if the player was successfully paused, otherwise `false`
   */
  pause(interpolateSilence = true) {
    if (this.state.status !== "playing" /* Playing */) return false;
    this.state = {
      ...this.state,
      status: "paused" /* Paused */,
      silencePacketsRemaining: interpolateSilence ? 5 : 0
    };
    return true;
  }
  /**
   * Unpauses playback of the current resource, if any.
   *
   * @returns `true` if the player was successfully unpaused, otherwise `false`
   */
  unpause() {
    if (this.state.status !== "paused" /* Paused */) return false;
    this.state = {
      ...this.state,
      status: "playing" /* Playing */,
      missedFrames: 0
    };
    return true;
  }
  /**
   * Stops playback of the current resource and destroys the resource. The player will either transition to the Idle state,
   * or remain in its current state until the silence padding frames of the resource have been played.
   *
   * @param force - If true, will force the player to enter the Idle state even if the resource has silence padding frames
   * @returns `true` if the player will come to a stop, otherwise `false`
   */
  stop(force = false) {
    if (this.state.status === "idle" /* Idle */) return false;
    if (force || this.state.resource.silencePaddingFrames === 0) {
      this.state = {
        status: "idle" /* Idle */
      };
    } else if (this.state.resource.silenceRemaining === -1) {
      this.state.resource.silenceRemaining = this.state.resource.silencePaddingFrames;
    }
    return true;
  }
  /**
   * Checks whether the underlying resource (if any) is playable (readable)
   *
   * @returns `true` if the resource is playable, otherwise `false`
   */
  checkPlayable() {
    const state = this._state;
    if (state.status === "idle" /* Idle */ || state.status === "buffering" /* Buffering */) return false;
    if (!state.resource.readable) {
      this.state = {
        status: "idle" /* Idle */
      };
      return false;
    }
    return true;
  }
  /**
   * Called roughly every 20ms by the global audio player timer. Dispatches any audio packets that are buffered
   * by the active connections of this audio player.
   */
  // @ts-ignore
  _stepDispatch() {
    const state = this._state;
    if (state.status === "idle" /* Idle */ || state.status === "buffering" /* Buffering */) return;
    for (const connection of this.playable) {
      connection.dispatchAudio();
    }
  }
  /**
   * Called roughly every 20ms by the global audio player timer. Attempts to read an audio packet from the
   * underlying resource of the stream, and then has all the active connections of the audio player prepare it
   * (encrypt it, append header data) so that it is ready to play at the start of the next cycle.
   */
  // @ts-ignore
  _stepPrepare() {
    const state = this._state;
    if (state.status === "idle" /* Idle */ || state.status === "buffering" /* Buffering */) return;
    const playable = this.playable;
    if (state.status === "autopaused" /* AutoPaused */ && playable.length > 0) {
      this.state = {
        ...state,
        status: "playing" /* Playing */,
        missedFrames: 0
      };
    }
    if (state.status === "paused" /* Paused */ || state.status === "autopaused" /* AutoPaused */) {
      if (state.silencePacketsRemaining > 0) {
        state.silencePacketsRemaining--;
        this._preparePacket(SILENCE_FRAME, playable, state);
        if (state.silencePacketsRemaining === 0) {
          this._signalStopSpeaking();
        }
      }
      return;
    }
    if (playable.length === 0) {
      if (this.behaviors.noSubscriber === "pause" /* Pause */) {
        this.state = {
          ...state,
          status: "autopaused" /* AutoPaused */,
          silencePacketsRemaining: 5
        };
        return;
      } else if (this.behaviors.noSubscriber === "stop" /* Stop */) {
        this.stop(true);
      }
    }
    const packet = state.resource.read();
    if (state.status === "playing" /* Playing */) {
      if (packet) {
        this._preparePacket(packet, playable, state);
        state.missedFrames = 0;
      } else {
        this._preparePacket(SILENCE_FRAME, playable, state);
        state.missedFrames++;
        if (state.missedFrames >= this.behaviors.maxMissedFrames) {
          this.stop();
        }
      }
    }
  }
  /**
   * Signals to all the subscribed connections that they should send a packet to Discord indicating
   * they are no longer speaking. Called once playback of a resource ends.
   */
  _signalStopSpeaking() {
    for (const { connection } of this.subscribers) {
      connection.setSpeaking(false);
    }
  }
  /**
   * Instructs the given connections to each prepare this packet to be played at the start of the
   * next cycle.
   *
   * @param packet - The Opus packet to be prepared by each receiver
   * @param receivers - The connections that should play this packet
   */
  _preparePacket(packet, receivers, state) {
    state.playbackDuration += 20;
    for (const connection of receivers) {
      connection.prepareAudioPacket(packet);
    }
  }
};
__name(_AudioPlayer, "AudioPlayer");
var AudioPlayer = _AudioPlayer;
function createAudioPlayer(options) {
  return new AudioPlayer(options);
}
__name(createAudioPlayer, "createAudioPlayer");

// src/audio/AudioResource.ts
var import_node_stream = require("stream");

// src/audio/TransformerGraph.ts
var import_opus = require("@discord-player/opus");
var import_ffmpeg = require("@discord-player/ffmpeg");
var import_equalizer = require("@discord-player/equalizer");
var FFMPEG_PCM_ARGUMENTS = (0, import_ffmpeg.createFFmpegArgs)({
  analyzeduration: "0",
  loglevel: "0",
  f: "s16le",
  ar: "48000",
  ac: "2"
});
var FFMPEG_OPUS_ARGUMENTS = (0, import_ffmpeg.createFFmpegArgs)({
  analyzeduration: "0",
  loglevel: "0",
  acodec: "libopus",
  f: "opus",
  ar: "48000",
  ac: "2"
});
var StreamType = /* @__PURE__ */ ((StreamType2) => {
  StreamType2["Arbitrary"] = "arbitrary";
  StreamType2["OggOpus"] = "ogg/opus";
  StreamType2["Opus"] = "opus";
  StreamType2["Raw"] = "raw";
  StreamType2["WebmOpus"] = "webm/opus";
  return StreamType2;
})(StreamType || {});
var _Node = class _Node {
  constructor(type) {
    /**
     * The outbound edges from this node.
     */
    __publicField(this, "edges", []);
    /**
     * The type of stream for this node.
     */
    __publicField(this, "type");
    this.type = type;
  }
  /**
   * Creates an outbound edge from this node.
   *
   * @param edge - The edge to create
   */
  addEdge(edge) {
    this.edges.push({ ...edge, from: this });
  }
};
__name(_Node, "Node");
var Node = _Node;
var NODES = null;
function canEnableFFmpegOptimizations() {
  return import_ffmpeg.FFmpeg.resolveSafe()?.result.includes("--enable-libopus") === true;
}
__name(canEnableFFmpegOptimizations, "canEnableFFmpegOptimizations");
function getNode(type) {
  const node = (NODES ?? (NODES = initializeNodes())).get(type);
  if (!node) throw new Error(`Node type '${type}' does not exist!`);
  return node;
}
__name(getNode, "getNode");
function initializeNodes() {
  const nodes = /* @__PURE__ */ new Map();
  for (const streamType of Object.values(StreamType)) {
    nodes.set(streamType, new Node(streamType));
  }
  nodes.get("raw" /* Raw */).addEdge({
    type: "opus encoder" /* OpusEncoder */,
    to: nodes.get("opus" /* Opus */),
    cost: 1.5,
    transformer: /* @__PURE__ */ __name(() => new import_opus.OpusEncoder({ rate: 48e3, channels: 2, frameSize: 960 }), "transformer")
  });
  nodes.get("opus" /* Opus */).addEdge({
    type: "opus decoder" /* OpusDecoder */,
    to: nodes.get("raw" /* Raw */),
    cost: 1.5,
    transformer: /* @__PURE__ */ __name(() => new import_opus.OpusDecoder({ rate: 48e3, channels: 2, frameSize: 960 }), "transformer")
  });
  nodes.get("ogg/opus" /* OggOpus */).addEdge({
    type: "ogg/opus demuxer" /* OggOpusDemuxer */,
    to: nodes.get("opus" /* Opus */),
    cost: 1,
    transformer: /* @__PURE__ */ __name(() => new import_opus.OggDemuxer(), "transformer")
  });
  nodes.get("webm/opus" /* WebmOpus */).addEdge({
    type: "webm/opus demuxer" /* WebmOpusDemuxer */,
    to: nodes.get("opus" /* Opus */),
    cost: 1,
    transformer: /* @__PURE__ */ __name(() => new import_opus.WebmDemuxer(), "transformer")
  });
  const FFMPEG_PCM_EDGE = {
    type: "ffmpeg pcm" /* FFmpegPCM */,
    to: nodes.get("raw" /* Raw */),
    cost: 2,
    transformer: /* @__PURE__ */ __name((input) => new import_ffmpeg.FFmpeg({
      args: ["-i", typeof input === "string" ? input : "-", ...FFMPEG_PCM_ARGUMENTS]
    }), "transformer")
  };
  nodes.get("arbitrary" /* Arbitrary */).addEdge(FFMPEG_PCM_EDGE);
  nodes.get("ogg/opus" /* OggOpus */).addEdge(FFMPEG_PCM_EDGE);
  nodes.get("webm/opus" /* WebmOpus */).addEdge(FFMPEG_PCM_EDGE);
  nodes.get("raw" /* Raw */).addEdge({
    type: "volume transformer" /* InlineVolume */,
    to: nodes.get("raw" /* Raw */),
    cost: 0.5,
    transformer: /* @__PURE__ */ __name(() => new import_equalizer.VolumeTransformer({ type: "s16le" }), "transformer")
  });
  if (canEnableFFmpegOptimizations()) {
    const FFMPEG_OGG_EDGE = {
      type: "ffmpeg ogg" /* FFmpegOgg */,
      to: nodes.get("ogg/opus" /* OggOpus */),
      cost: 2,
      transformer: /* @__PURE__ */ __name((input) => new import_ffmpeg.FFmpeg({
        args: ["-i", typeof input === "string" ? input : "-", ...FFMPEG_OPUS_ARGUMENTS]
      }), "transformer")
    };
    nodes.get("arbitrary" /* Arbitrary */).addEdge(FFMPEG_OGG_EDGE);
    nodes.get("ogg/opus" /* OggOpus */).addEdge(FFMPEG_OGG_EDGE);
    nodes.get("webm/opus" /* WebmOpus */).addEdge(FFMPEG_OGG_EDGE);
  }
  return nodes;
}
__name(initializeNodes, "initializeNodes");
function findPath(from, constraints, goal = getNode("opus" /* Opus */), path = [], depth = 5) {
  if (from === goal && constraints(path)) {
    return { cost: 0 };
  } else if (depth === 0) {
    return { cost: Number.POSITIVE_INFINITY };
  }
  let currentBest;
  for (const edge of from.edges) {
    if (currentBest && edge.cost > currentBest.cost) continue;
    const next = findPath(edge.to, constraints, goal, [...path, edge], depth - 1);
    const cost = edge.cost + next.cost;
    if (!currentBest || cost < currentBest.cost) {
      currentBest = { cost, edge, next };
    }
  }
  return currentBest ?? { cost: Number.POSITIVE_INFINITY };
}
__name(findPath, "findPath");
function constructPipeline(step) {
  const edges = [];
  let current = step;
  while (current?.edge) {
    edges.push(current.edge);
    current = current.next;
  }
  return edges;
}
__name(constructPipeline, "constructPipeline");
function findPipeline(from, constraint) {
  return constructPipeline(findPath(getNode(from), constraint));
}
__name(findPipeline, "findPipeline");

// src/audio/AudioResource.ts
var import_opus2 = require("@discord-player/opus");
var import_equalizer2 = require("@discord-player/equalizer");
var _AudioResource = class _AudioResource {
  constructor(edges, streams, metadata, silencePaddingFrames) {
    /**
     * An object-mode Readable stream that emits Opus packets. This is what is played by audio players.
     */
    __publicField(this, "playStream");
    /**
     * The pipeline used to convert the input stream into a playable format. For example, this may
     * contain an FFmpeg component for arbitrary inputs, and it may contain a VolumeTransformer component
     * for resources with inline volume transformation enabled.
     */
    __publicField(this, "edges");
    /**
     * Optional metadata that can be used to identify the resource.
     */
    __publicField(this, "metadata");
    /**
     * If the resource was created with inline volume transformation enabled, then this will be a
     * `@discord-player/equalizer` VolumeTransformer. You can use this to alter the volume of the stream.
     */
    __publicField(this, "volume");
    /**
     * If using an Opus encoder to create this audio resource, then this will be a`@discord-player/opus` opus.Encoder.
     * You can use this to control settings such as bitrate, FEC, PLP.
     */
    __publicField(this, "encoder");
    /**
     * The audio player that the resource is subscribed to, if any.
     */
    __publicField(this, "audioPlayer");
    /**
     * The playback duration of this audio resource, given in milliseconds.
     */
    __publicField(this, "playbackDuration", 0);
    /**
     * Whether or not the stream for this resource has started (data has become readable)
     */
    __publicField(this, "started", false);
    /**
     * The number of silence frames to append to the end of the resource's audio stream, to prevent interpolation glitches.
     */
    __publicField(this, "silencePaddingFrames");
    /**
     * The number of remaining silence frames to play. If -1, the frames have not yet started playing.
     */
    __publicField(this, "silenceRemaining", -1);
    this.edges = edges;
    this.playStream = streams.length > 1 ? (0, import_node_stream.pipeline)(streams, noop) : streams[0];
    this.metadata = metadata;
    this.silencePaddingFrames = silencePaddingFrames;
    for (const stream of streams) {
      if (stream instanceof import_equalizer2.VolumeTransformer) {
        this.volume = stream;
      } else if (stream instanceof import_opus2.OpusEncoder) {
        this.encoder = stream;
      }
    }
    this.playStream.once("readable", () => this.started = true);
  }
  /**
   * Whether this resource is readable. If the underlying resource is no longer readable, this will still return true
   * while there are silence padding frames left to play.
   */
  get readable() {
    if (this.silenceRemaining === 0) return false;
    const real = this.playStream.readable;
    if (!real) {
      if (this.silenceRemaining === -1) this.silenceRemaining = this.silencePaddingFrames;
      return this.silenceRemaining !== 0;
    }
    return real;
  }
  /**
   * Whether this resource has ended or not.
   */
  get ended() {
    return this.playStream.readableEnded || this.playStream.destroyed || this.silenceRemaining === 0;
  }
  /**
   * Attempts to read an Opus packet from the audio resource. If a packet is available, the playbackDuration
   * is incremented.
   *
   * @remarks
   * It is advisable to check that the playStream is readable before calling this method. While no runtime
   * errors will be thrown, you should check that the resource is still available before attempting to
   * read from it.
   * @internal
   */
  read() {
    if (this.silenceRemaining === 0) {
      return null;
    } else if (this.silenceRemaining > 0) {
      this.silenceRemaining--;
      return SILENCE_FRAME;
    }
    const packet = this.playStream.read();
    if (packet) {
      this.playbackDuration += 20;
    }
    return packet;
  }
};
__name(_AudioResource, "AudioResource");
var AudioResource = _AudioResource;
var VOLUME_CONSTRAINT = /* @__PURE__ */ __name((path) => path.some((edge) => edge.type === "volume transformer" /* InlineVolume */), "VOLUME_CONSTRAINT");
var NO_CONSTRAINT = /* @__PURE__ */ __name(() => true, "NO_CONSTRAINT");
function inferStreamType(stream) {
  if (stream instanceof import_opus2.OpusEncoder) {
    return { streamType: "opus" /* Opus */, hasVolume: false };
  } else if (stream instanceof import_opus2.OpusDecoder) {
    return { streamType: "raw" /* Raw */, hasVolume: false };
  } else if (stream instanceof import_equalizer2.VolumeTransformer) {
    return { streamType: "raw" /* Raw */, hasVolume: true };
  } else if (stream instanceof import_opus2.OggDemuxer) {
    return { streamType: "opus" /* Opus */, hasVolume: false };
  } else if (stream instanceof import_opus2.WebmDemuxer) {
    return { streamType: "opus" /* Opus */, hasVolume: false };
  }
  return { streamType: "arbitrary" /* Arbitrary */, hasVolume: false };
}
__name(inferStreamType, "inferStreamType");
function createAudioResource(input, options = {}) {
  let inputType = options.inputType;
  let needsInlineVolume = Boolean(options.inlineVolume);
  if (typeof input === "string") {
    inputType = "arbitrary" /* Arbitrary */;
  } else if (inputType === void 0) {
    const analysis = inferStreamType(input);
    inputType = analysis.streamType;
    needsInlineVolume = needsInlineVolume && !analysis.hasVolume;
  }
  const transformerPipeline = findPipeline(inputType, needsInlineVolume ? VOLUME_CONSTRAINT : NO_CONSTRAINT);
  if (transformerPipeline.length === 0) {
    if (typeof input === "string") throw new Error(`Invalid pipeline constructed for string resource '${input}'`);
    return new AudioResource(
      [],
      [input],
      options.metadata ?? null,
      options.silencePaddingFrames ?? 5
    );
  }
  const streams = transformerPipeline.map((edge) => edge.transformer(input));
  if (typeof input !== "string") streams.unshift(input);
  return new AudioResource(
    transformerPipeline,
    streams,
    options.metadata ?? null,
    options.silencePaddingFrames ?? 5
  );
}
__name(createAudioResource, "createAudioResource");

// src/util/entersState.ts
var import_node_events6 = require("events");

// src/util/abortAfter.ts
function abortAfter(delay) {
  const ac = new AbortController();
  const timeout = setTimeout(() => ac.abort(), delay);
  ac.signal.addEventListener("abort", () => clearTimeout(timeout));
  return [ac, ac.signal];
}
__name(abortAfter, "abortAfter");

// src/util/entersState.ts
async function entersState(target, status, timeoutOrSignal) {
  if (target.state.status !== status) {
    const [ac, signal] = typeof timeoutOrSignal === "number" ? abortAfter(timeoutOrSignal) : [void 0, timeoutOrSignal];
    try {
      await (0, import_node_events6.once)(target, status, { signal });
    } finally {
      ac?.abort();
    }
  }
  return target;
}
__name(entersState, "entersState");

// src/version.ts
var version = (
  /* @__MACRO__ getVersion */
  "7.0.0"
);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AudioPlayer,
  AudioPlayerError,
  AudioPlayerStatus,
  AudioResource,
  NoSubscriberBehavior,
  PlayerSubscription,
  StreamType,
  VoiceConnection,
  VoiceConnectionDisconnectReason,
  VoiceConnectionStatus,
  createAudioPlayer,
  createAudioResource,
  entersState,
  getGroups,
  getVoiceConnection,
  getVoiceConnections,
  joinVoiceChannel,
  version
});
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vc3JjL2luZGV4LnRzIiwgIi4uL3NyYy9Wb2ljZUNvbm5lY3Rpb24udHMiLCAiLi4vc3JjL0RhdGFTdG9yZS50cyIsICIuLi9zcmMvbmV0d29ya2luZy9OZXR3b3JraW5nLnRzIiwgIi4uL3NyYy91dGlsL1NlY3JldGJveC50cyIsICIuLi9zcmMvdXRpbC91dGlsLnRzIiwgIi4uL3NyYy9uZXR3b3JraW5nL1ZvaWNlVURQU29ja2V0LnRzIiwgIi4uL3NyYy9uZXR3b3JraW5nL1ZvaWNlV2ViU29ja2V0LnRzIiwgIi4uL3NyYy9qb2luVm9pY2VDaGFubmVsLnRzIiwgIi4uL3NyYy9hdWRpby9BdWRpb1BsYXllci50cyIsICIuLi9zcmMvYXVkaW8vQXVkaW9QbGF5ZXJFcnJvci50cyIsICIuLi9zcmMvYXVkaW8vUGxheWVyU3Vic2NyaXB0aW9uLnRzIiwgIi4uL3NyYy9hdWRpby9BdWRpb1Jlc291cmNlLnRzIiwgIi4uL3NyYy9hdWRpby9UcmFuc2Zvcm1lckdyYXBoLnRzIiwgIi4uL3NyYy91dGlsL2VudGVyc1N0YXRlLnRzIiwgIi4uL3NyYy91dGlsL2Fib3J0QWZ0ZXIudHMiLCAiLi4vc3JjL3ZlcnNpb24udHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbIi8vIENvcHlyaWdodCBkaXNjb3JkLXBsYXllciBhdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLiBNSVQgTGljZW5zZS5cbi8vIENvcHlyaWdodCBkaXNjb3JkLmpzIGF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuIEFwYWNoZSBMaWNlbnNlIDIuMFxuXG5leHBvcnQgKiBmcm9tICcuL2pvaW5Wb2ljZUNoYW5uZWwnO1xuZXhwb3J0ICogZnJvbSAnLi9hdWRpby9pbmRleCc7XG5leHBvcnQgKiBmcm9tICcuL3V0aWwvaW5kZXgnO1xuXG5leHBvcnQge1xuICBWb2ljZUNvbm5lY3Rpb24sXG4gIHR5cGUgVm9pY2VDb25uZWN0aW9uU3RhdGUsXG4gIFZvaWNlQ29ubmVjdGlvblN0YXR1cyxcbiAgdHlwZSBWb2ljZUNvbm5lY3Rpb25Db25uZWN0aW5nU3RhdGUsXG4gIHR5cGUgVm9pY2VDb25uZWN0aW9uRGVzdHJveWVkU3RhdGUsXG4gIHR5cGUgVm9pY2VDb25uZWN0aW9uRGlzY29ubmVjdGVkU3RhdGUsXG4gIHR5cGUgVm9pY2VDb25uZWN0aW9uRGlzY29ubmVjdGVkQmFzZVN0YXRlLFxuICB0eXBlIFZvaWNlQ29ubmVjdGlvbkRpc2Nvbm5lY3RlZE90aGVyU3RhdGUsXG4gIHR5cGUgVm9pY2VDb25uZWN0aW9uRGlzY29ubmVjdGVkV2ViU29ja2V0U3RhdGUsXG4gIFZvaWNlQ29ubmVjdGlvbkRpc2Nvbm5lY3RSZWFzb24sXG4gIHR5cGUgVm9pY2VDb25uZWN0aW9uUmVhZHlTdGF0ZSxcbiAgdHlwZSBWb2ljZUNvbm5lY3Rpb25TaWduYWxsaW5nU3RhdGUgfSBmcm9tXG4nLi9Wb2ljZUNvbm5lY3Rpb24nO1xuXG5leHBvcnQgeyB0eXBlIEpvaW5Db25maWcsIGdldFZvaWNlQ29ubmVjdGlvbiwgZ2V0Vm9pY2VDb25uZWN0aW9ucywgZ2V0R3JvdXBzIH0gZnJvbSAnLi9EYXRhU3RvcmUnO1xuXG5leHBvcnQgeyB2ZXJzaW9uIH0gZnJvbSAnLi92ZXJzaW9uJzsiLCAiLy8gQ29weXJpZ2h0IGRpc2NvcmQtcGxheWVyIGF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuIE1JVCBMaWNlbnNlLlxuLy8gQ29weXJpZ2h0IGRpc2NvcmQuanMgYXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC4gQXBhY2hlIExpY2Vuc2UgMi4wXG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC91bmJvdW5kLW1ldGhvZCwgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1kZWNsYXJhdGlvbi1tZXJnaW5nICovXG5cbmltcG9ydCB0eXBlIHsgQnVmZmVyIH0gZnJvbSAnbm9kZTpidWZmZXInO1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnbm9kZTpldmVudHMnO1xuaW1wb3J0IHR5cGUgeyBHYXRld2F5Vm9pY2VTZXJ2ZXJVcGRhdGVEaXNwYXRjaERhdGEsIEdhdGV3YXlWb2ljZVN0YXRlVXBkYXRlRGlzcGF0Y2hEYXRhIH0gZnJvbSAnZGlzY29yZC1hcGktdHlwZXMvdjEwJztcbmltcG9ydCB0eXBlIHsgSm9pbkNvbmZpZyB9IGZyb20gJy4vRGF0YVN0b3JlJztcbmltcG9ydCB7XG4gIGdldFZvaWNlQ29ubmVjdGlvbixcbiAgY3JlYXRlSm9pblZvaWNlQ2hhbm5lbFBheWxvYWQsXG4gIHRyYWNrVm9pY2VDb25uZWN0aW9uLFxuICB1bnRyYWNrVm9pY2VDb25uZWN0aW9uIH0gZnJvbVxuJy4vRGF0YVN0b3JlJztcbmltcG9ydCB0eXBlIHsgQXVkaW9QbGF5ZXIgfSBmcm9tICcuL2F1ZGlvL0F1ZGlvUGxheWVyJztcbmltcG9ydCB0eXBlIHsgUGxheWVyU3Vic2NyaXB0aW9uIH0gZnJvbSAnLi9hdWRpby9QbGF5ZXJTdWJzY3JpcHRpb24nO1xuaW1wb3J0IHsgTmV0d29ya2luZywgTmV0d29ya2luZ1N0YXR1c0NvZGUsIHR5cGUgTmV0d29ya2luZ1N0YXRlIH0gZnJvbSAnLi9uZXR3b3JraW5nL05ldHdvcmtpbmcnO1xuaW1wb3J0IHR5cGUgeyBEaXNjb3JkR2F0ZXdheUFkYXB0ZXJJbXBsZW1lbnRlck1ldGhvZHMgfSBmcm9tICcuL3V0aWwvYWRhcHRlcic7XG5pbXBvcnQgeyBub29wIH0gZnJvbSAnLi91dGlsL3V0aWwnO1xuaW1wb3J0IHR5cGUgeyBDcmVhdGVWb2ljZUNvbm5lY3Rpb25PcHRpb25zIH0gZnJvbSAnLi9pbmRleCc7XG5pbXBvcnQgeyB1bnNhZmUgfSBmcm9tICcuL2NvbW1vbi90eXBlcyc7XG5cbi8qKlxuICogVGhlIHZhcmlvdXMgc3RhdHVzIGNvZGVzIGEgdm9pY2UgY29ubmVjdGlvbiBjYW4gaG9sZCBhdCBhbnkgb25lIHRpbWUuXG4gKi9cbmV4cG9ydCBlbnVtIFZvaWNlQ29ubmVjdGlvblN0YXR1cyB7XG4gIC8qKlxuICAgKiBUaGUgYFZPSUNFX1NFUlZFUl9VUERBVEVgIGFuZCBgVk9JQ0VfU1RBVEVfVVBEQVRFYCBwYWNrZXRzIGhhdmUgYmVlbiByZWNlaXZlZCwgbm93IGF0dGVtcHRpbmcgdG8gZXN0YWJsaXNoIGEgdm9pY2UgY29ubmVjdGlvbi5cbiAgICovXG4gIENvbm5lY3RpbmcgPSAnY29ubmVjdGluZycsXG5cbiAgLyoqXG4gICAqIFRoZSB2b2ljZSBjb25uZWN0aW9uIGhhcyBiZWVuIGRlc3Ryb3llZCBhbmQgdW50cmFja2VkLCBpdCBjYW5ub3QgYmUgcmV1c2VkLlxuICAgKi9cbiAgRGVzdHJveWVkID0gJ2Rlc3Ryb3llZCcsXG5cbiAgLyoqXG4gICAqIFRoZSB2b2ljZSBjb25uZWN0aW9uIGhhcyBlaXRoZXIgYmVlbiBzZXZlcmVkIG9yIG5vdCBlc3RhYmxpc2hlZC5cbiAgICovXG4gIERpc2Nvbm5lY3RlZCA9ICdkaXNjb25uZWN0ZWQnLFxuXG4gIC8qKlxuICAgKiBBIHZvaWNlIGNvbm5lY3Rpb24gaGFzIGJlZW4gZXN0YWJsaXNoZWQsIGFuZCBpcyByZWFkeSB0byBiZSB1c2VkLlxuICAgKi9cbiAgUmVhZHkgPSAncmVhZHknLFxuXG4gIC8qKlxuICAgKiBTZW5kaW5nIGEgcGFja2V0IHRvIHRoZSBtYWluIERpc2NvcmQgZ2F0ZXdheSB0byBpbmRpY2F0ZSB3ZSB3YW50IHRvIGNoYW5nZSBvdXIgdm9pY2Ugc3RhdGUuXG4gICAqL1xuICBTaWduYWxsaW5nID0gJ3NpZ25hbGxpbmcnLFxufVxuXG4vKipcbiAqIFRoZSBzdGF0ZSB0aGF0IGEgVm9pY2VDb25uZWN0aW9uIHdpbGwgYmUgaW4gd2hlbiBpdCBpcyB3YWl0aW5nIHRvIHJlY2VpdmUgYSBWT0lDRV9TRVJWRVJfVVBEQVRFIGFuZFxuICogVk9JQ0VfU1RBVEVfVVBEQVRFIHBhY2tldCBmcm9tIERpc2NvcmQsIHByb3ZpZGVkIGJ5IHRoZSBhZGFwdGVyLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFZvaWNlQ29ubmVjdGlvblNpZ25hbGxpbmdTdGF0ZSB7XG4gIGFkYXB0ZXI6IERpc2NvcmRHYXRld2F5QWRhcHRlckltcGxlbWVudGVyTWV0aG9kcztcbiAgc3RhdHVzOiBWb2ljZUNvbm5lY3Rpb25TdGF0dXMuU2lnbmFsbGluZztcbiAgc3Vic2NyaXB0aW9uPzogUGxheWVyU3Vic2NyaXB0aW9uIHwgdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIFRoZSByZWFzb25zIGEgdm9pY2UgY29ubmVjdGlvbiBjYW4gYmUgaW4gdGhlIGRpc2Nvbm5lY3RlZCBzdGF0ZS5cbiAqL1xuZXhwb3J0IGVudW0gVm9pY2VDb25uZWN0aW9uRGlzY29ubmVjdFJlYXNvbiB7XG4gIC8qKlxuICAgKiBXaGVuIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiBoYXMgYmVlbiBjbG9zZWQuXG4gICAqL1xuICBXZWJTb2NrZXRDbG9zZSxcblxuICAvKipcbiAgICogV2hlbiB0aGUgYWRhcHRlciB3YXMgdW5hYmxlIHRvIHNlbmQgYSBtZXNzYWdlIHJlcXVlc3RlZCBieSB0aGUgVm9pY2VDb25uZWN0aW9uLlxuICAgKi9cbiAgQWRhcHRlclVuYXZhaWxhYmxlLFxuXG4gIC8qKlxuICAgKiBXaGVuIGEgVk9JQ0VfU0VSVkVSX1VQREFURSBwYWNrZXQgaXMgcmVjZWl2ZWQgd2l0aCBhIG51bGwgZW5kcG9pbnQsIGNhdXNpbmcgdGhlIGNvbm5lY3Rpb24gdG8gYmUgc2V2ZXJlZC5cbiAgICovXG4gIEVuZHBvaW50UmVtb3ZlZCxcblxuICAvKipcbiAgICogV2hlbiBhIG1hbnVhbCBkaXNjb25uZWN0IHdhcyByZXF1ZXN0ZWQuXG4gICAqL1xuICBNYW51YWwsXG59XG5cbi8qKlxuICogVGhlIHN0YXRlIHRoYXQgYSBWb2ljZUNvbm5lY3Rpb24gd2lsbCBiZSBpbiB3aGVuIGl0IGlzIG5vdCBjb25uZWN0ZWQgdG8gYSBEaXNjb3JkIHZvaWNlIHNlcnZlciBub3IgaXNcbiAqIGl0IGF0dGVtcHRpbmcgdG8gY29ubmVjdC4gWW91IGNhbiBtYW51YWxseSBhdHRlbXB0IHRvIHJlY29ubmVjdCB1c2luZyBWb2ljZUNvbm5lY3Rpb24jcmVjb25uZWN0LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFZvaWNlQ29ubmVjdGlvbkRpc2Nvbm5lY3RlZEJhc2VTdGF0ZSB7XG4gIGFkYXB0ZXI6IERpc2NvcmRHYXRld2F5QWRhcHRlckltcGxlbWVudGVyTWV0aG9kcztcbiAgc3RhdHVzOiBWb2ljZUNvbm5lY3Rpb25TdGF0dXMuRGlzY29ubmVjdGVkO1xuICBzdWJzY3JpcHRpb24/OiBQbGF5ZXJTdWJzY3JpcHRpb24gfCB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogVGhlIHN0YXRlIHRoYXQgYSBWb2ljZUNvbm5lY3Rpb24gd2lsbCBiZSBpbiB3aGVuIGl0IGlzIG5vdCBjb25uZWN0ZWQgdG8gYSBEaXNjb3JkIHZvaWNlIHNlcnZlciBub3IgaXNcbiAqIGl0IGF0dGVtcHRpbmcgdG8gY29ubmVjdC4gWW91IGNhbiBtYW51YWxseSBhdHRlbXB0IHRvIHJlY29ubmVjdCB1c2luZyBWb2ljZUNvbm5lY3Rpb24jcmVjb25uZWN0LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFZvaWNlQ29ubmVjdGlvbkRpc2Nvbm5lY3RlZE90aGVyU3RhdGUgZXh0ZW5kcyBWb2ljZUNvbm5lY3Rpb25EaXNjb25uZWN0ZWRCYXNlU3RhdGUge1xuICByZWFzb246IEV4Y2x1ZGU8Vm9pY2VDb25uZWN0aW9uRGlzY29ubmVjdFJlYXNvbiwgVm9pY2VDb25uZWN0aW9uRGlzY29ubmVjdFJlYXNvbi5XZWJTb2NrZXRDbG9zZT47XG59XG5cbi8qKlxuICogVGhlIHN0YXRlIHRoYXQgYSBWb2ljZUNvbm5lY3Rpb24gd2lsbCBiZSBpbiB3aGVuIGl0cyBXZWJTb2NrZXQgY29ubmVjdGlvbiB3YXMgY2xvc2VkLlxuICogWW91IGNhbiBtYW51YWxseSBhdHRlbXB0IHRvIHJlY29ubmVjdCB1c2luZyBWb2ljZUNvbm5lY3Rpb24jcmVjb25uZWN0LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFZvaWNlQ29ubmVjdGlvbkRpc2Nvbm5lY3RlZFdlYlNvY2tldFN0YXRlIGV4dGVuZHMgVm9pY2VDb25uZWN0aW9uRGlzY29ubmVjdGVkQmFzZVN0YXRlIHtcbiAgLyoqXG4gICAqIFRoZSBjbG9zZSBjb2RlIG9mIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbiB0byB0aGUgRGlzY29yZCB2b2ljZSBzZXJ2ZXIuXG4gICAqL1xuICBjbG9zZUNvZGU6IG51bWJlcjtcblxuICByZWFzb246IFZvaWNlQ29ubmVjdGlvbkRpc2Nvbm5lY3RSZWFzb24uV2ViU29ja2V0Q2xvc2U7XG59XG5cbi8qKlxuICogVGhlIHN0YXRlcyB0aGF0IGEgVm9pY2VDb25uZWN0aW9uIGNhbiBiZSBpbiB3aGVuIGl0IGlzIG5vdCBjb25uZWN0ZWQgdG8gYSBEaXNjb3JkIHZvaWNlIHNlcnZlciBub3IgaXNcbiAqIGl0IGF0dGVtcHRpbmcgdG8gY29ubmVjdC4gWW91IGNhbiBtYW51YWxseSBhdHRlbXB0IHRvIGNvbm5lY3QgdXNpbmcgVm9pY2VDb25uZWN0aW9uI3JlY29ubmVjdC5cbiAqL1xuZXhwb3J0IHR5cGUgVm9pY2VDb25uZWN0aW9uRGlzY29ubmVjdGVkU3RhdGUgPVxuVm9pY2VDb25uZWN0aW9uRGlzY29ubmVjdGVkT3RoZXJTdGF0ZSB8XG5Wb2ljZUNvbm5lY3Rpb25EaXNjb25uZWN0ZWRXZWJTb2NrZXRTdGF0ZTtcblxuLyoqXG4gKiBUaGUgc3RhdGUgdGhhdCBhIFZvaWNlQ29ubmVjdGlvbiB3aWxsIGJlIGluIHdoZW4gaXQgaXMgZXN0YWJsaXNoaW5nIGEgY29ubmVjdGlvbiB0byBhIERpc2NvcmRcbiAqIHZvaWNlIHNlcnZlci5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBWb2ljZUNvbm5lY3Rpb25Db25uZWN0aW5nU3RhdGUge1xuICBhZGFwdGVyOiBEaXNjb3JkR2F0ZXdheUFkYXB0ZXJJbXBsZW1lbnRlck1ldGhvZHM7XG4gIG5ldHdvcmtpbmc6IE5ldHdvcmtpbmc7XG4gIHN0YXR1czogVm9pY2VDb25uZWN0aW9uU3RhdHVzLkNvbm5lY3Rpbmc7XG4gIHN1YnNjcmlwdGlvbj86IFBsYXllclN1YnNjcmlwdGlvbiB8IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBUaGUgc3RhdGUgdGhhdCBhIFZvaWNlQ29ubmVjdGlvbiB3aWxsIGJlIGluIHdoZW4gaXQgaGFzIGFuIGFjdGl2ZSBjb25uZWN0aW9uIHRvIGEgRGlzY29yZFxuICogdm9pY2Ugc2VydmVyLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFZvaWNlQ29ubmVjdGlvblJlYWR5U3RhdGUge1xuICBhZGFwdGVyOiBEaXNjb3JkR2F0ZXdheUFkYXB0ZXJJbXBsZW1lbnRlck1ldGhvZHM7XG4gIG5ldHdvcmtpbmc6IE5ldHdvcmtpbmc7XG4gIHN0YXR1czogVm9pY2VDb25uZWN0aW9uU3RhdHVzLlJlYWR5O1xuICBzdWJzY3JpcHRpb24/OiBQbGF5ZXJTdWJzY3JpcHRpb24gfCB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogVGhlIHN0YXRlIHRoYXQgYSBWb2ljZUNvbm5lY3Rpb24gd2lsbCBiZSBpbiB3aGVuIGl0IGhhcyBiZWVuIHBlcm1hbmVudGx5IGJlZW4gZGVzdHJveWVkIGJ5IHRoZVxuICogdXNlciBhbmQgdW50cmFja2VkIGJ5IHRoZSBsaWJyYXJ5LiBJdCBjYW5ub3QgYmUgcmVjb25uZWN0ZWQsIGluc3RlYWQsIGEgbmV3IFZvaWNlQ29ubmVjdGlvblxuICogbmVlZHMgdG8gYmUgZXN0YWJsaXNoZWQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVm9pY2VDb25uZWN0aW9uRGVzdHJveWVkU3RhdGUge1xuICBzdGF0dXM6IFZvaWNlQ29ubmVjdGlvblN0YXR1cy5EZXN0cm95ZWQ7XG59XG5cbi8qKlxuICogVGhlIHZhcmlvdXMgc3RhdGVzIHRoYXQgYSB2b2ljZSBjb25uZWN0aW9uIGNhbiBiZSBpbi5cbiAqL1xuZXhwb3J0IHR5cGUgVm9pY2VDb25uZWN0aW9uU3RhdGUgPVxuVm9pY2VDb25uZWN0aW9uQ29ubmVjdGluZ1N0YXRlIHxcblZvaWNlQ29ubmVjdGlvbkRlc3Ryb3llZFN0YXRlIHxcblZvaWNlQ29ubmVjdGlvbkRpc2Nvbm5lY3RlZFN0YXRlIHxcblZvaWNlQ29ubmVjdGlvblJlYWR5U3RhdGUgfFxuVm9pY2VDb25uZWN0aW9uU2lnbmFsbGluZ1N0YXRlO1xuXG5leHBvcnQgaW50ZXJmYWNlIFZvaWNlQ29ubmVjdGlvbiBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIC8qKlxuICAgKiBFbWl0dGVkIHdoZW4gdGhlcmUgaXMgYW4gZXJyb3IgZW1pdHRlZCBmcm9tIHRoZSB2b2ljZSBjb25uZWN0aW9uXG4gICAqXG4gICAqIEBldmVudFByb3BlcnR5XG4gICAqL1xuICBvbihldmVudDogJ2Vycm9yJywgbGlzdGVuZXI6IChlcnJvcjogRXJyb3IpID0+IHZvaWQpOiB0aGlzO1xuICAvKipcbiAgICogRW1pdHRlZCBkZWJ1Z2dpbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHZvaWNlIGNvbm5lY3Rpb25cbiAgICpcbiAgICogQGV2ZW50UHJvcGVydHlcbiAgICovXG4gIG9uKGV2ZW50OiAnZGVidWcnLCBsaXN0ZW5lcjogKG1lc3NhZ2U6IHN0cmluZykgPT4gdm9pZCk6IHRoaXM7XG4gIC8qKlxuICAgKiBFbWl0dGVkIHdoZW4gdGhlIHN0YXRlIG9mIHRoZSB2b2ljZSBjb25uZWN0aW9uIGNoYW5nZXNcbiAgICpcbiAgICogQGV2ZW50UHJvcGVydHlcbiAgICovXG4gIG9uKGV2ZW50OiAnc3RhdGVDaGFuZ2UnLCBsaXN0ZW5lcjogKG9sZFN0YXRlOiBWb2ljZUNvbm5lY3Rpb25TdGF0ZSwgbmV3U3RhdGU6IFZvaWNlQ29ubmVjdGlvblN0YXRlKSA9PiB2b2lkKTogdGhpcztcbiAgLyoqXG4gICAqIEVtaXR0ZWQgd2hlbiB0aGUgc3RhdGUgb2YgdGhlIHZvaWNlIGNvbm5lY3Rpb24gY2hhbmdlcyB0byBhIHNwZWNpZmljIHN0YXR1c1xuICAgKlxuICAgKiBAZXZlbnRQcm9wZXJ0eVxuICAgKi9cbiAgb248RXZlbnQgZXh0ZW5kcyBWb2ljZUNvbm5lY3Rpb25TdGF0dXM+KFxuICBldmVudDogRXZlbnQsXG4gIGxpc3RlbmVyOiAob2xkU3RhdGU6IFZvaWNlQ29ubmVjdGlvblN0YXRlLCBuZXdTdGF0ZTogVm9pY2VDb25uZWN0aW9uU3RhdGUgJiB7c3RhdHVzOiBFdmVudDt9KSA9PiB2b2lkKVxuICA6IHRoaXM7XG59XG5cbi8qKlxuICogQSBjb25uZWN0aW9uIHRvIHRoZSB2b2ljZSBzZXJ2ZXIgb2YgYSBHdWlsZCwgY2FuIGJlIHVzZWQgdG8gcGxheSBhdWRpbyBpbiB2b2ljZSBjaGFubmVscy5cbiAqL1xuZXhwb3J0IGNsYXNzIFZvaWNlQ29ubmVjdGlvbiBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIC8qKlxuICAgKiBUaGUgbnVtYmVyIG9mIGNvbnNlY3V0aXZlIHJlam9pbiBhdHRlbXB0cy4gSW5pdGlhbGx5IDAsIGFuZCBpbmNyZW1lbnRzIGZvciBlYWNoIHJlam9pbi5cbiAgICogV2hlbiBhIGNvbm5lY3Rpb24gaXMgc3VjY2Vzc2Z1bGx5IGVzdGFibGlzaGVkLCBpdCByZXNldHMgdG8gMC5cbiAgICovXG4gIHB1YmxpYyByZWpvaW5BdHRlbXB0czogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgc3RhdGUgb2YgdGhlIHZvaWNlIGNvbm5lY3Rpb24uXG4gICAqL1xuICBwcml2YXRlIF9zdGF0ZTogVm9pY2VDb25uZWN0aW9uU3RhdGU7XG5cbiAgLyoqXG4gICAqIEEgY29uZmlndXJhdGlvbiBzdG9yaW5nIGFsbCB0aGUgZGF0YSBuZWVkZWQgdG8gcmVjb25uZWN0IHRvIGEgR3VpbGQncyB2b2ljZSBzZXJ2ZXIuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IGpvaW5Db25maWc6IEpvaW5Db25maWc7XG5cbiAgLyoqXG4gICAqIFRoZSB0d28gcGFja2V0cyBuZWVkZWQgdG8gc3VjY2Vzc2Z1bGx5IGVzdGFibGlzaCBhIHZvaWNlIGNvbm5lY3Rpb24uIFRoZXkgYXJlIHJlY2VpdmVkXG4gICAqIGZyb20gdGhlIG1haW4gRGlzY29yZCBnYXRld2F5IGFmdGVyIHNpZ25hbGxpbmcgdG8gY2hhbmdlIHRoZSB2b2ljZSBzdGF0ZS5cbiAgICovXG4gIHByaXZhdGUgcmVhZG9ubHkgcGFja2V0czoge1xuICAgIHNlcnZlcjogR2F0ZXdheVZvaWNlU2VydmVyVXBkYXRlRGlzcGF0Y2hEYXRhIHwgdW5kZWZpbmVkO1xuICAgIHN0YXRlOiBHYXRld2F5Vm9pY2VTdGF0ZVVwZGF0ZURpc3BhdGNoRGF0YSB8IHVuZGVmaW5lZDtcbiAgfTtcblxuICAvKipcbiAgICogVGhlIGRlYnVnIGxvZ2dlciBmdW5jdGlvbiwgaWYgZGVidWdnaW5nIGlzIGVuYWJsZWQuXG4gICAqL1xuICBwcml2YXRlIHJlYWRvbmx5IGRlYnVnOiAoKG1lc3NhZ2U6IHN0cmluZykgPT4gdm9pZCkgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHZvaWNlIGNvbm5lY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSBqb2luQ29uZmlnIC0gVGhlIGRhdGEgcmVxdWlyZWQgdG8gZXN0YWJsaXNoIHRoZSB2b2ljZSBjb25uZWN0aW9uXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgdXNlZCB0byBjcmVhdGUgdGhpcyB2b2ljZSBjb25uZWN0aW9uXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3Ioam9pbkNvbmZpZzogSm9pbkNvbmZpZywgb3B0aW9uczogQ3JlYXRlVm9pY2VDb25uZWN0aW9uT3B0aW9ucykge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLmRlYnVnID0gb3B0aW9ucy5kZWJ1ZyA/IChtZXNzYWdlOiBzdHJpbmcpID0+IHRoaXMuZW1pdCgnZGVidWcnLCBtZXNzYWdlKSA6IG51bGw7XG4gICAgdGhpcy5yZWpvaW5BdHRlbXB0cyA9IDA7XG5cbiAgICB0aGlzLm9uTmV0d29ya2luZ0Nsb3NlID0gdGhpcy5vbk5ldHdvcmtpbmdDbG9zZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMub25OZXR3b3JraW5nU3RhdGVDaGFuZ2UgPSB0aGlzLm9uTmV0d29ya2luZ1N0YXRlQ2hhbmdlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vbk5ldHdvcmtpbmdFcnJvciA9IHRoaXMub25OZXR3b3JraW5nRXJyb3IuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9uTmV0d29ya2luZ0RlYnVnID0gdGhpcy5vbk5ldHdvcmtpbmdEZWJ1Zy5iaW5kKHRoaXMpO1xuXG4gICAgY29uc3QgYWRhcHRlciA9IG9wdGlvbnMuYWRhcHRlckNyZWF0b3Ioe1xuICAgICAgb25Wb2ljZVNlcnZlclVwZGF0ZTogKGRhdGEpID0+IHRoaXMuYWRkU2VydmVyUGFja2V0KGRhdGEpLFxuICAgICAgb25Wb2ljZVN0YXRlVXBkYXRlOiAoZGF0YSkgPT4gdGhpcy5hZGRTdGF0ZVBhY2tldChkYXRhKSxcbiAgICAgIGRlc3Ryb3k6ICgpID0+IHRoaXMuZGVzdHJveShmYWxzZSlcbiAgICB9KTtcblxuICAgIHRoaXMuX3N0YXRlID0geyBzdGF0dXM6IFZvaWNlQ29ubmVjdGlvblN0YXR1cy5TaWduYWxsaW5nLCBhZGFwdGVyIH07XG5cbiAgICB0aGlzLnBhY2tldHMgPSB7XG4gICAgICBzZXJ2ZXI6IHVuZGVmaW5lZCxcbiAgICAgIHN0YXRlOiB1bmRlZmluZWRcbiAgICB9O1xuXG4gICAgdGhpcy5qb2luQ29uZmlnID0gam9pbkNvbmZpZztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgdm9pY2UgY29ubmVjdGlvbi5cbiAgICovXG4gIHB1YmxpYyBnZXQgc3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHN0YXRlIG9mIHRoZSB2b2ljZSBjb25uZWN0aW9uLCBwZXJmb3JtaW5nIGNsZWFuLXVwIG9wZXJhdGlvbnMgd2hlcmUgbmVjZXNzYXJ5LlxuICAgKi9cbiAgcHVibGljIHNldCBzdGF0ZShuZXdTdGF0ZTogVm9pY2VDb25uZWN0aW9uU3RhdGUpIHtcbiAgICBjb25zdCBvbGRTdGF0ZSA9IHRoaXMuX3N0YXRlO1xuICAgIGNvbnN0IG9sZE5ldHdvcmtpbmcgPSBSZWZsZWN0LmdldChvbGRTdGF0ZSwgJ25ldHdvcmtpbmcnKSBhcyBOZXR3b3JraW5nIHwgdW5kZWZpbmVkO1xuICAgIGNvbnN0IG5ld05ldHdvcmtpbmcgPSBSZWZsZWN0LmdldChuZXdTdGF0ZSwgJ25ldHdvcmtpbmcnKSBhcyBOZXR3b3JraW5nIHwgdW5kZWZpbmVkO1xuXG4gICAgY29uc3Qgb2xkU3Vic2NyaXB0aW9uID0gUmVmbGVjdC5nZXQob2xkU3RhdGUsICdzdWJzY3JpcHRpb24nKSBhcyBQbGF5ZXJTdWJzY3JpcHRpb24gfCB1bmRlZmluZWQ7XG4gICAgY29uc3QgbmV3U3Vic2NyaXB0aW9uID0gUmVmbGVjdC5nZXQobmV3U3RhdGUsICdzdWJzY3JpcHRpb24nKSBhcyBQbGF5ZXJTdWJzY3JpcHRpb24gfCB1bmRlZmluZWQ7XG5cbiAgICBpZiAob2xkTmV0d29ya2luZyAhPT0gbmV3TmV0d29ya2luZykge1xuICAgICAgaWYgKG9sZE5ldHdvcmtpbmcpIHtcbiAgICAgICAgb2xkTmV0d29ya2luZy5vbignZXJyb3InLCBub29wKTtcbiAgICAgICAgb2xkTmV0d29ya2luZy5vZmYoJ2RlYnVnJywgdGhpcy5vbk5ldHdvcmtpbmdEZWJ1Zyk7XG4gICAgICAgIG9sZE5ldHdvcmtpbmcub2ZmKCdlcnJvcicsIHRoaXMub25OZXR3b3JraW5nRXJyb3IpO1xuICAgICAgICBvbGROZXR3b3JraW5nLm9mZignY2xvc2UnLCB0aGlzLm9uTmV0d29ya2luZ0Nsb3NlKTtcbiAgICAgICAgb2xkTmV0d29ya2luZy5vZmYoJ3N0YXRlQ2hhbmdlJywgdGhpcy5vbk5ldHdvcmtpbmdTdGF0ZUNoYW5nZSk7XG4gICAgICAgIG9sZE5ldHdvcmtpbmcuZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChuZXdTdGF0ZS5zdGF0dXMgPT09IFZvaWNlQ29ubmVjdGlvblN0YXR1cy5SZWFkeSkge1xuICAgICAgdGhpcy5yZWpvaW5BdHRlbXB0cyA9IDA7XG4gICAgfVxuXG4gICAgLy8gSWYgZGVzdHJveWVkLCB0aGUgYWRhcHRlciBjYW4gYWxzbyBiZSBkZXN0cm95ZWQgc28gaXQgY2FuIGJlIGNsZWFuZWQgdXAgYnkgdGhlIHVzZXJcbiAgICBpZiAob2xkU3RhdGUuc3RhdHVzICE9PSBWb2ljZUNvbm5lY3Rpb25TdGF0dXMuRGVzdHJveWVkICYmIG5ld1N0YXRlLnN0YXR1cyA9PT0gVm9pY2VDb25uZWN0aW9uU3RhdHVzLkRlc3Ryb3llZCkge1xuICAgICAgb2xkU3RhdGUuYWRhcHRlci5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgdGhpcy5fc3RhdGUgPSBuZXdTdGF0ZTtcblxuICAgIGlmIChvbGRTdWJzY3JpcHRpb24gJiYgb2xkU3Vic2NyaXB0aW9uICE9PSBuZXdTdWJzY3JpcHRpb24pIHtcbiAgICAgIG9sZFN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cblxuICAgIHRoaXMuZW1pdCgnc3RhdGVDaGFuZ2UnLCBvbGRTdGF0ZSwgbmV3U3RhdGUpO1xuICAgIGlmIChvbGRTdGF0ZS5zdGF0dXMgIT09IG5ld1N0YXRlLnN0YXR1cykge1xuICAgICAgdGhpcy5lbWl0KG5ld1N0YXRlLnN0YXR1cywgb2xkU3RhdGUsIG5ld1N0YXRlIGFzIHVuc2FmZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIGBWT0lDRV9TRVJWRVJfVVBEQVRFYCBwYWNrZXQgdG8gdGhlIHZvaWNlIGNvbm5lY3Rpb24uIFRoaXMgd2lsbCBjYXVzZSBpdCB0byByZWNvbm5lY3QgdXNpbmcgdGhlXG4gICAqIG5ldyBkYXRhIHByb3ZpZGVkIGluIHRoZSBwYWNrZXQuXG4gICAqXG4gICAqIEBwYXJhbSBwYWNrZXQgLSBUaGUgcmVjZWl2ZWQgYFZPSUNFX1NFUlZFUl9VUERBVEVgIHBhY2tldFxuICAgKi9cbiAgcHJpdmF0ZSBhZGRTZXJ2ZXJQYWNrZXQocGFja2V0OiBHYXRld2F5Vm9pY2VTZXJ2ZXJVcGRhdGVEaXNwYXRjaERhdGEpIHtcbiAgICB0aGlzLnBhY2tldHMuc2VydmVyID0gcGFja2V0O1xuICAgIGlmIChwYWNrZXQuZW5kcG9pbnQpIHtcbiAgICAgIHRoaXMuY29uZmlndXJlTmV0d29ya2luZygpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZS5zdGF0dXMgIT09IFZvaWNlQ29ubmVjdGlvblN0YXR1cy5EZXN0cm95ZWQpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgIC4uLnRoaXMuc3RhdGUsXG4gICAgICAgIHN0YXR1czogVm9pY2VDb25uZWN0aW9uU3RhdHVzLkRpc2Nvbm5lY3RlZCxcbiAgICAgICAgcmVhc29uOiBWb2ljZUNvbm5lY3Rpb25EaXNjb25uZWN0UmVhc29uLkVuZHBvaW50UmVtb3ZlZFxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgYFZPSUNFX1NUQVRFX1VQREFURWAgcGFja2V0IHRvIHRoZSB2b2ljZSBjb25uZWN0aW9uLiBNb3N0IGltcG9ydGFudGx5LCBpdCBzdG9yZXMgdGhlIGlkIG9mIHRoZVxuICAgKiBjaGFubmVsIHRoYXQgdGhlIGNsaWVudCBpcyBjb25uZWN0ZWQgdG8uXG4gICAqXG4gICAqIEBwYXJhbSBwYWNrZXQgLSBUaGUgcmVjZWl2ZWQgYFZPSUNFX1NUQVRFX1VQREFURWAgcGFja2V0XG4gICAqL1xuICBwcml2YXRlIGFkZFN0YXRlUGFja2V0KHBhY2tldDogR2F0ZXdheVZvaWNlU3RhdGVVcGRhdGVEaXNwYXRjaERhdGEpIHtcbiAgICB0aGlzLnBhY2tldHMuc3RhdGUgPSBwYWNrZXQ7XG5cbiAgICBpZiAocGFja2V0LnNlbGZfZGVhZiAhPT0gdW5kZWZpbmVkKSB0aGlzLmpvaW5Db25maWcuc2VsZkRlYWYgPSBwYWNrZXQuc2VsZl9kZWFmO1xuICAgIGlmIChwYWNrZXQuc2VsZl9tdXRlICE9PSB1bmRlZmluZWQpIHRoaXMuam9pbkNvbmZpZy5zZWxmTXV0ZSA9IHBhY2tldC5zZWxmX211dGU7XG4gICAgaWYgKHBhY2tldC5jaGFubmVsX2lkKSB0aGlzLmpvaW5Db25maWcuY2hhbm5lbElkID0gcGFja2V0LmNoYW5uZWxfaWQ7XG4gICAgLypcbiAgICB0aGUgY2hhbm5lbF9pZCBiZWluZyBudWxsIGRvZXNuJ3QgbmVjZXNzYXJpbHkgbWVhbiBpdCB3YXMgaW50ZW5kZWQgZm9yIHRoZSBjbGllbnQgdG8gbGVhdmUgdGhlIHZvaWNlIGNoYW5uZWxcbiAgICBhcyBpdCBtYXkgaGF2ZSBkaXNjb25uZWN0ZWQgZHVlIHRvIG5ldHdvcmsgZmFpbHVyZS4gVGhpcyB3aWxsIGJlIGdyYWNlZnVsbHkgaGFuZGxlZCBvbmNlIHRoZSB2b2ljZSB3ZWJzb2NrZXRcbiAgICBkaWVzLCBhbmQgdGhlbiBpdCBpcyB1cCB0byB0aGUgdXNlciB0byBkZWNpZGUgaG93IHRoZXkgd2lzaCB0byBoYW5kbGUgdGhpcy5cbiAgICAqL1xuICB9XG5cbiAgLyoqXG4gICAqIEF0dGVtcHRzIHRvIGNvbmZpZ3VyZSBhIG5ldHdvcmtpbmcgaW5zdGFuY2UgZm9yIHRoaXMgdm9pY2UgY29ubmVjdGlvbiB1c2luZyB0aGUgcmVjZWl2ZWQgcGFja2V0cy5cbiAgICogQm90aCBwYWNrZXRzIGFyZSByZXF1aXJlZCwgYW5kIGFueSBleGlzdGluZyBuZXR3b3JraW5nIGluc3RhbmNlIHdpbGwgYmUgZGVzdHJveWVkLlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBUaGlzIGlzIGNhbGxlZCB3aGVuIHRoZSB2b2ljZSBzZXJ2ZXIgb2YgdGhlIGNvbm5lY3Rpb24gY2hhbmdlcywgZS5nLiBpZiB0aGUgYm90IGlzIG1vdmVkIGludG8gYVxuICAgKiBkaWZmZXJlbnQgY2hhbm5lbCBpbiB0aGUgc2FtZSBndWlsZCBidXQgaGFzIGEgZGlmZmVyZW50IHZvaWNlIHNlcnZlci4gSW4gdGhpcyBpbnN0YW5jZSwgdGhlIGNvbm5lY3Rpb25cbiAgICogbmVlZHMgdG8gYmUgcmUtZXN0YWJsaXNoZWQgdG8gdGhlIG5ldyB2b2ljZSBzZXJ2ZXIuXG4gICAqXG4gICAqIFRoZSBjb25uZWN0aW9uIHdpbGwgdHJhbnNpdGlvbiB0byB0aGUgQ29ubmVjdGluZyBzdGF0ZSB3aGVuIHRoaXMgaXMgY2FsbGVkLlxuICAgKi9cbiAgcHVibGljIGNvbmZpZ3VyZU5ldHdvcmtpbmcoKSB7XG4gICAgY29uc3QgeyBzZXJ2ZXIsIHN0YXRlIH0gPSB0aGlzLnBhY2tldHM7XG4gICAgaWYgKCFzZXJ2ZXIgfHwgIXN0YXRlIHx8IHRoaXMuc3RhdGUuc3RhdHVzID09PSBWb2ljZUNvbm5lY3Rpb25TdGF0dXMuRGVzdHJveWVkIHx8ICFzZXJ2ZXIuZW5kcG9pbnQpIHJldHVybjtcblxuICAgIGNvbnN0IG5ldHdvcmtpbmcgPSBuZXcgTmV0d29ya2luZyhcbiAgICAgIHtcbiAgICAgICAgZW5kcG9pbnQ6IHNlcnZlci5lbmRwb2ludCxcbiAgICAgICAgc2VydmVySWQ6IHNlcnZlci5ndWlsZF9pZCxcbiAgICAgICAgdG9rZW46IHNlcnZlci50b2tlbixcbiAgICAgICAgc2Vzc2lvbklkOiBzdGF0ZS5zZXNzaW9uX2lkLFxuICAgICAgICB1c2VySWQ6IHN0YXRlLnVzZXJfaWRcbiAgICAgIH0sXG4gICAgICBCb29sZWFuKHRoaXMuZGVidWcpXG4gICAgKTtcblxuICAgIG5ldHdvcmtpbmcub25jZSgnY2xvc2UnLCB0aGlzLm9uTmV0d29ya2luZ0Nsb3NlKTtcbiAgICBuZXR3b3JraW5nLm9uKCdzdGF0ZUNoYW5nZScsIHRoaXMub25OZXR3b3JraW5nU3RhdGVDaGFuZ2UpO1xuICAgIG5ldHdvcmtpbmcub24oJ2Vycm9yJywgdGhpcy5vbk5ldHdvcmtpbmdFcnJvcik7XG4gICAgbmV0d29ya2luZy5vbignZGVidWcnLCB0aGlzLm9uTmV0d29ya2luZ0RlYnVnKTtcblxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAuLi50aGlzLnN0YXRlLFxuICAgICAgc3RhdHVzOiBWb2ljZUNvbm5lY3Rpb25TdGF0dXMuQ29ubmVjdGluZyxcbiAgICAgIG5ldHdvcmtpbmdcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIHRoZSBuZXR3b3JraW5nIGluc3RhbmNlIGZvciB0aGlzIGNvbm5lY3Rpb24gY2xvc2VzLiBJZiB0aGUgY2xvc2UgY29kZSBpcyA0MDE0IChkbyBub3QgcmVjb25uZWN0KSxcbiAgICogdGhlIHZvaWNlIGNvbm5lY3Rpb24gd2lsbCB0cmFuc2l0aW9uIHRvIHRoZSBEaXNjb25uZWN0ZWQgc3RhdGUgd2hpY2ggd2lsbCBzdG9yZSB0aGUgY2xvc2UgY29kZS4gWW91IGNhblxuICAgKiBkZWNpZGUgd2hldGhlciBvciBub3QgdG8gcmVjb25uZWN0IHdoZW4gdGhpcyBvY2N1cnMgYnkgbGlzdGVuaW5nIGZvciB0aGUgc3RhdGUgY2hhbmdlIGFuZCBjYWxsaW5nIHJlY29ubmVjdCgpLlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBJZiB0aGUgY2xvc2UgY29kZSB3YXMgYW55dGhpbmcgb3RoZXIgdGhhbiA0MDE0LCBpdCBpcyBsaWtlbHkgdGhhdCB0aGUgY2xvc2luZyB3YXMgbm90IGludGVuZGVkLCBhbmQgc28gdGhlXG4gICAqIFZvaWNlQ29ubmVjdGlvbiB3aWxsIHNpZ25hbCB0byBEaXNjb3JkIHRoYXQgaXQgd291bGQgbGlrZSB0byByZWpvaW4gdGhlIGNoYW5uZWwuIFRoaXMgYXV0b21hdGljYWxseSBhdHRlbXB0c1xuICAgKiB0byByZS1lc3RhYmxpc2ggdGhlIGNvbm5lY3Rpb24uIFRoaXMgd291bGQgYmUgc2VlbiBhcyBhIHRyYW5zaXRpb24gZnJvbSB0aGUgUmVhZHkgc3RhdGUgdG8gdGhlIFNpZ25hbGxpbmcgc3RhdGUuXG4gICAqIEBwYXJhbSBjb2RlIC0gVGhlIGNsb3NlIGNvZGVcbiAgICovXG4gIHByaXZhdGUgb25OZXR3b3JraW5nQ2xvc2UoY29kZTogbnVtYmVyKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUuc3RhdHVzID09PSBWb2ljZUNvbm5lY3Rpb25TdGF0dXMuRGVzdHJveWVkKSByZXR1cm47XG4gICAgLy8gSWYgbmV0d29ya2luZyBjbG9zZXMsIHRyeSB0byBjb25uZWN0IHRvIHRoZSB2b2ljZSBjaGFubmVsIGFnYWluLlxuICAgIGlmIChjb2RlID09PSA0XzAxNCkge1xuICAgICAgLy8gRGlzY29ubmVjdGVkIC0gbmV0d29ya2luZyBpcyBhbHJlYWR5IGRlc3Ryb3llZCBoZXJlXG4gICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAuLi50aGlzLnN0YXRlLFxuICAgICAgICBzdGF0dXM6IFZvaWNlQ29ubmVjdGlvblN0YXR1cy5EaXNjb25uZWN0ZWQsXG4gICAgICAgIHJlYXNvbjogVm9pY2VDb25uZWN0aW9uRGlzY29ubmVjdFJlYXNvbi5XZWJTb2NrZXRDbG9zZSxcbiAgICAgICAgY2xvc2VDb2RlOiBjb2RlXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAuLi50aGlzLnN0YXRlLFxuICAgICAgICBzdGF0dXM6IFZvaWNlQ29ubmVjdGlvblN0YXR1cy5TaWduYWxsaW5nXG4gICAgICB9O1xuICAgICAgdGhpcy5yZWpvaW5BdHRlbXB0cysrO1xuICAgICAgaWYgKCF0aGlzLnN0YXRlLmFkYXB0ZXIuc2VuZFBheWxvYWQoY3JlYXRlSm9pblZvaWNlQ2hhbm5lbFBheWxvYWQodGhpcy5qb2luQ29uZmlnKSkpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAuLi50aGlzLnN0YXRlLFxuICAgICAgICAgIHN0YXR1czogVm9pY2VDb25uZWN0aW9uU3RhdHVzLkRpc2Nvbm5lY3RlZCxcbiAgICAgICAgICByZWFzb246IFZvaWNlQ29ubmVjdGlvbkRpc2Nvbm5lY3RSZWFzb24uQWRhcHRlclVuYXZhaWxhYmxlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIHRoZSBzdGF0ZSBvZiB0aGUgbmV0d29ya2luZyBpbnN0YW5jZSBjaGFuZ2VzLiBUaGlzIGlzIHVzZWQgdG8gZGVyaXZlIHRoZSBzdGF0ZSBvZiB0aGUgdm9pY2UgY29ubmVjdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIG9sZFN0YXRlIC0gVGhlIHByZXZpb3VzIHN0YXRlXG4gICAqIEBwYXJhbSBuZXdTdGF0ZSAtIFRoZSBuZXcgc3RhdGVcbiAgICovXG4gIHByaXZhdGUgb25OZXR3b3JraW5nU3RhdGVDaGFuZ2Uob2xkU3RhdGU6IE5ldHdvcmtpbmdTdGF0ZSwgbmV3U3RhdGU6IE5ldHdvcmtpbmdTdGF0ZSkge1xuICAgIGlmIChvbGRTdGF0ZS5jb2RlID09PSBuZXdTdGF0ZS5jb2RlKSByZXR1cm47XG4gICAgaWYgKHRoaXMuc3RhdGUuc3RhdHVzICE9PSBWb2ljZUNvbm5lY3Rpb25TdGF0dXMuQ29ubmVjdGluZyAmJiB0aGlzLnN0YXRlLnN0YXR1cyAhPT0gVm9pY2VDb25uZWN0aW9uU3RhdHVzLlJlYWR5KVxuICAgIHJldHVybjtcblxuICAgIGlmIChuZXdTdGF0ZS5jb2RlID09PSBOZXR3b3JraW5nU3RhdHVzQ29kZS5SZWFkeSkge1xuICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgLi4udGhpcy5zdGF0ZSxcbiAgICAgICAgc3RhdHVzOiBWb2ljZUNvbm5lY3Rpb25TdGF0dXMuUmVhZHlcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChuZXdTdGF0ZS5jb2RlICE9PSBOZXR3b3JraW5nU3RhdHVzQ29kZS5DbG9zZWQpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgIC4uLnRoaXMuc3RhdGUsXG4gICAgICAgIHN0YXR1czogVm9pY2VDb25uZWN0aW9uU3RhdHVzLkNvbm5lY3RpbmdcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFByb3BhZ2F0ZXMgZXJyb3JzIGZyb20gdGhlIHVuZGVybHlpbmcgbmV0d29yayBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIGVycm9yIC0gVGhlIGVycm9yIHRvIHByb3BhZ2F0ZVxuICAgKi9cbiAgcHJpdmF0ZSBvbk5ldHdvcmtpbmdFcnJvcihlcnJvcjogRXJyb3IpIHtcbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb3BhZ2F0ZXMgZGVidWcgbWVzc2FnZXMgZnJvbSB0aGUgdW5kZXJseWluZyBuZXR3b3JrIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0gbWVzc2FnZSAtIFRoZSBkZWJ1ZyBtZXNzYWdlIHRvIHByb3BhZ2F0ZVxuICAgKi9cbiAgcHJpdmF0ZSBvbk5ldHdvcmtpbmdEZWJ1ZyhtZXNzYWdlOiBzdHJpbmcpIHtcbiAgICB0aGlzLmRlYnVnPy4oYFtOV10gJHttZXNzYWdlfWApO1xuICB9XG5cbiAgLyoqXG4gICAqIFByZXBhcmVzIGFuIGF1ZGlvIHBhY2tldCBmb3IgZGlzcGF0Y2guXG4gICAqXG4gICAqIEBwYXJhbSBidWZmZXIgLSBUaGUgT3B1cyBwYWNrZXQgdG8gcHJlcGFyZVxuICAgKi9cbiAgcHVibGljIHByZXBhcmVBdWRpb1BhY2tldChidWZmZXI6IEJ1ZmZlcikge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAoc3RhdGUuc3RhdHVzICE9PSBWb2ljZUNvbm5lY3Rpb25TdGF0dXMuUmVhZHkpIHJldHVybjtcbiAgICByZXR1cm4gc3RhdGUubmV0d29ya2luZy5wcmVwYXJlQXVkaW9QYWNrZXQoYnVmZmVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEaXNwYXRjaGVzIHRoZSBwcmV2aW91c2x5IHByZXBhcmVkIGF1ZGlvIHBhY2tldCAoaWYgYW55KVxuICAgKi9cbiAgcHVibGljIGRpc3BhdGNoQXVkaW8oKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIGlmIChzdGF0ZS5zdGF0dXMgIT09IFZvaWNlQ29ubmVjdGlvblN0YXR1cy5SZWFkeSkgcmV0dXJuO1xuICAgIHJldHVybiBzdGF0ZS5uZXR3b3JraW5nLmRpc3BhdGNoQXVkaW8oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmVwYXJlcyBhbiBhdWRpbyBwYWNrZXQgYW5kIGRpc3BhdGNoZXMgaXQgaW1tZWRpYXRlbHkuXG4gICAqXG4gICAqIEBwYXJhbSBidWZmZXIgLSBUaGUgT3B1cyBwYWNrZXQgdG8gcGxheVxuICAgKi9cbiAgcHVibGljIHBsYXlPcHVzUGFja2V0KGJ1ZmZlcjogQnVmZmVyKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIGlmIChzdGF0ZS5zdGF0dXMgIT09IFZvaWNlQ29ubmVjdGlvblN0YXR1cy5SZWFkeSkgcmV0dXJuO1xuICAgIHN0YXRlLm5ldHdvcmtpbmcucHJlcGFyZUF1ZGlvUGFja2V0KGJ1ZmZlcik7XG4gICAgcmV0dXJuIHN0YXRlLm5ldHdvcmtpbmcuZGlzcGF0Y2hBdWRpbygpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlc3Ryb3lzIHRoZSBWb2ljZUNvbm5lY3Rpb24sIHByZXZlbnRpbmcgaXQgZnJvbSBjb25uZWN0aW5nIHRvIHZvaWNlIGFnYWluLlxuICAgKiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgY2FsbGVkIHdoZW4geW91IG5vIGxvbmdlciByZXF1aXJlIHRoZSBWb2ljZUNvbm5lY3Rpb24gdG9cbiAgICogcHJldmVudCBtZW1vcnkgbGVha3MuXG4gICAqXG4gICAqIEBwYXJhbSBhZGFwdGVyQXZhaWxhYmxlIC0gV2hldGhlciB0aGUgYWRhcHRlciBjYW4gYmUgdXNlZFxuICAgKi9cbiAgcHVibGljIGRlc3Ryb3koYWRhcHRlckF2YWlsYWJsZSA9IHRydWUpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5zdGF0dXMgPT09IFZvaWNlQ29ubmVjdGlvblN0YXR1cy5EZXN0cm95ZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGRlc3Ryb3kgVm9pY2VDb25uZWN0aW9uIC0gaXQgaGFzIGFscmVhZHkgYmVlbiBkZXN0cm95ZWQnKTtcbiAgICB9XG5cbiAgICBpZiAoZ2V0Vm9pY2VDb25uZWN0aW9uKHRoaXMuam9pbkNvbmZpZy5ndWlsZElkLCB0aGlzLmpvaW5Db25maWcuZ3JvdXApID09PSB0aGlzKSB7XG4gICAgICB1bnRyYWNrVm9pY2VDb25uZWN0aW9uKHRoaXMpO1xuICAgIH1cblxuICAgIGlmIChhZGFwdGVyQXZhaWxhYmxlKSB7XG4gICAgICB0aGlzLnN0YXRlLmFkYXB0ZXIuc2VuZFBheWxvYWQoY3JlYXRlSm9pblZvaWNlQ2hhbm5lbFBheWxvYWQoeyAuLi50aGlzLmpvaW5Db25maWcsIGNoYW5uZWxJZDogbnVsbCB9KSk7XG4gICAgfVxuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIHN0YXR1czogVm9pY2VDb25uZWN0aW9uU3RhdHVzLkRlc3Ryb3llZFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGlzY29ubmVjdHMgdGhlIFZvaWNlQ29ubmVjdGlvbiwgYWxsb3dpbmcgdGhlIHBvc3NpYmlsaXR5IG9mIHJlam9pbmluZyBsYXRlciBvbi5cbiAgICpcbiAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBjb25uZWN0aW9uIHdhcyBzdWNjZXNzZnVsbHkgZGlzY29ubmVjdGVkXG4gICAqL1xuICBwdWJsaWMgZGlzY29ubmVjdCgpIHtcbiAgICBpZiAoXG4gICAgdGhpcy5zdGF0ZS5zdGF0dXMgPT09IFZvaWNlQ29ubmVjdGlvblN0YXR1cy5EZXN0cm95ZWQgfHxcbiAgICB0aGlzLnN0YXRlLnN0YXR1cyA9PT0gVm9pY2VDb25uZWN0aW9uU3RhdHVzLlNpZ25hbGxpbmcpXG4gICAge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuam9pbkNvbmZpZy5jaGFubmVsSWQgPSBudWxsO1xuICAgIGlmICghdGhpcy5zdGF0ZS5hZGFwdGVyLnNlbmRQYXlsb2FkKGNyZWF0ZUpvaW5Wb2ljZUNoYW5uZWxQYXlsb2FkKHRoaXMuam9pbkNvbmZpZykpKSB7XG4gICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICBhZGFwdGVyOiB0aGlzLnN0YXRlLmFkYXB0ZXIsXG4gICAgICAgIHN1YnNjcmlwdGlvbjogdGhpcy5zdGF0ZS5zdWJzY3JpcHRpb24sXG4gICAgICAgIHN0YXR1czogVm9pY2VDb25uZWN0aW9uU3RhdHVzLkRpc2Nvbm5lY3RlZCxcbiAgICAgICAgcmVhc29uOiBWb2ljZUNvbm5lY3Rpb25EaXNjb25uZWN0UmVhc29uLkFkYXB0ZXJVbmF2YWlsYWJsZVxuICAgICAgfTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgYWRhcHRlcjogdGhpcy5zdGF0ZS5hZGFwdGVyLFxuICAgICAgcmVhc29uOiBWb2ljZUNvbm5lY3Rpb25EaXNjb25uZWN0UmVhc29uLk1hbnVhbCxcbiAgICAgIHN0YXR1czogVm9pY2VDb25uZWN0aW9uU3RhdHVzLkRpc2Nvbm5lY3RlZFxuICAgIH07XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQXR0ZW1wdHMgdG8gcmVqb2luIChiZXR0ZXIgZXhwbGFuYXRpb24gc29vbjp0bTopXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIENhbGxpbmcgdGhpcyBtZXRob2Qgc3VjY2Vzc2Z1bGx5IHdpbGwgYXV0b21hdGljYWxseSBpbmNyZW1lbnQgdGhlIGByZWpvaW5BdHRlbXB0c2AgY291bnRlcixcbiAgICogd2hpY2ggeW91IGNhbiB1c2UgdG8gaW5mb3JtIHdoZXRoZXIgb3Igbm90IHlvdSdkIGxpa2UgdG8ga2VlcCBhdHRlbXB0aW5nIHRvIHJlY29ubmVjdCB5b3VyXG4gICAqIHZvaWNlIGNvbm5lY3Rpb24uXG4gICAqXG4gICAqIEEgc3RhdGUgdHJhbnNpdGlvbiBmcm9tIERpc2Nvbm5lY3RlZCB0byBTaWduYWxsaW5nIHdpbGwgYmUgb2JzZXJ2ZWQgd2hlbiB0aGlzIGlzIGNhbGxlZC5cbiAgICovXG4gIHB1YmxpYyByZWpvaW4oam9pbkNvbmZpZz86IE9taXQ8Sm9pbkNvbmZpZywgJ2dyb3VwJyB8ICdndWlsZElkJz4pIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5zdGF0dXMgPT09IFZvaWNlQ29ubmVjdGlvblN0YXR1cy5EZXN0cm95ZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBub3RSZWFkeSA9IHRoaXMuc3RhdGUuc3RhdHVzICE9PSBWb2ljZUNvbm5lY3Rpb25TdGF0dXMuUmVhZHk7XG5cbiAgICBpZiAobm90UmVhZHkpIHRoaXMucmVqb2luQXR0ZW1wdHMrKztcbiAgICBPYmplY3QuYXNzaWduKHRoaXMuam9pbkNvbmZpZywgam9pbkNvbmZpZyk7XG4gICAgaWYgKHRoaXMuc3RhdGUuYWRhcHRlci5zZW5kUGF5bG9hZChjcmVhdGVKb2luVm9pY2VDaGFubmVsUGF5bG9hZCh0aGlzLmpvaW5Db25maWcpKSkge1xuICAgICAgaWYgKG5vdFJlYWR5KSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgLi4udGhpcy5zdGF0ZSxcbiAgICAgICAgICBzdGF0dXM6IFZvaWNlQ29ubmVjdGlvblN0YXR1cy5TaWduYWxsaW5nXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBhZGFwdGVyOiB0aGlzLnN0YXRlLmFkYXB0ZXIsXG4gICAgICBzdWJzY3JpcHRpb246IHRoaXMuc3RhdGUuc3Vic2NyaXB0aW9uLFxuICAgICAgc3RhdHVzOiBWb2ljZUNvbm5lY3Rpb25TdGF0dXMuRGlzY29ubmVjdGVkLFxuICAgICAgcmVhc29uOiBWb2ljZUNvbm5lY3Rpb25EaXNjb25uZWN0UmVhc29uLkFkYXB0ZXJVbmF2YWlsYWJsZVxuICAgIH07XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHNwZWFraW5nIHN0YXR1cyBvZiB0aGUgdm9pY2UgY29ubmVjdGlvbi4gVGhpcyBpcyB1c2VkIHdoZW4gYXVkaW8gcGxheWVycyBhcmUgZG9uZSBwbGF5aW5nIGF1ZGlvLFxuICAgKiBhbmQgbmVlZCB0byBzaWduYWwgdGhhdCB0aGUgY29ubmVjdGlvbiBpcyBubyBsb25nZXIgcGxheWluZyBhdWRpby5cbiAgICpcbiAgICogQHBhcmFtIGVuYWJsZWQgLSBXaGV0aGVyIG9yIG5vdCB0byBzaG93IGFzIHNwZWFraW5nXG4gICAqL1xuICBwdWJsaWMgc2V0U3BlYWtpbmcoZW5hYmxlZDogYm9vbGVhbikge1xuICAgIGlmICh0aGlzLnN0YXRlLnN0YXR1cyAhPT0gVm9pY2VDb25uZWN0aW9uU3RhdHVzLlJlYWR5KSByZXR1cm4gZmFsc2U7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1jb25mdXNpbmctdm9pZC1leHByZXNzaW9uXG4gICAgcmV0dXJuIHRoaXMuc3RhdGUubmV0d29ya2luZy5zZXRTcGVha2luZyhlbmFibGVkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJzY3JpYmVzIHRvIGFuIGF1ZGlvIHBsYXllciwgYWxsb3dpbmcgdGhlIHBsYXllciB0byBwbGF5IGF1ZGlvIG9uIHRoaXMgdm9pY2UgY29ubmVjdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHBsYXllciAtIFRoZSBhdWRpbyBwbGF5ZXIgdG8gc3Vic2NyaWJlIHRvXG4gICAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIHN1YnNjcmlwdGlvblxuICAgKi9cbiAgcHVibGljIHN1YnNjcmliZShwbGF5ZXI6IEF1ZGlvUGxheWVyKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUuc3RhdHVzID09PSBWb2ljZUNvbm5lY3Rpb25TdGF0dXMuRGVzdHJveWVkKSByZXR1cm47XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2RvdC1ub3RhdGlvblxuICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHBsYXllclsnc3Vic2NyaWJlJ10odGhpcyk7XG5cbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgLi4udGhpcy5zdGF0ZSxcbiAgICAgIHN1YnNjcmlwdGlvblxuICAgIH07XG5cbiAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBsYXRlc3QgcGluZyAoaW4gbWlsbGlzZWNvbmRzKSBmb3IgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uIGFuZCBhdWRpbyBwbGF5YmFjayBmb3IgdGhpcyB2b2ljZVxuICAgKiBjb25uZWN0aW9uLCBpZiB0aGlzIGRhdGEgaXMgYXZhaWxhYmxlLlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBGb3IgdGhpcyBkYXRhIHRvIGJlIGF2YWlsYWJsZSwgdGhlIFZvaWNlQ29ubmVjdGlvbiBtdXN0IGJlIGluIHRoZSBSZWFkeSBzdGF0ZSwgYW5kIGl0cyB1bmRlcmx5aW5nXG4gICAqIFdlYlNvY2tldCBjb25uZWN0aW9uIGFuZCBVRFAgc29ja2V0IG11c3QgaGF2ZSBoYWQgYXQgbGVhc3Qgb25lIHBpbmctcG9uZyBleGNoYW5nZS5cbiAgICovXG4gIHB1YmxpYyBnZXQgcGluZygpIHtcbiAgICBpZiAoXG4gICAgdGhpcy5zdGF0ZS5zdGF0dXMgPT09IFZvaWNlQ29ubmVjdGlvblN0YXR1cy5SZWFkeSAmJlxuICAgIHRoaXMuc3RhdGUubmV0d29ya2luZy5zdGF0ZS5jb2RlID09PSBOZXR3b3JraW5nU3RhdHVzQ29kZS5SZWFkeSlcbiAgICB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3czogdGhpcy5zdGF0ZS5uZXR3b3JraW5nLnN0YXRlLndzLnBpbmcsXG4gICAgICAgIHVkcDogdGhpcy5zdGF0ZS5uZXR3b3JraW5nLnN0YXRlLnVkcC5waW5nXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB3czogdW5kZWZpbmVkLFxuICAgICAgdWRwOiB1bmRlZmluZWRcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIGEgc3Vic2NyaXB0aW9uIG9mIHRoaXMgdm9pY2UgY29ubmVjdGlvbiB0byBhbiBhdWRpbyBwbGF5ZXIgaXMgcmVtb3ZlZC5cbiAgICpcbiAgICogQHBhcmFtIHN1YnNjcmlwdGlvbiAtIFRoZSByZW1vdmVkIHN1YnNjcmlwdGlvblxuICAgKi9cbiAgcHJvdGVjdGVkIG9uU3Vic2NyaXB0aW9uUmVtb3ZlZChzdWJzY3JpcHRpb246IFBsYXllclN1YnNjcmlwdGlvbikge1xuICAgIGlmICh0aGlzLnN0YXRlLnN0YXR1cyAhPT0gVm9pY2VDb25uZWN0aW9uU3RhdHVzLkRlc3Ryb3llZCAmJiB0aGlzLnN0YXRlLnN1YnNjcmlwdGlvbiA9PT0gc3Vic2NyaXB0aW9uKSB7XG4gICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAuLi50aGlzLnN0YXRlLFxuICAgICAgICBzdWJzY3JpcHRpb246IHVuZGVmaW5lZFxuICAgICAgfTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZvaWNlIGNvbm5lY3Rpb24uXG4gKlxuICogQHBhcmFtIGpvaW5Db25maWcgLSBUaGUgZGF0YSByZXF1aXJlZCB0byBlc3RhYmxpc2ggdGhlIHZvaWNlIGNvbm5lY3Rpb25cbiAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgdG8gdXNlIHdoZW4gam9pbmluZyB0aGUgdm9pY2UgY2hhbm5lbFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVm9pY2VDb25uZWN0aW9uKGpvaW5Db25maWc6IEpvaW5Db25maWcsIG9wdGlvbnM6IENyZWF0ZVZvaWNlQ29ubmVjdGlvbk9wdGlvbnMpIHtcbiAgY29uc3QgcGF5bG9hZCA9IGNyZWF0ZUpvaW5Wb2ljZUNoYW5uZWxQYXlsb2FkKGpvaW5Db25maWcpO1xuICBjb25zdCBleGlzdGluZyA9IGdldFZvaWNlQ29ubmVjdGlvbihqb2luQ29uZmlnLmd1aWxkSWQsIGpvaW5Db25maWcuZ3JvdXApO1xuICBpZiAoZXhpc3RpbmcgJiYgZXhpc3Rpbmcuc3RhdGUuc3RhdHVzICE9PSBWb2ljZUNvbm5lY3Rpb25TdGF0dXMuRGVzdHJveWVkKSB7XG4gICAgaWYgKGV4aXN0aW5nLnN0YXRlLnN0YXR1cyA9PT0gVm9pY2VDb25uZWN0aW9uU3RhdHVzLkRpc2Nvbm5lY3RlZCkge1xuICAgICAgZXhpc3RpbmcucmVqb2luKHtcbiAgICAgICAgY2hhbm5lbElkOiBqb2luQ29uZmlnLmNoYW5uZWxJZCxcbiAgICAgICAgc2VsZkRlYWY6IGpvaW5Db25maWcuc2VsZkRlYWYsXG4gICAgICAgIHNlbGZNdXRlOiBqb2luQ29uZmlnLnNlbGZNdXRlXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKCFleGlzdGluZy5zdGF0ZS5hZGFwdGVyLnNlbmRQYXlsb2FkKHBheWxvYWQpKSB7XG4gICAgICBleGlzdGluZy5zdGF0ZSA9IHtcbiAgICAgICAgLi4uZXhpc3Rpbmcuc3RhdGUsXG4gICAgICAgIHN0YXR1czogVm9pY2VDb25uZWN0aW9uU3RhdHVzLkRpc2Nvbm5lY3RlZCxcbiAgICAgICAgcmVhc29uOiBWb2ljZUNvbm5lY3Rpb25EaXNjb25uZWN0UmVhc29uLkFkYXB0ZXJVbmF2YWlsYWJsZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXhpc3Rpbmc7XG4gIH1cblxuICBjb25zdCB2b2ljZUNvbm5lY3Rpb24gPSBuZXcgVm9pY2VDb25uZWN0aW9uKGpvaW5Db25maWcsIG9wdGlvbnMpO1xuICB0cmFja1ZvaWNlQ29ubmVjdGlvbih2b2ljZUNvbm5lY3Rpb24pO1xuICBpZiAoXG4gIHZvaWNlQ29ubmVjdGlvbi5zdGF0ZS5zdGF0dXMgIT09IFZvaWNlQ29ubmVjdGlvblN0YXR1cy5EZXN0cm95ZWQgJiZcbiAgIXZvaWNlQ29ubmVjdGlvbi5zdGF0ZS5hZGFwdGVyLnNlbmRQYXlsb2FkKHBheWxvYWQpKVxuICB7XG4gICAgdm9pY2VDb25uZWN0aW9uLnN0YXRlID0ge1xuICAgICAgLi4udm9pY2VDb25uZWN0aW9uLnN0YXRlLFxuICAgICAgc3RhdHVzOiBWb2ljZUNvbm5lY3Rpb25TdGF0dXMuRGlzY29ubmVjdGVkLFxuICAgICAgcmVhc29uOiBWb2ljZUNvbm5lY3Rpb25EaXNjb25uZWN0UmVhc29uLkFkYXB0ZXJVbmF2YWlsYWJsZVxuICAgIH07XG4gIH1cblxuICByZXR1cm4gdm9pY2VDb25uZWN0aW9uO1xufSIsICIvLyBDb3B5cmlnaHQgZGlzY29yZC1wbGF5ZXIgYXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC4gTUlUIExpY2Vuc2UuXG4vLyBDb3B5cmlnaHQgZGlzY29yZC5qcyBhdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLiBBcGFjaGUgTGljZW5zZSAyLjBcblxuaW1wb3J0IHsgR2F0ZXdheU9wY29kZXMgfSBmcm9tICdkaXNjb3JkLWFwaS10eXBlcy92MTAnO1xuaW1wb3J0IHR5cGUgeyBWb2ljZUNvbm5lY3Rpb24gfSBmcm9tICcuL1ZvaWNlQ29ubmVjdGlvbic7XG5pbXBvcnQgdHlwZSB7IEF1ZGlvUGxheWVyIH0gZnJvbSAnLi9hdWRpby9pbmRleCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSm9pbkNvbmZpZyB7XG4gIGNoYW5uZWxJZDogc3RyaW5nIHwgbnVsbDtcbiAgZ3JvdXA6IHN0cmluZztcbiAgZ3VpbGRJZDogc3RyaW5nO1xuICBzZWxmRGVhZjogYm9vbGVhbjtcbiAgc2VsZk11dGU6IGJvb2xlYW47XG59XG5cbi8qKlxuICogU2VuZHMgYSB2b2ljZSBzdGF0ZSB1cGRhdGUgdG8gdGhlIG1haW4gd2Vic29ja2V0IHNoYXJkIG9mIGEgZ3VpbGQsIHRvIGluZGljYXRlIGpvaW5pbmcvbGVhdmluZy9tb3ZpbmcgYWNyb3NzXG4gKiB2b2ljZSBjaGFubmVscy5cbiAqXG4gKiBAcGFyYW0gY29uZmlnIC0gVGhlIGNvbmZpZ3VyYXRpb24gdG8gdXNlIHdoZW4gam9pbmluZyB0aGUgdm9pY2UgY2hhbm5lbFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSm9pblZvaWNlQ2hhbm5lbFBheWxvYWQoY29uZmlnOiBKb2luQ29uZmlnKSB7XG4gIHJldHVybiB7XG4gICAgb3A6IEdhdGV3YXlPcGNvZGVzLlZvaWNlU3RhdGVVcGRhdGUsXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGlkLWxlbmd0aFxuICAgIGQ6IHtcbiAgICAgIGd1aWxkX2lkOiBjb25maWcuZ3VpbGRJZCxcbiAgICAgIGNoYW5uZWxfaWQ6IGNvbmZpZy5jaGFubmVsSWQsXG4gICAgICBzZWxmX2RlYWY6IGNvbmZpZy5zZWxmRGVhZixcbiAgICAgIHNlbGZfbXV0ZTogY29uZmlnLnNlbGZNdXRlXG4gICAgfVxuICB9O1xufVxuXG4vLyBWb2ljZSBDb25uZWN0aW9uc1xuY29uc3QgZ3JvdXBzID0gbmV3IE1hcDxzdHJpbmcsIE1hcDxzdHJpbmcsIFZvaWNlQ29ubmVjdGlvbj4+KCk7XG5ncm91cHMuc2V0KCdkZWZhdWx0JywgbmV3IE1hcCgpKTtcblxuZnVuY3Rpb24gZ2V0T3JDcmVhdGVHcm91cChncm91cDogc3RyaW5nKSB7XG4gIGNvbnN0IGV4aXN0aW5nID0gZ3JvdXBzLmdldChncm91cCk7XG4gIGlmIChleGlzdGluZykgcmV0dXJuIGV4aXN0aW5nO1xuICBjb25zdCBtYXAgPSBuZXcgTWFwPHN0cmluZywgVm9pY2VDb25uZWN0aW9uPigpO1xuICBncm91cHMuc2V0KGdyb3VwLCBtYXApO1xuICByZXR1cm4gbWFwO1xufVxuXG4vKipcbiAqIFJldHJpZXZlcyB0aGUgbWFwIG9mIGdyb3VwIG5hbWVzIHRvIG1hcHMgb2Ygdm9pY2UgY29ubmVjdGlvbnMuIEJ5IGRlZmF1bHQsIGFsbCB2b2ljZSBjb25uZWN0aW9uc1xuICogYXJlIGNyZWF0ZWQgdW5kZXIgdGhlICdkZWZhdWx0JyBncm91cC5cbiAqXG4gKiBAcmV0dXJucyBUaGUgZ3JvdXAgbWFwXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRHcm91cHMoKSB7XG4gIHJldHVybiBncm91cHM7XG59XG5cbi8qKlxuICogUmV0cmlldmVzIGFsbCB0aGUgdm9pY2UgY29ubmVjdGlvbnMgdW5kZXIgdGhlICdkZWZhdWx0JyBncm91cC5cbiAqXG4gKiBAcGFyYW0gZ3JvdXAgLSBUaGUgZ3JvdXAgdG8gbG9vayB1cFxuICogQHJldHVybnMgVGhlIG1hcCBvZiB2b2ljZSBjb25uZWN0aW9uc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Vm9pY2VDb25uZWN0aW9ucyhncm91cD86ICdkZWZhdWx0Jyk6IE1hcDxzdHJpbmcsIFZvaWNlQ29ubmVjdGlvbj47XG5cbi8qKlxuICogUmV0cmlldmVzIGFsbCB0aGUgdm9pY2UgY29ubmVjdGlvbnMgdW5kZXIgdGhlIGdpdmVuIGdyb3VwIG5hbWUuXG4gKlxuICogQHBhcmFtIGdyb3VwIC0gVGhlIGdyb3VwIHRvIGxvb2sgdXBcbiAqIEByZXR1cm5zIFRoZSBtYXAgb2Ygdm9pY2UgY29ubmVjdGlvbnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFZvaWNlQ29ubmVjdGlvbnMoZ3JvdXA6IHN0cmluZyk6IE1hcDxzdHJpbmcsIFZvaWNlQ29ubmVjdGlvbj4gfCB1bmRlZmluZWQ7XG5cbi8qKlxuICogUmV0cmlldmVzIGFsbCB0aGUgdm9pY2UgY29ubmVjdGlvbnMgdW5kZXIgdGhlIGdpdmVuIGdyb3VwIG5hbWUuIERlZmF1bHRzIHRvIHRoZSAnZGVmYXVsdCcgZ3JvdXAuXG4gKlxuICogQHBhcmFtIGdyb3VwIC0gVGhlIGdyb3VwIHRvIGxvb2sgdXBcbiAqIEByZXR1cm5zIFRoZSBtYXAgb2Ygdm9pY2UgY29ubmVjdGlvbnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFZvaWNlQ29ubmVjdGlvbnMoZ3JvdXAgPSAnZGVmYXVsdCcpIHtcbiAgcmV0dXJuIGdyb3Vwcy5nZXQoZ3JvdXApO1xufVxuXG4vKipcbiAqIEZpbmRzIGEgdm9pY2UgY29ubmVjdGlvbiB3aXRoIHRoZSBnaXZlbiBndWlsZCBpZCBhbmQgZ3JvdXAuIERlZmF1bHRzIHRvIHRoZSAnZGVmYXVsdCcgZ3JvdXAuXG4gKlxuICogQHBhcmFtIGd1aWxkSWQgLSBUaGUgZ3VpbGQgaWQgb2YgdGhlIHZvaWNlIGNvbm5lY3Rpb25cbiAqIEBwYXJhbSBncm91cCAtIHRoZSBncm91cCB0aGF0IHRoZSB2b2ljZSBjb25uZWN0aW9uIHdhcyByZWdpc3RlcmVkIHdpdGhcbiAqIEByZXR1cm5zIFRoZSB2b2ljZSBjb25uZWN0aW9uLCBpZiBpdCBleGlzdHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFZvaWNlQ29ubmVjdGlvbihndWlsZElkOiBzdHJpbmcsIGdyb3VwID0gJ2RlZmF1bHQnKSB7XG4gIHJldHVybiBnZXRWb2ljZUNvbm5lY3Rpb25zKGdyb3VwKT8uZ2V0KGd1aWxkSWQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdW50cmFja1ZvaWNlQ29ubmVjdGlvbih2b2ljZUNvbm5lY3Rpb246IFZvaWNlQ29ubmVjdGlvbikge1xuICByZXR1cm4gZ2V0Vm9pY2VDb25uZWN0aW9ucyh2b2ljZUNvbm5lY3Rpb24uam9pbkNvbmZpZy5ncm91cCk/LmRlbGV0ZSh2b2ljZUNvbm5lY3Rpb24uam9pbkNvbmZpZy5ndWlsZElkKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYWNrVm9pY2VDb25uZWN0aW9uKHZvaWNlQ29ubmVjdGlvbjogVm9pY2VDb25uZWN0aW9uKSB7XG4gIHJldHVybiBnZXRPckNyZWF0ZUdyb3VwKHZvaWNlQ29ubmVjdGlvbi5qb2luQ29uZmlnLmdyb3VwKS5zZXQodm9pY2VDb25uZWN0aW9uLmpvaW5Db25maWcuZ3VpbGRJZCwgdm9pY2VDb25uZWN0aW9uKTtcbn1cblxuLy8gQXVkaW8gUGxheWVyc1xuXG4vLyBFYWNoIGF1ZGlvIHBhY2tldCBpcyAyMG1zIGxvbmdcbmNvbnN0IEZSQU1FX0xFTkdUSCA9IDIwO1xuXG5sZXQgYXVkaW9DeWNsZUludGVydmFsOiBOb2RlSlMuVGltZW91dCB8IHVuZGVmaW5lZDtcbmxldCBuZXh0VGltZSA9IC0xO1xuXG4vKipcbiAqIEEgbGlzdCBvZiBjcmVhdGVkIGF1ZGlvIHBsYXllcnMgdGhhdCBhcmUgc3RpbGwgYWN0aXZlIGFuZCBoYXZlbid0IGJlZW4gZGVzdHJveWVkLlxuICovXG5jb25zdCBhdWRpb1BsYXllcnM6IEF1ZGlvUGxheWVyW10gPSBbXTtcblxuLyoqXG4gKiBDYWxsZWQgcm91Z2hseSBldmVyeSAyMCBtaWxsaXNlY29uZHMuIERpc3BhdGNoZXMgYXVkaW8gZnJvbSBhbGwgcGxheWVycywgYW5kIHRoZW4gZ2V0cyB0aGUgcGxheWVycyB0byBwcmVwYXJlXG4gKiB0aGUgbmV4dCBhdWRpbyBmcmFtZS5cbiAqL1xuZnVuY3Rpb24gYXVkaW9DeWNsZVN0ZXAoKSB7XG4gIGlmIChuZXh0VGltZSA9PT0gLTEpIHJldHVybjtcblxuICBuZXh0VGltZSArPSBGUkFNRV9MRU5HVEg7XG4gIGNvbnN0IGF2YWlsYWJsZSA9IGF1ZGlvUGxheWVycy5maWx0ZXIoKHBsYXllcikgPT4gcGxheWVyLmNoZWNrUGxheWFibGUoKSk7XG5cbiAgZm9yIChjb25zdCBwbGF5ZXIgb2YgYXZhaWxhYmxlKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9kb3Qtbm90YXRpb25cbiAgICBwbGF5ZXJbJ19zdGVwRGlzcGF0Y2gnXSgpO1xuICB9XG5cbiAgcHJlcGFyZU5leHRBdWRpb0ZyYW1lKGF2YWlsYWJsZSk7XG59XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgZ2V0cyB0aGUgcGxheWVycyB0aGF0IGhhdmUgYmVlbiBwYXNzZWQgYXMgcGFyYW1ldGVycyB0byBwcmVwYXJlIGF1ZGlvIGZyYW1lcyB0aGF0IGNhbiBiZSBwbGF5ZWRcbiAqIGF0IHRoZSBzdGFydCBvZiB0aGUgbmV4dCBjeWNsZS5cbiAqL1xuZnVuY3Rpb24gcHJlcGFyZU5leHRBdWRpb0ZyYW1lKHBsYXllcnM6IEF1ZGlvUGxheWVyW10pIHtcbiAgY29uc3QgbmV4dFBsYXllciA9IHBsYXllcnMuc2hpZnQoKTtcblxuICBpZiAoIW5leHRQbGF5ZXIpIHtcbiAgICBpZiAobmV4dFRpbWUgIT09IC0xKSB7XG4gICAgICBhdWRpb0N5Y2xlSW50ZXJ2YWwgPSBzZXRUaW1lb3V0KCgpID0+IGF1ZGlvQ3ljbGVTdGVwKCksIG5leHRUaW1lIC0gRGF0ZS5ub3coKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9kb3Qtbm90YXRpb25cbiAgbmV4dFBsYXllclsnX3N0ZXBQcmVwYXJlJ10oKTtcblxuICAvLyBzZXRJbW1lZGlhdGUgdG8gYXZvaWQgbG9uZyBhdWRpbyBwbGF5ZXIgY2hhaW5zIGJsb2NraW5nIG90aGVyIHNjaGVkdWxlZCB0YXNrc1xuICBzZXRJbW1lZGlhdGUoKCkgPT4gcHJlcGFyZU5leHRBdWRpb0ZyYW1lKHBsYXllcnMpKTtcbn1cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhlIGdpdmVuIGF1ZGlvIHBsYXllciBpcyBiZWluZyBkcml2ZW4gYnkgdGhlIGRhdGEgc3RvcmUgY2xvY2suXG4gKlxuICogQHBhcmFtIHRhcmdldCAtIFRoZSB0YXJnZXQgdG8gdGVzdCBmb3JcbiAqIEByZXR1cm5zIGB0cnVlYCBpZiBpdCBpcyBiZWluZyB0cmFja2VkLCBgZmFsc2VgIG90aGVyd2lzZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzQXVkaW9QbGF5ZXIodGFyZ2V0OiBBdWRpb1BsYXllcikge1xuICByZXR1cm4gYXVkaW9QbGF5ZXJzLmluY2x1ZGVzKHRhcmdldCk7XG59XG5cbi8qKlxuICogQWRkcyBhbiBhdWRpbyBwbGF5ZXIgdG8gdGhlIGRhdGEgc3RvcmUgdHJhY2tpbmcgbGlzdCwgaWYgaXQgaXNuJ3QgYWxyZWFkeSB0aGVyZS5cbiAqXG4gKiBAcGFyYW0gcGxheWVyIC0gVGhlIHBsYXllciB0byB0cmFja1xuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkQXVkaW9QbGF5ZXIocGxheWVyOiBBdWRpb1BsYXllcikge1xuICBpZiAoaGFzQXVkaW9QbGF5ZXIocGxheWVyKSkgcmV0dXJuIHBsYXllcjtcbiAgYXVkaW9QbGF5ZXJzLnB1c2gocGxheWVyKTtcbiAgaWYgKGF1ZGlvUGxheWVycy5sZW5ndGggPT09IDEpIHtcbiAgICBuZXh0VGltZSA9IERhdGUubm93KCk7XG4gICAgc2V0SW1tZWRpYXRlKCgpID0+IGF1ZGlvQ3ljbGVTdGVwKCkpO1xuICB9XG5cbiAgcmV0dXJuIHBsYXllcjtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFuIGF1ZGlvIHBsYXllciBmcm9tIHRoZSBkYXRhIHN0b3JlIHRyYWNraW5nIGxpc3QsIGlmIGl0IGlzIHByZXNlbnQgdGhlcmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWxldGVBdWRpb1BsYXllcihwbGF5ZXI6IEF1ZGlvUGxheWVyKSB7XG4gIGNvbnN0IGluZGV4ID0gYXVkaW9QbGF5ZXJzLmluZGV4T2YocGxheWVyKTtcbiAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuO1xuICBhdWRpb1BsYXllcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgaWYgKGF1ZGlvUGxheWVycy5sZW5ndGggPT09IDApIHtcbiAgICBuZXh0VGltZSA9IC0xO1xuICAgIGlmIChhdWRpb0N5Y2xlSW50ZXJ2YWwgIT09IHVuZGVmaW5lZCkgY2xlYXJUaW1lb3V0KGF1ZGlvQ3ljbGVJbnRlcnZhbCk7XG4gIH1cbn0iLCAiLy8gQ29weXJpZ2h0IGRpc2NvcmQtcGxheWVyIGF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuIE1JVCBMaWNlbnNlLlxuLy8gQ29weXJpZ2h0IGRpc2NvcmQuanMgYXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC4gQXBhY2hlIExpY2Vuc2UgMi4wXG5cbi8qIGVzbGludC1kaXNhYmxlIGlkLWxlbmd0aCAqL1xuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L3VuYm91bmQtbWV0aG9kLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWRlY2xhcmF0aW9uLW1lcmdpbmcgKi9cbmltcG9ydCB7IEJ1ZmZlciB9IGZyb20gJ25vZGU6YnVmZmVyJztcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ25vZGU6ZXZlbnRzJztcbmltcG9ydCBjcnlwdG8gZnJvbSAnbm9kZTpjcnlwdG8nO1xuaW1wb3J0IHsgVm9pY2VPcGNvZGVzIH0gZnJvbSAnZGlzY29yZC1hcGktdHlwZXMvdm9pY2UvdjQnO1xuaW1wb3J0ICogYXMgc2VjcmV0Ym94IGZyb20gJy4uL3V0aWwvU2VjcmV0Ym94JztcbmltcG9ydCB7IG5vb3AgfSBmcm9tICcuLi91dGlsL3V0aWwnO1xuaW1wb3J0IHsgVm9pY2VVRFBTb2NrZXQgfSBmcm9tICcuL1ZvaWNlVURQU29ja2V0JztcbmltcG9ydCB7IFZvaWNlV2ViU29ja2V0IH0gZnJvbSAnLi9Wb2ljZVdlYlNvY2tldCc7XG5pbXBvcnQgeyB1bnNhZmUgfSBmcm9tICcuLi9jb21tb24vdHlwZXMnO1xuXG4vLyBUaGUgbnVtYmVyIG9mIGF1ZGlvIGNoYW5uZWxzIHJlcXVpcmVkIGJ5IERpc2NvcmRcbmNvbnN0IENIQU5ORUxTID0gMjtcbmNvbnN0IFRJTUVTVEFNUF9JTkMgPSA0OF8wMDAgLyAxMDAgKiBDSEFOTkVMUztcbmNvbnN0IE1BWF9OT05DRV9TSVpFID0gMiAqKiAzMiAtIDE7XG5cbmV4cG9ydCBjb25zdCBTVVBQT1JURURfRU5DUllQVElPTl9NT0RFUyA9IFsnYWVhZF94Y2hhY2hhMjBfcG9seTEzMDVfcnRwc2l6ZSddO1xuXG4vLyBKdXN0IGluIGNhc2UgdGhlcmUncyBzb21lIHN5c3RlbSB0aGF0IGRvZXNuJ3QgY29tZSB3aXRoIGFlcy0yNTYtZ2NtLCBjb25kaXRpb25hbGx5IGFkZCBpdCBhcyBzdXBwb3J0ZWRcbmlmIChjcnlwdG8uZ2V0Q2lwaGVycygpLmluY2x1ZGVzKCdhZXMtMjU2LWdjbScpKSB7XG4gIFNVUFBPUlRFRF9FTkNSWVBUSU9OX01PREVTLnVuc2hpZnQoJ2FlYWRfYWVzMjU2X2djbV9ydHBzaXplJyk7XG59XG5cbi8qKlxuICogVGhlIGRpZmZlcmVudCBzdGF0dXNlcyB0aGF0IGEgbmV0d29ya2luZyBpbnN0YW5jZSBjYW4gaG9sZC4gVGhlIG9yZGVyXG4gKiBvZiB0aGUgc3RhdGVzIGJldHdlZW4gT3BlbmluZ1dzIGFuZCBSZWFkeSBpcyBjaHJvbm9sb2dpY2FsIChmaXJzdCB0aGVcbiAqIGluc3RhbmNlIGVudGVycyBPcGVuaW5nV3MsIHRoZW4gaXQgZW50ZXJzIElkZW50aWZ5aW5nIGV0Yy4pXG4gKi9cbmV4cG9ydCBlbnVtIE5ldHdvcmtpbmdTdGF0dXNDb2RlIHtcbiAgT3BlbmluZ1dzLFxuICBJZGVudGlmeWluZyxcbiAgVWRwSGFuZHNoYWtpbmcsXG4gIFNlbGVjdGluZ1Byb3RvY29sLFxuICBSZWFkeSxcbiAgUmVzdW1pbmcsXG4gIENsb3NlZCxcbn1cblxuLyoqXG4gKiBUaGUgaW5pdGlhbCBOZXR3b3JraW5nIHN0YXRlLiBJbnN0YW5jZXMgd2lsbCBiZSBpbiB0aGlzIHN0YXRlIHdoZW4gYSBXZWJTb2NrZXQgY29ubmVjdGlvbiB0byBhIERpc2NvcmRcbiAqIHZvaWNlIGdhdGV3YXkgaXMgYmVpbmcgb3BlbmVkLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE5ldHdvcmtpbmdPcGVuaW5nV3NTdGF0ZSB7XG4gIGNvZGU6IE5ldHdvcmtpbmdTdGF0dXNDb2RlLk9wZW5pbmdXcztcbiAgY29ubmVjdGlvbk9wdGlvbnM6IENvbm5lY3Rpb25PcHRpb25zO1xuICB3czogVm9pY2VXZWJTb2NrZXQ7XG59XG5cbi8qKlxuICogVGhlIHN0YXRlIHRoYXQgYSBOZXR3b3JraW5nIGluc3RhbmNlIHdpbGwgYmUgaW4gd2hlbiBpdCBpcyBhdHRlbXB0aW5nIHRvIGF1dGhvcml6ZSBpdHNlbGYuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTmV0d29ya2luZ0lkZW50aWZ5aW5nU3RhdGUge1xuICBjb2RlOiBOZXR3b3JraW5nU3RhdHVzQ29kZS5JZGVudGlmeWluZztcbiAgY29ubmVjdGlvbk9wdGlvbnM6IENvbm5lY3Rpb25PcHRpb25zO1xuICB3czogVm9pY2VXZWJTb2NrZXQ7XG59XG5cbi8qKlxuICogVGhlIHN0YXRlIHRoYXQgYSBOZXR3b3JraW5nIGluc3RhbmNlIHdpbGwgYmUgaW4gd2hlbiBvcGVuaW5nIGEgVURQIGNvbm5lY3Rpb24gdG8gdGhlIElQIGFuZCBwb3J0IHByb3ZpZGVkXG4gKiBieSBEaXNjb3JkLCBhcyB3ZWxsIGFzIHBlcmZvcm1pbmcgSVAgZGlzY292ZXJ5LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE5ldHdvcmtpbmdVZHBIYW5kc2hha2luZ1N0YXRlIHtcbiAgY29kZTogTmV0d29ya2luZ1N0YXR1c0NvZGUuVWRwSGFuZHNoYWtpbmc7XG4gIGNvbm5lY3Rpb25EYXRhOiBQaWNrPENvbm5lY3Rpb25EYXRhLCAnc3NyYyc+O1xuICBjb25uZWN0aW9uT3B0aW9uczogQ29ubmVjdGlvbk9wdGlvbnM7XG4gIHVkcDogVm9pY2VVRFBTb2NrZXQ7XG4gIHdzOiBWb2ljZVdlYlNvY2tldDtcbn1cblxuLyoqXG4gKiBUaGUgc3RhdGUgdGhhdCBhIE5ldHdvcmtpbmcgaW5zdGFuY2Ugd2lsbCBiZSBpbiB3aGVuIHNlbGVjdGluZyBhbiBlbmNyeXB0aW9uIHByb3RvY29sIGZvciBhdWRpbyBwYWNrZXRzLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE5ldHdvcmtpbmdTZWxlY3RpbmdQcm90b2NvbFN0YXRlIHtcbiAgY29kZTogTmV0d29ya2luZ1N0YXR1c0NvZGUuU2VsZWN0aW5nUHJvdG9jb2w7XG4gIGNvbm5lY3Rpb25EYXRhOiBQaWNrPENvbm5lY3Rpb25EYXRhLCAnc3NyYyc+O1xuICBjb25uZWN0aW9uT3B0aW9uczogQ29ubmVjdGlvbk9wdGlvbnM7XG4gIHVkcDogVm9pY2VVRFBTb2NrZXQ7XG4gIHdzOiBWb2ljZVdlYlNvY2tldDtcbn1cblxuLyoqXG4gKiBUaGUgc3RhdGUgdGhhdCBhIE5ldHdvcmtpbmcgaW5zdGFuY2Ugd2lsbCBiZSBpbiB3aGVuIGl0IGhhcyBhIGZ1bGx5IGVzdGFibGlzaGVkIGNvbm5lY3Rpb24gdG8gYSBEaXNjb3JkXG4gKiB2b2ljZSBzZXJ2ZXIuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTmV0d29ya2luZ1JlYWR5U3RhdGUge1xuICBjb2RlOiBOZXR3b3JraW5nU3RhdHVzQ29kZS5SZWFkeTtcbiAgY29ubmVjdGlvbkRhdGE6IENvbm5lY3Rpb25EYXRhO1xuICBjb25uZWN0aW9uT3B0aW9uczogQ29ubmVjdGlvbk9wdGlvbnM7XG4gIHByZXBhcmVkUGFja2V0PzogQnVmZmVyIHwgdW5kZWZpbmVkO1xuICB1ZHA6IFZvaWNlVURQU29ja2V0O1xuICB3czogVm9pY2VXZWJTb2NrZXQ7XG59XG5cbi8qKlxuICogVGhlIHN0YXRlIHRoYXQgYSBOZXR3b3JraW5nIGluc3RhbmNlIHdpbGwgYmUgaW4gd2hlbiBpdHMgY29ubmVjdGlvbiBoYXMgYmVlbiBkcm9wcGVkIHVuZXhwZWN0ZWRseSwgYW5kIGl0XG4gKiBpcyBhdHRlbXB0aW5nIHRvIHJlc3VtZSBhbiBleGlzdGluZyBzZXNzaW9uLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE5ldHdvcmtpbmdSZXN1bWluZ1N0YXRlIHtcbiAgY29kZTogTmV0d29ya2luZ1N0YXR1c0NvZGUuUmVzdW1pbmc7XG4gIGNvbm5lY3Rpb25EYXRhOiBDb25uZWN0aW9uRGF0YTtcbiAgY29ubmVjdGlvbk9wdGlvbnM6IENvbm5lY3Rpb25PcHRpb25zO1xuICBwcmVwYXJlZFBhY2tldD86IEJ1ZmZlciB8IHVuZGVmaW5lZDtcbiAgdWRwOiBWb2ljZVVEUFNvY2tldDtcbiAgd3M6IFZvaWNlV2ViU29ja2V0O1xufVxuXG4vKipcbiAqIFRoZSBzdGF0ZSB0aGF0IGEgTmV0d29ya2luZyBpbnN0YW5jZSB3aWxsIGJlIGluIHdoZW4gaXQgaGFzIGJlZW4gZGVzdHJveWVkLiBJdCBjYW5ub3QgYmUgcmVjb3ZlcmVkIGZyb20gdGhpc1xuICogc3RhdGUuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTmV0d29ya2luZ0Nsb3NlZFN0YXRlIHtcbiAgY29kZTogTmV0d29ya2luZ1N0YXR1c0NvZGUuQ2xvc2VkO1xufVxuXG4vKipcbiAqIFRoZSB2YXJpb3VzIHN0YXRlcyB0aGF0IGEgbmV0d29ya2luZyBpbnN0YW5jZSBjYW4gYmUgaW4uXG4gKi9cbmV4cG9ydCB0eXBlIE5ldHdvcmtpbmdTdGF0ZSA9XG5OZXR3b3JraW5nQ2xvc2VkU3RhdGUgfFxuTmV0d29ya2luZ0lkZW50aWZ5aW5nU3RhdGUgfFxuTmV0d29ya2luZ09wZW5pbmdXc1N0YXRlIHxcbk5ldHdvcmtpbmdSZWFkeVN0YXRlIHxcbk5ldHdvcmtpbmdSZXN1bWluZ1N0YXRlIHxcbk5ldHdvcmtpbmdTZWxlY3RpbmdQcm90b2NvbFN0YXRlIHxcbk5ldHdvcmtpbmdVZHBIYW5kc2hha2luZ1N0YXRlO1xuXG4vKipcbiAqIERldGFpbHMgcmVxdWlyZWQgdG8gY29ubmVjdCB0byB0aGUgRGlzY29yZCB2b2ljZSBnYXRld2F5LiBUaGVzZSBkZXRhaWxzXG4gKiBhcmUgZmlyc3QgcmVjZWl2ZWQgb24gdGhlIG1haW4gYm90IGdhdGV3YXksIGluIHRoZSBmb3JtIG9mIFZPSUNFX1NFUlZFUl9VUERBVEVcbiAqIGFuZCBWT0lDRV9TVEFURV9VUERBVEUgcGFja2V0cy5cbiAqL1xuaW50ZXJmYWNlIENvbm5lY3Rpb25PcHRpb25zIHtcbiAgZW5kcG9pbnQ6IHN0cmluZztcbiAgc2VydmVySWQ6IHN0cmluZztcbiAgc2Vzc2lvbklkOiBzdHJpbmc7XG4gIHRva2VuOiBzdHJpbmc7XG4gIHVzZXJJZDogc3RyaW5nO1xufVxuXG4vKipcbiAqIEluZm9ybWF0aW9uIGFib3V0IHRoZSBjdXJyZW50IGNvbm5lY3Rpb24sIGUuZy4gd2hpY2ggZW5jcnlwdGlvbiBtb2RlIGlzIHRvIGJlIHVzZWQgb25cbiAqIHRoZSBjb25uZWN0aW9uLCB0aW1pbmcgaW5mb3JtYXRpb24gZm9yIHBsYXliYWNrIG9mIHN0cmVhbXMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ29ubmVjdGlvbkRhdGEge1xuICBlbmNyeXB0aW9uTW9kZTogc3RyaW5nO1xuICBub25jZTogbnVtYmVyO1xuICBub25jZUJ1ZmZlcjogQnVmZmVyO1xuICBwYWNrZXRzUGxheWVkOiBudW1iZXI7XG4gIHNlY3JldEtleTogVWludDhBcnJheTtcbiAgc2VxdWVuY2U6IG51bWJlcjtcbiAgc3BlYWtpbmc6IGJvb2xlYW47XG4gIHNzcmM6IG51bWJlcjtcbiAgdGltZXN0YW1wOiBudW1iZXI7XG59XG5cbi8qKlxuICogQW4gZW1wdHkgYnVmZmVyIHRoYXQgaXMgcmV1c2VkIGluIHBhY2tldCBlbmNyeXB0aW9uIGJ5IG1hbnkgZGlmZmVyZW50IG5ldHdvcmtpbmcgaW5zdGFuY2VzLlxuICovXG5jb25zdCBub25jZSA9IEJ1ZmZlci5hbGxvYygyNCk7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTmV0d29ya2luZyBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIC8qKlxuICAgKiBEZWJ1ZyBldmVudCBmb3IgTmV0d29ya2luZy5cbiAgICpcbiAgICogQGV2ZW50UHJvcGVydHlcbiAgICovXG4gIG9uKGV2ZW50OiAnZGVidWcnLCBsaXN0ZW5lcjogKG1lc3NhZ2U6IHN0cmluZykgPT4gdm9pZCk6IHRoaXM7XG4gIG9uKGV2ZW50OiAnZXJyb3InLCBsaXN0ZW5lcjogKGVycm9yOiBFcnJvcikgPT4gdm9pZCk6IHRoaXM7XG4gIG9uKGV2ZW50OiAnc3RhdGVDaGFuZ2UnLCBsaXN0ZW5lcjogKG9sZFN0YXRlOiBOZXR3b3JraW5nU3RhdGUsIG5ld1N0YXRlOiBOZXR3b3JraW5nU3RhdGUpID0+IHZvaWQpOiB0aGlzO1xuICBvbihldmVudDogJ2Nsb3NlJywgbGlzdGVuZXI6IChjb2RlOiBudW1iZXIpID0+IHZvaWQpOiB0aGlzO1xufVxuXG4vKipcbiAqIFN0cmluZ2lmaWVzIGEgTmV0d29ya2luZ1N0YXRlLlxuICpcbiAqIEBwYXJhbSBzdGF0ZSAtIFRoZSBzdGF0ZSB0byBzdHJpbmdpZnlcbiAqL1xuZnVuY3Rpb24gc3RyaW5naWZ5U3RhdGUoc3RhdGU6IE5ldHdvcmtpbmdTdGF0ZSkge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgIC4uLnN0YXRlLFxuICAgIHdzOiBSZWZsZWN0LmhhcyhzdGF0ZSwgJ3dzJyksXG4gICAgdWRwOiBSZWZsZWN0LmhhcyhzdGF0ZSwgJ3VkcCcpXG4gIH0pO1xufVxuXG4vKipcbiAqIENob29zZXMgYW4gZW5jcnlwdGlvbiBtb2RlIGZyb20gYSBsaXN0IG9mIGdpdmVuIG9wdGlvbnMuIENob29zZXMgdGhlIG1vc3QgcHJlZmVycmVkIG9wdGlvbi5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBhdmFpbGFibGUgZW5jcnlwdGlvbiBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGNob29zZUVuY3J5cHRpb25Nb2RlKG9wdGlvbnM6IHN0cmluZ1tdKTogc3RyaW5nIHtcbiAgY29uc3Qgb3B0aW9uID0gb3B0aW9ucy5maW5kKChvcHRpb24pID0+IFNVUFBPUlRFRF9FTkNSWVBUSU9OX01PREVTLmluY2x1ZGVzKG9wdGlvbikpO1xuICBpZiAoIW9wdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihgTm8gY29tcGF0aWJsZSBlbmNyeXB0aW9uIG1vZGVzLiBBdmFpbGFibGUgaW5jbHVkZTogJHtvcHRpb25zLmpvaW4oJywgJyl9YCk7XG4gIH1cblxuICByZXR1cm4gb3B0aW9uO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSByYW5kb20gbnVtYmVyIHRoYXQgaXMgaW4gdGhlIHJhbmdlIG9mIG4gYml0cy5cbiAqXG4gKiBAcGFyYW0gbnVtYmVyT2ZCaXRzIC0gVGhlIG51bWJlciBvZiBiaXRzXG4gKi9cbmZ1bmN0aW9uIHJhbmRvbU5CaXQobnVtYmVyT2ZCaXRzOiBudW1iZXIpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDIgKiogbnVtYmVyT2ZCaXRzKTtcbn1cblxuLyoqXG4gKiBNYW5hZ2VzIHRoZSBuZXR3b3JraW5nIHJlcXVpcmVkIHRvIG1haW50YWluIGEgdm9pY2UgY29ubmVjdGlvbiBhbmQgZGlzcGF0Y2ggYXVkaW8gcGFja2V0c1xuICovXG5leHBvcnQgY2xhc3MgTmV0d29ya2luZyBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIHByaXZhdGUgX3N0YXRlOiBOZXR3b3JraW5nU3RhdGU7XG5cbiAgLyoqXG4gICAqIFRoZSBkZWJ1ZyBsb2dnZXIgZnVuY3Rpb24sIGlmIGRlYnVnZ2luZyBpcyBlbmFibGVkLlxuICAgKi9cbiAgcHJpdmF0ZSByZWFkb25seSBkZWJ1ZzogKChtZXNzYWdlOiBzdHJpbmcpID0+IHZvaWQpIHwgbnVsbDtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBOZXR3b3JraW5nIGluc3RhbmNlLlxuICAgKi9cbiAgcHVibGljIGNvbnN0cnVjdG9yKG9wdGlvbnM6IENvbm5lY3Rpb25PcHRpb25zLCBkZWJ1ZzogYm9vbGVhbikge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLm9uV3NPcGVuID0gdGhpcy5vbldzT3Blbi5iaW5kKHRoaXMpO1xuICAgIHRoaXMub25DaGlsZEVycm9yID0gdGhpcy5vbkNoaWxkRXJyb3IuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9uV3NQYWNrZXQgPSB0aGlzLm9uV3NQYWNrZXQuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9uV3NDbG9zZSA9IHRoaXMub25Xc0Nsb3NlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vbldzRGVidWcgPSB0aGlzLm9uV3NEZWJ1Zy5iaW5kKHRoaXMpO1xuICAgIHRoaXMub25VZHBEZWJ1ZyA9IHRoaXMub25VZHBEZWJ1Zy5iaW5kKHRoaXMpO1xuICAgIHRoaXMub25VZHBDbG9zZSA9IHRoaXMub25VZHBDbG9zZS5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5kZWJ1ZyA9IGRlYnVnID8gKG1lc3NhZ2U6IHN0cmluZykgPT4gdGhpcy5lbWl0KCdkZWJ1ZycsIG1lc3NhZ2UpIDogbnVsbDtcblxuICAgIHRoaXMuX3N0YXRlID0ge1xuICAgICAgY29kZTogTmV0d29ya2luZ1N0YXR1c0NvZGUuT3BlbmluZ1dzLFxuICAgICAgd3M6IHRoaXMuY3JlYXRlV2ViU29ja2V0KG9wdGlvbnMuZW5kcG9pbnQpLFxuICAgICAgY29ubmVjdGlvbk9wdGlvbnM6IG9wdGlvbnNcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlc3Ryb3lzIHRoZSBOZXR3b3JraW5nIGluc3RhbmNlLCB0cmFuc2l0aW9uaW5nIGl0IGludG8gdGhlIENsb3NlZCBzdGF0ZS5cbiAgICovXG4gIHB1YmxpYyBkZXN0cm95KCkge1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBjb2RlOiBOZXR3b3JraW5nU3RhdHVzQ29kZS5DbG9zZWRcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBuZXR3b3JraW5nIGluc3RhbmNlLlxuICAgKi9cbiAgcHVibGljIGdldCBzdGF0ZSgpOiBOZXR3b3JraW5nU3RhdGUge1xuICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGEgbmV3IHN0YXRlIGZvciB0aGUgbmV0d29ya2luZyBpbnN0YW5jZSwgcGVyZm9ybWluZyBjbGVhbi11cCBvcGVyYXRpb25zIHdoZXJlIG5lY2Vzc2FyeS5cbiAgICovXG4gIHB1YmxpYyBzZXQgc3RhdGUobmV3U3RhdGU6IE5ldHdvcmtpbmdTdGF0ZSkge1xuICAgIGNvbnN0IG9sZFdzID0gUmVmbGVjdC5nZXQodGhpcy5fc3RhdGUsICd3cycpIGFzIFZvaWNlV2ViU29ja2V0IHwgdW5kZWZpbmVkO1xuICAgIGNvbnN0IG5ld1dzID0gUmVmbGVjdC5nZXQobmV3U3RhdGUsICd3cycpIGFzIFZvaWNlV2ViU29ja2V0IHwgdW5kZWZpbmVkO1xuICAgIGlmIChvbGRXcyAmJiBvbGRXcyAhPT0gbmV3V3MpIHtcbiAgICAgIC8vIFRoZSBvbGQgV2ViU29ja2V0IGlzIGJlaW5nIGZyZWVkIC0gcmVtb3ZlIGFsbCBoYW5kbGVycyBmcm9tIGl0XG4gICAgICBvbGRXcy5vZmYoJ2RlYnVnJywgdGhpcy5vbldzRGVidWcpO1xuICAgICAgb2xkV3Mub24oJ2Vycm9yJywgbm9vcCk7XG4gICAgICBvbGRXcy5vZmYoJ2Vycm9yJywgdGhpcy5vbkNoaWxkRXJyb3IpO1xuICAgICAgb2xkV3Mub2ZmKCdvcGVuJywgdGhpcy5vbldzT3Blbik7XG4gICAgICBvbGRXcy5vZmYoJ3BhY2tldCcsIHRoaXMub25Xc1BhY2tldCk7XG4gICAgICBvbGRXcy5vZmYoJ2Nsb3NlJywgdGhpcy5vbldzQ2xvc2UpO1xuICAgICAgb2xkV3MuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIGNvbnN0IG9sZFVkcCA9IFJlZmxlY3QuZ2V0KHRoaXMuX3N0YXRlLCAndWRwJykgYXMgVm9pY2VVRFBTb2NrZXQgfCB1bmRlZmluZWQ7XG4gICAgY29uc3QgbmV3VWRwID0gUmVmbGVjdC5nZXQobmV3U3RhdGUsICd1ZHAnKSBhcyBWb2ljZVVEUFNvY2tldCB8IHVuZGVmaW5lZDtcblxuICAgIGlmIChvbGRVZHAgJiYgb2xkVWRwICE9PSBuZXdVZHApIHtcbiAgICAgIG9sZFVkcC5vbignZXJyb3InLCBub29wKTtcbiAgICAgIG9sZFVkcC5vZmYoJ2Vycm9yJywgdGhpcy5vbkNoaWxkRXJyb3IpO1xuICAgICAgb2xkVWRwLm9mZignY2xvc2UnLCB0aGlzLm9uVWRwQ2xvc2UpO1xuICAgICAgb2xkVWRwLm9mZignZGVidWcnLCB0aGlzLm9uVWRwRGVidWcpO1xuICAgICAgb2xkVWRwLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICBjb25zdCBvbGRTdGF0ZSA9IHRoaXMuX3N0YXRlO1xuICAgIHRoaXMuX3N0YXRlID0gbmV3U3RhdGU7XG4gICAgdGhpcy5lbWl0KCdzdGF0ZUNoYW5nZScsIG9sZFN0YXRlLCBuZXdTdGF0ZSk7XG5cbiAgICB0aGlzLmRlYnVnPy4oYHN0YXRlIGNoYW5nZTpcXG5mcm9tICR7c3RyaW5naWZ5U3RhdGUob2xkU3RhdGUpfVxcbnRvICR7c3RyaW5naWZ5U3RhdGUobmV3U3RhdGUpfWApO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgV2ViU29ja2V0IHRvIGEgRGlzY29yZCBWb2ljZSBnYXRld2F5LlxuICAgKlxuICAgKiBAcGFyYW0gZW5kcG9pbnQgLSBUaGUgZW5kcG9pbnQgdG8gY29ubmVjdCB0b1xuICAgKi9cbiAgcHJpdmF0ZSBjcmVhdGVXZWJTb2NrZXQoZW5kcG9pbnQ6IHN0cmluZykge1xuICAgIGNvbnN0IHdzID0gbmV3IFZvaWNlV2ViU29ja2V0KGB3c3M6Ly8ke2VuZHBvaW50fT92PTRgLCBCb29sZWFuKHRoaXMuZGVidWcpKTtcblxuICAgIHdzLm9uKCdlcnJvcicsIHRoaXMub25DaGlsZEVycm9yKTtcbiAgICB3cy5vbmNlKCdvcGVuJywgdGhpcy5vbldzT3Blbik7XG4gICAgd3Mub24oJ3BhY2tldCcsIHRoaXMub25Xc1BhY2tldCk7XG4gICAgd3Mub25jZSgnY2xvc2UnLCB0aGlzLm9uV3NDbG9zZSk7XG4gICAgd3Mub24oJ2RlYnVnJywgdGhpcy5vbldzRGVidWcpO1xuXG4gICAgcmV0dXJuIHdzO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb3BhZ2F0ZXMgZXJyb3JzIGZyb20gdGhlIGNoaWxkcmVuIFZvaWNlV2ViU29ja2V0IGFuZCBWb2ljZVVEUFNvY2tldC5cbiAgICpcbiAgICogQHBhcmFtIGVycm9yIC0gVGhlIGVycm9yIHRoYXQgd2FzIGVtaXR0ZWQgYnkgYSBjaGlsZFxuICAgKi9cbiAgcHJpdmF0ZSBvbkNoaWxkRXJyb3IoZXJyb3I6IEVycm9yKSB7XG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiB0aGUgV2ViU29ja2V0IG9wZW5zLiBEZXBlbmRpbmcgb24gdGhlIHN0YXRlIHRoYXQgdGhlIGluc3RhbmNlIGlzIGluLFxuICAgKiBpdCB3aWxsIGVpdGhlciBpZGVudGlmeSB3aXRoIGEgbmV3IHNlc3Npb24sIG9yIGl0IHdpbGwgYXR0ZW1wdCB0byByZXN1bWUgYW4gZXhpc3Rpbmcgc2Vzc2lvbi5cbiAgICovXG4gIHByaXZhdGUgb25Xc09wZW4oKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUuY29kZSA9PT0gTmV0d29ya2luZ1N0YXR1c0NvZGUuT3BlbmluZ1dzKSB7XG4gICAgICBjb25zdCBwYWNrZXQgPSB7XG4gICAgICAgIG9wOiBWb2ljZU9wY29kZXMuSWRlbnRpZnksXG4gICAgICAgIGQ6IHtcbiAgICAgICAgICBzZXJ2ZXJfaWQ6IHRoaXMuc3RhdGUuY29ubmVjdGlvbk9wdGlvbnMuc2VydmVySWQsXG4gICAgICAgICAgdXNlcl9pZDogdGhpcy5zdGF0ZS5jb25uZWN0aW9uT3B0aW9ucy51c2VySWQsXG4gICAgICAgICAgc2Vzc2lvbl9pZDogdGhpcy5zdGF0ZS5jb25uZWN0aW9uT3B0aW9ucy5zZXNzaW9uSWQsXG4gICAgICAgICAgdG9rZW46IHRoaXMuc3RhdGUuY29ubmVjdGlvbk9wdGlvbnMudG9rZW5cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHRoaXMuc3RhdGUud3Muc2VuZFBhY2tldChwYWNrZXQpO1xuICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgLi4udGhpcy5zdGF0ZSxcbiAgICAgICAgY29kZTogTmV0d29ya2luZ1N0YXR1c0NvZGUuSWRlbnRpZnlpbmdcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlLmNvZGUgPT09IE5ldHdvcmtpbmdTdGF0dXNDb2RlLlJlc3VtaW5nKSB7XG4gICAgICBjb25zdCBwYWNrZXQgPSB7XG4gICAgICAgIG9wOiBWb2ljZU9wY29kZXMuUmVzdW1lLFxuICAgICAgICBkOiB7XG4gICAgICAgICAgc2VydmVyX2lkOiB0aGlzLnN0YXRlLmNvbm5lY3Rpb25PcHRpb25zLnNlcnZlcklkLFxuICAgICAgICAgIHNlc3Npb25faWQ6IHRoaXMuc3RhdGUuY29ubmVjdGlvbk9wdGlvbnMuc2Vzc2lvbklkLFxuICAgICAgICAgIHRva2VuOiB0aGlzLnN0YXRlLmNvbm5lY3Rpb25PcHRpb25zLnRva2VuXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0aGlzLnN0YXRlLndzLnNlbmRQYWNrZXQocGFja2V0KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gdGhlIFdlYlNvY2tldCBjbG9zZXMuIEJhc2VkIG9uIHRoZSByZWFzb24gZm9yIGNsb3NpbmcgKGdpdmVuIGJ5IHRoZSBjb2RlIHBhcmFtZXRlciksXG4gICAqIHRoZSBpbnN0YW5jZSB3aWxsIGVpdGhlciBhdHRlbXB0IHRvIHJlc3VtZSwgb3IgZW50ZXIgdGhlIGNsb3NlZCBzdGF0ZSBhbmQgZW1pdCBhICdjbG9zZScgZXZlbnRcbiAgICogd2l0aCB0aGUgY2xvc2UgY29kZSwgYWxsb3dpbmcgdGhlIHVzZXIgdG8gZGVjaWRlIHdoZXRoZXIgb3Igbm90IHRoZXkgd291bGQgbGlrZSB0byByZWNvbm5lY3QuXG4gICAqXG4gICAqIEBwYXJhbSBjb2RlIC0gVGhlIGNsb3NlIGNvZGVcbiAgICovXG4gIHByaXZhdGUgb25Xc0Nsb3NlKHsgY29kZSB9OiBDbG9zZUV2ZW50KSB7XG4gICAgY29uc3QgY2FuUmVzdW1lID0gY29kZSA9PT0gNF8wMTUgfHwgY29kZSA8IDRfMDAwO1xuICAgIGlmIChjYW5SZXN1bWUgJiYgdGhpcy5zdGF0ZS5jb2RlID09PSBOZXR3b3JraW5nU3RhdHVzQ29kZS5SZWFkeSkge1xuICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgLi4udGhpcy5zdGF0ZSxcbiAgICAgICAgY29kZTogTmV0d29ya2luZ1N0YXR1c0NvZGUuUmVzdW1pbmcsXG4gICAgICAgIHdzOiB0aGlzLmNyZWF0ZVdlYlNvY2tldCh0aGlzLnN0YXRlLmNvbm5lY3Rpb25PcHRpb25zLmVuZHBvaW50KVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc3RhdGUuY29kZSAhPT0gTmV0d29ya2luZ1N0YXR1c0NvZGUuQ2xvc2VkKSB7XG4gICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuZW1pdCgnY2xvc2UnLCBjb2RlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gdGhlIFVEUCBzb2NrZXQgaGFzIGNsb3NlZCBpdHNlbGYgaWYgaXQgaGFzIHN0b3BwZWQgcmVjZWl2aW5nIHJlcGxpZXMgZnJvbSBEaXNjb3JkLlxuICAgKi9cbiAgcHJpdmF0ZSBvblVkcENsb3NlKCkge1xuICAgIGlmICh0aGlzLnN0YXRlLmNvZGUgPT09IE5ldHdvcmtpbmdTdGF0dXNDb2RlLlJlYWR5KSB7XG4gICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAuLi50aGlzLnN0YXRlLFxuICAgICAgICBjb2RlOiBOZXR3b3JraW5nU3RhdHVzQ29kZS5SZXN1bWluZyxcbiAgICAgICAgd3M6IHRoaXMuY3JlYXRlV2ViU29ja2V0KHRoaXMuc3RhdGUuY29ubmVjdGlvbk9wdGlvbnMuZW5kcG9pbnQpXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBhIHBhY2tldCBpcyByZWNlaXZlZCBvbiB0aGUgY29ubmVjdGlvbidzIFdlYlNvY2tldC5cbiAgICpcbiAgICogQHBhcmFtIHBhY2tldCAtIFRoZSByZWNlaXZlZCBwYWNrZXRcbiAgICovXG4gIHByaXZhdGUgb25Xc1BhY2tldChwYWNrZXQ6IHVuc2FmZSkge1xuICAgIGlmIChwYWNrZXQub3AgPT09IFZvaWNlT3Bjb2Rlcy5IZWxsbyAmJiB0aGlzLnN0YXRlLmNvZGUgIT09IE5ldHdvcmtpbmdTdGF0dXNDb2RlLkNsb3NlZCkge1xuICAgICAgdGhpcy5zdGF0ZS53cy5zZXRIZWFydGJlYXRJbnRlcnZhbChwYWNrZXQuZC5oZWFydGJlYXRfaW50ZXJ2YWwpO1xuICAgIH0gZWxzZSBpZiAocGFja2V0Lm9wID09PSBWb2ljZU9wY29kZXMuUmVhZHkgJiYgdGhpcy5zdGF0ZS5jb2RlID09PSBOZXR3b3JraW5nU3RhdHVzQ29kZS5JZGVudGlmeWluZykge1xuICAgICAgY29uc3QgeyBpcCwgcG9ydCwgc3NyYywgbW9kZXMgfSA9IHBhY2tldC5kO1xuXG4gICAgICBjb25zdCB1ZHAgPSBuZXcgVm9pY2VVRFBTb2NrZXQoeyBpcCwgcG9ydCB9KTtcbiAgICAgIHVkcC5vbignZXJyb3InLCB0aGlzLm9uQ2hpbGRFcnJvcik7XG4gICAgICB1ZHAub24oJ2RlYnVnJywgdGhpcy5vblVkcERlYnVnKTtcbiAgICAgIHVkcC5vbmNlKCdjbG9zZScsIHRoaXMub25VZHBDbG9zZSk7XG4gICAgICB1ZHAuXG4gICAgICBwZXJmb3JtSVBEaXNjb3Zlcnkoc3NyYykuXG4gICAgICB0aGVuKChsb2NhbENvbmZpZykgPT4ge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5jb2RlICE9PSBOZXR3b3JraW5nU3RhdHVzQ29kZS5VZHBIYW5kc2hha2luZykgcmV0dXJuO1xuICAgICAgICB0aGlzLnN0YXRlLndzLnNlbmRQYWNrZXQoe1xuICAgICAgICAgIG9wOiBWb2ljZU9wY29kZXMuU2VsZWN0UHJvdG9jb2wsXG4gICAgICAgICAgZDoge1xuICAgICAgICAgICAgcHJvdG9jb2w6ICd1ZHAnLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICBhZGRyZXNzOiBsb2NhbENvbmZpZy5pcCxcbiAgICAgICAgICAgICAgcG9ydDogbG9jYWxDb25maWcucG9ydCxcbiAgICAgICAgICAgICAgbW9kZTogY2hvb3NlRW5jcnlwdGlvbk1vZGUobW9kZXMpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAuLi50aGlzLnN0YXRlLFxuICAgICAgICAgIGNvZGU6IE5ldHdvcmtpbmdTdGF0dXNDb2RlLlNlbGVjdGluZ1Byb3RvY29sXG4gICAgICAgIH07XG4gICAgICB9KS5cbiAgICAgIGNhdGNoKChlcnJvcjogRXJyb3IpID0+IHRoaXMuZW1pdCgnZXJyb3InLCBlcnJvcikpO1xuXG4gICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAuLi50aGlzLnN0YXRlLFxuICAgICAgICBjb2RlOiBOZXR3b3JraW5nU3RhdHVzQ29kZS5VZHBIYW5kc2hha2luZyxcbiAgICAgICAgdWRwLFxuICAgICAgICBjb25uZWN0aW9uRGF0YToge1xuICAgICAgICAgIHNzcmNcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKFxuICAgIHBhY2tldC5vcCA9PT0gVm9pY2VPcGNvZGVzLlNlc3Npb25EZXNjcmlwdGlvbiAmJlxuICAgIHRoaXMuc3RhdGUuY29kZSA9PT0gTmV0d29ya2luZ1N0YXR1c0NvZGUuU2VsZWN0aW5nUHJvdG9jb2wpXG4gICAge1xuICAgICAgY29uc3QgeyBtb2RlOiBlbmNyeXB0aW9uTW9kZSwgc2VjcmV0X2tleTogc2VjcmV0S2V5IH0gPSBwYWNrZXQuZDtcbiAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgIC4uLnRoaXMuc3RhdGUsXG4gICAgICAgIGNvZGU6IE5ldHdvcmtpbmdTdGF0dXNDb2RlLlJlYWR5LFxuICAgICAgICBjb25uZWN0aW9uRGF0YToge1xuICAgICAgICAgIC4uLnRoaXMuc3RhdGUuY29ubmVjdGlvbkRhdGEsXG4gICAgICAgICAgZW5jcnlwdGlvbk1vZGUsXG4gICAgICAgICAgc2VjcmV0S2V5OiBuZXcgVWludDhBcnJheShzZWNyZXRLZXkpLFxuICAgICAgICAgIHNlcXVlbmNlOiByYW5kb21OQml0KDE2KSxcbiAgICAgICAgICB0aW1lc3RhbXA6IHJhbmRvbU5CaXQoMzIpLFxuICAgICAgICAgIG5vbmNlOiAwLFxuICAgICAgICAgIG5vbmNlQnVmZmVyOiBlbmNyeXB0aW9uTW9kZSA9PT0gJ2FlYWRfYWVzMjU2X2djbV9ydHBzaXplJyA/IEJ1ZmZlci5hbGxvYygxMikgOiBCdWZmZXIuYWxsb2MoMjQpLFxuICAgICAgICAgIHNwZWFraW5nOiBmYWxzZSxcbiAgICAgICAgICBwYWNrZXRzUGxheWVkOiAwXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChwYWNrZXQub3AgPT09IFZvaWNlT3Bjb2Rlcy5SZXN1bWVkICYmIHRoaXMuc3RhdGUuY29kZSA9PT0gTmV0d29ya2luZ1N0YXR1c0NvZGUuUmVzdW1pbmcpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgIC4uLnRoaXMuc3RhdGUsXG4gICAgICAgIGNvZGU6IE5ldHdvcmtpbmdTdGF0dXNDb2RlLlJlYWR5XG4gICAgICB9O1xuICAgICAgdGhpcy5zdGF0ZS5jb25uZWN0aW9uRGF0YS5zcGVha2luZyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9wYWdhdGVzIGRlYnVnIG1lc3NhZ2VzIGZyb20gdGhlIGNoaWxkIFdlYlNvY2tldC5cbiAgICpcbiAgICogQHBhcmFtIG1lc3NhZ2UgLSBUaGUgZW1pdHRlZCBkZWJ1ZyBtZXNzYWdlXG4gICAqL1xuICBwcml2YXRlIG9uV3NEZWJ1ZyhtZXNzYWdlOiBzdHJpbmcpIHtcbiAgICB0aGlzLmRlYnVnPy4oYFtXU10gJHttZXNzYWdlfWApO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb3BhZ2F0ZXMgZGVidWcgbWVzc2FnZXMgZnJvbSB0aGUgY2hpbGQgVURQU29ja2V0LlxuICAgKlxuICAgKiBAcGFyYW0gbWVzc2FnZSAtIFRoZSBlbWl0dGVkIGRlYnVnIG1lc3NhZ2VcbiAgICovXG4gIHByaXZhdGUgb25VZHBEZWJ1ZyhtZXNzYWdlOiBzdHJpbmcpIHtcbiAgICB0aGlzLmRlYnVnPy4oYFtVRFBdICR7bWVzc2FnZX1gKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmVwYXJlcyBhbiBPcHVzIHBhY2tldCBmb3IgcGxheWJhY2suIFRoaXMgaW5jbHVkZXMgYXR0YWNoaW5nIG1ldGFkYXRhIHRvIGl0IGFuZCBlbmNyeXB0aW5nIGl0LlxuICAgKiBJdCB3aWxsIGJlIHN0b3JlZCB3aXRoaW4gdGhlIGluc3RhbmNlLCBhbmQgY2FuIGJlIHBsYXllZCBieSBkaXNwYXRjaEF1ZGlvKClcbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogQ2FsbGluZyB0aGlzIG1ldGhvZCB3aGlsZSB0aGVyZSBpcyBhbHJlYWR5IGEgcHJlcGFyZWQgYXVkaW8gcGFja2V0IHRoYXQgaGFzIG5vdCB5ZXQgYmVlbiBkaXNwYXRjaGVkXG4gICAqIHdpbGwgb3ZlcndyaXRlIHRoZSBleGlzdGluZyBhdWRpbyBwYWNrZXQuIFRoaXMgc2hvdWxkIGJlIGF2b2lkZWQuXG4gICAqIEBwYXJhbSBvcHVzUGFja2V0IC0gVGhlIE9wdXMgcGFja2V0IHRvIGVuY3J5cHRcbiAgICogQHJldHVybnMgVGhlIGF1ZGlvIHBhY2tldCB0aGF0IHdhcyBwcmVwYXJlZFxuICAgKi9cbiAgcHVibGljIHByZXBhcmVBdWRpb1BhY2tldChvcHVzUGFja2V0OiBCdWZmZXIpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKHN0YXRlLmNvZGUgIT09IE5ldHdvcmtpbmdTdGF0dXNDb2RlLlJlYWR5KSByZXR1cm47XG4gICAgc3RhdGUucHJlcGFyZWRQYWNrZXQgPSB0aGlzLmNyZWF0ZUF1ZGlvUGFja2V0KG9wdXNQYWNrZXQsIHN0YXRlLmNvbm5lY3Rpb25EYXRhKTtcbiAgICByZXR1cm4gc3RhdGUucHJlcGFyZWRQYWNrZXQ7XG4gIH1cblxuICAvKipcbiAgICogRGlzcGF0Y2hlcyB0aGUgYXVkaW8gcGFja2V0IHByZXZpb3VzbHkgcHJlcGFyZWQgYnkgcHJlcGFyZUF1ZGlvUGFja2V0KG9wdXNQYWNrZXQpLiBUaGUgYXVkaW8gcGFja2V0XG4gICAqIGlzIGNvbnN1bWVkIGFuZCBjYW5ub3QgYmUgZGlzcGF0Y2hlZCBhZ2Fpbi5cbiAgICovXG4gIHB1YmxpYyBkaXNwYXRjaEF1ZGlvKCkge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAoc3RhdGUuY29kZSAhPT0gTmV0d29ya2luZ1N0YXR1c0NvZGUuUmVhZHkpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoc3RhdGUucHJlcGFyZWRQYWNrZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5wbGF5QXVkaW9QYWNrZXQoc3RhdGUucHJlcGFyZWRQYWNrZXQpO1xuICAgICAgc3RhdGUucHJlcGFyZWRQYWNrZXQgPSB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUGxheXMgYW4gYXVkaW8gcGFja2V0LCB1cGRhdGluZyB0aW1pbmcgbWV0YWRhdGEgdXNlZCBmb3IgcGxheWJhY2suXG4gICAqXG4gICAqIEBwYXJhbSBhdWRpb1BhY2tldCAtIFRoZSBhdWRpbyBwYWNrZXQgdG8gcGxheVxuICAgKi9cbiAgcHJpdmF0ZSBwbGF5QXVkaW9QYWNrZXQoYXVkaW9QYWNrZXQ6IEJ1ZmZlcikge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAoc3RhdGUuY29kZSAhPT0gTmV0d29ya2luZ1N0YXR1c0NvZGUuUmVhZHkpIHJldHVybjtcbiAgICBjb25zdCB7IGNvbm5lY3Rpb25EYXRhIH0gPSBzdGF0ZTtcbiAgICBjb25uZWN0aW9uRGF0YS5wYWNrZXRzUGxheWVkKys7XG4gICAgY29ubmVjdGlvbkRhdGEuc2VxdWVuY2UrKztcbiAgICBjb25uZWN0aW9uRGF0YS50aW1lc3RhbXAgKz0gVElNRVNUQU1QX0lOQztcbiAgICBpZiAoY29ubmVjdGlvbkRhdGEuc2VxdWVuY2UgPj0gMiAqKiAxNikgY29ubmVjdGlvbkRhdGEuc2VxdWVuY2UgPSAwO1xuICAgIGlmIChjb25uZWN0aW9uRGF0YS50aW1lc3RhbXAgPj0gMiAqKiAzMikgY29ubmVjdGlvbkRhdGEudGltZXN0YW1wID0gMDtcbiAgICB0aGlzLnNldFNwZWFraW5nKHRydWUpO1xuICAgIHN0YXRlLnVkcC5zZW5kKGF1ZGlvUGFja2V0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIHBhY2tldCB0byB0aGUgdm9pY2UgZ2F0ZXdheSBpbmRpY2F0aW5nIHRoYXQgdGhlIGNsaWVudCBoYXMgc3RhcnQvc3RvcHBlZCBzZW5kaW5nXG4gICAqIGF1ZGlvLlxuICAgKlxuICAgKiBAcGFyYW0gc3BlYWtpbmcgLSBXaGV0aGVyIG9yIG5vdCB0aGUgY2xpZW50IHNob3VsZCBiZSBzaG93biBhcyBzcGVha2luZ1xuICAgKi9cbiAgcHVibGljIHNldFNwZWFraW5nKHNwZWFraW5nOiBib29sZWFuKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIGlmIChzdGF0ZS5jb2RlICE9PSBOZXR3b3JraW5nU3RhdHVzQ29kZS5SZWFkeSkgcmV0dXJuO1xuICAgIGlmIChzdGF0ZS5jb25uZWN0aW9uRGF0YS5zcGVha2luZyA9PT0gc3BlYWtpbmcpIHJldHVybjtcbiAgICBzdGF0ZS5jb25uZWN0aW9uRGF0YS5zcGVha2luZyA9IHNwZWFraW5nO1xuICAgIHN0YXRlLndzLnNlbmRQYWNrZXQoe1xuICAgICAgb3A6IFZvaWNlT3Bjb2Rlcy5TcGVha2luZyxcbiAgICAgIGQ6IHtcbiAgICAgICAgc3BlYWtpbmc6IHNwZWFraW5nID8gMSA6IDAsXG4gICAgICAgIGRlbGF5OiAwLFxuICAgICAgICBzc3JjOiBzdGF0ZS5jb25uZWN0aW9uRGF0YS5zc3JjXG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBhdWRpbyBwYWNrZXQgZnJvbSBhbiBPcHVzIHBhY2tldC4gVGhpcyBpbnZvbHZlcyBlbmNyeXB0aW5nIHRoZSBwYWNrZXQsXG4gICAqIHRoZW4gcHJlcGVuZGluZyBhIGhlYWRlciB0aGF0IGluY2x1ZGVzIG1ldGFkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0gb3B1c1BhY2tldCAtIFRoZSBPcHVzIHBhY2tldCB0byBwcmVwYXJlXG4gICAqIEBwYXJhbSBjb25uZWN0aW9uRGF0YSAtIFRoZSBjdXJyZW50IGNvbm5lY3Rpb24gZGF0YSBvZiB0aGUgaW5zdGFuY2VcbiAgICovXG4gIHByaXZhdGUgY3JlYXRlQXVkaW9QYWNrZXQob3B1c1BhY2tldDogQnVmZmVyLCBjb25uZWN0aW9uRGF0YTogQ29ubmVjdGlvbkRhdGEpIHtcbiAgICBjb25zdCBwYWNrZXRCdWZmZXIgPSBCdWZmZXIuYWxsb2MoMTIpO1xuICAgIHBhY2tldEJ1ZmZlclswXSA9IDB4ODA7XG4gICAgcGFja2V0QnVmZmVyWzFdID0gMHg3ODtcblxuICAgIGNvbnN0IHsgc2VxdWVuY2UsIHRpbWVzdGFtcCwgc3NyYyB9ID0gY29ubmVjdGlvbkRhdGE7XG5cbiAgICBwYWNrZXRCdWZmZXIud3JpdGVVSW50QkUoc2VxdWVuY2UsIDIsIDIpO1xuICAgIHBhY2tldEJ1ZmZlci53cml0ZVVJbnRCRSh0aW1lc3RhbXAsIDQsIDQpO1xuICAgIHBhY2tldEJ1ZmZlci53cml0ZVVJbnRCRShzc3JjLCA4LCA0KTtcblxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBwYWNrZXRCdWZmZXIuY29weShub25jZSwgMCwgMCwgMTIpO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbcGFja2V0QnVmZmVyLCAuLi50aGlzLmVuY3J5cHRPcHVzUGFja2V0KG9wdXNQYWNrZXQsIGNvbm5lY3Rpb25EYXRhLCBwYWNrZXRCdWZmZXIpXSk7XG4gIH1cblxuICAvKipcbiAgICogRW5jcnlwdHMgYW4gT3B1cyBwYWNrZXQgdXNpbmcgdGhlIGZvcm1hdCBhZ3JlZWQgdXBvbiBieSB0aGUgaW5zdGFuY2UgYW5kIERpc2NvcmQuXG4gICAqXG4gICAqIEBwYXJhbSBvcHVzUGFja2V0IC0gVGhlIE9wdXMgcGFja2V0IHRvIGVuY3J5cHRcbiAgICogQHBhcmFtIGNvbm5lY3Rpb25EYXRhIC0gVGhlIGN1cnJlbnQgY29ubmVjdGlvbiBkYXRhIG9mIHRoZSBpbnN0YW5jZVxuICAgKi9cbiAgcHJpdmF0ZSBlbmNyeXB0T3B1c1BhY2tldChvcHVzUGFja2V0OiBCdWZmZXIsIGNvbm5lY3Rpb25EYXRhOiBDb25uZWN0aW9uRGF0YSwgZGF0YTogQnVmZmVyKSB7XG4gICAgY29uc3QgeyBzZWNyZXRLZXksIGVuY3J5cHRpb25Nb2RlIH0gPSBjb25uZWN0aW9uRGF0YTtcblxuICAgIC8vIEJvdGggc3VwcG9ydGVkIGVuY3J5cHRpb24gbWV0aG9kcyB3YW50IHRoZSBub25jZSB0byBiZSBhbiBpbmNyZW1lbnRhbCBpbnRlZ2VyXG4gICAgY29ubmVjdGlvbkRhdGEubm9uY2UrKztcbiAgICBpZiAoY29ubmVjdGlvbkRhdGEubm9uY2UgPiBNQVhfTk9OQ0VfU0laRSkgY29ubmVjdGlvbkRhdGEubm9uY2UgPSAwO1xuICAgIGNvbm5lY3Rpb25EYXRhLm5vbmNlQnVmZmVyLndyaXRlVUludDMyQkUoY29ubmVjdGlvbkRhdGEubm9uY2UsIDApO1xuXG4gICAgLy8gNCBleHRyYSBieXRlcyBvZiBwYWRkaW5nIG9uIHRoZSBlbmQgb2YgdGhlIGVuY3J5cHRlZCBwYWNrZXRcbiAgICBjb25zdCBub25jZVBhZGRpbmcgPSBjb25uZWN0aW9uRGF0YS5ub25jZUJ1ZmZlci5zdWJhcnJheSgwLCA0KTtcblxuICAgIGxldCBlbmNyeXB0ZWQ7XG4gICAgc3dpdGNoIChlbmNyeXB0aW9uTW9kZSkge1xuICAgICAgY2FzZSAnYWVhZF9hZXMyNTZfZ2NtX3J0cHNpemUnOntcbiAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgY29uc3QgY2lwaGVyID0gY3J5cHRvLmNyZWF0ZUNpcGhlcml2KCdhZXMtMjU2LWdjbScsIHNlY3JldEtleSwgY29ubmVjdGlvbkRhdGEubm9uY2VCdWZmZXIpO1xuICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICBjaXBoZXIuc2V0QUFEKGRhdGEpO1xuXG4gICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgIGVuY3J5cHRlZCA9IEJ1ZmZlci5jb25jYXQoW2NpcGhlci51cGRhdGUob3B1c1BhY2tldCksIGNpcGhlci5maW5hbCgpLCBjaXBoZXIuZ2V0QXV0aFRhZygpXSk7XG5cbiAgICAgICAgICByZXR1cm4gW2VuY3J5cHRlZCwgbm9uY2VQYWRkaW5nXTtcbiAgICAgICAgfVxuICAgICAgY2FzZSAnYWVhZF94Y2hhY2hhMjBfcG9seTEzMDVfcnRwc2l6ZSc6e1xuICAgICAgICAgIGVuY3J5cHRlZCA9IHNlY3JldGJveC5tZXRob2RzLmNyeXB0b19hZWFkX3hjaGFjaGEyMHBvbHkxMzA1X2lldGZfZW5jcnlwdChcbiAgICAgICAgICAgIG9wdXNQYWNrZXQsXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgY29ubmVjdGlvbkRhdGEubm9uY2VCdWZmZXIsXG4gICAgICAgICAgICBzZWNyZXRLZXlcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgcmV0dXJuIFtlbmNyeXB0ZWQsIG5vbmNlUGFkZGluZ107XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6e1xuICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbi4gT3VyIGVuY3J5cHRpb24gbW9kZSBpcyBjaG9zZW4gZnJvbSBhIGxpc3QgZ2l2ZW4gdG8gdXMgYnkgdGhlIGdhdGV3YXkgYW5kIGNoZWNrZWQgd2l0aCB0aGUgb25lcyB3ZSBzdXBwb3J0LlxuICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBVbnN1cHBvcnRlZCBlbmNyeXB0aW9uIG1ldGhvZDogJHtlbmNyeXB0aW9uTW9kZX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxufSIsICJpbXBvcnQgeyBCdWZmZXIgfSBmcm9tICdub2RlOmJ1ZmZlcic7XG5cbmludGVyZmFjZSBNZXRob2RzIHtcbiAgY3J5cHRvX2FlYWRfeGNoYWNoYTIwcG9seTEzMDVfaWV0Zl9lbmNyeXB0KFxuICBwbGFpbnRleHQ6IEJ1ZmZlcixcbiAgYWRkaXRpb25hbERhdGE6IEJ1ZmZlcixcbiAgbm9uY2U6IEJ1ZmZlcixcbiAga2V5OiBBcnJheUJ1ZmZlckxpa2UpXG4gIDogQnVmZmVyO1xufVxuXG5jb25zdCBsaWJzID0ge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAnc29kaXVtLW5hdGl2ZSc6IChzb2RpdW06IGFueSk6IE1ldGhvZHMgPT4gKHtcbiAgICBjcnlwdG9fYWVhZF94Y2hhY2hhMjBwb2x5MTMwNV9pZXRmX2VuY3J5cHQ6IChcbiAgICBwbGFpbnRleHQ6IEJ1ZmZlcixcbiAgICBhZGRpdGlvbmFsRGF0YTogQnVmZmVyLFxuICAgIG5vbmNlOiBCdWZmZXIsXG4gICAga2V5OiBBcnJheUJ1ZmZlckxpa2UpID0+XG4gICAge1xuICAgICAgY29uc3QgY2lwaGVyVGV4dCA9IEJ1ZmZlci5hbGxvYyhwbGFpbnRleHQubGVuZ3RoICsgc29kaXVtLmNyeXB0b19hZWFkX3hjaGFjaGEyMHBvbHkxMzA1X2lldGZfQUJZVEVTKTtcbiAgICAgIHNvZGl1bS5jcnlwdG9fYWVhZF94Y2hhY2hhMjBwb2x5MTMwNV9pZXRmX2VuY3J5cHQoY2lwaGVyVGV4dCwgcGxhaW50ZXh0LCBhZGRpdGlvbmFsRGF0YSwgbnVsbCwgbm9uY2UsIGtleSk7XG4gICAgICByZXR1cm4gY2lwaGVyVGV4dDtcbiAgICB9XG4gIH0pLFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICBzb2RpdW06IChzb2RpdW06IGFueSk6IE1ldGhvZHMgPT4gKHtcbiAgICBjcnlwdG9fYWVhZF94Y2hhY2hhMjBwb2x5MTMwNV9pZXRmX2VuY3J5cHQ6IChcbiAgICBwbGFpbnRleHQ6IEJ1ZmZlcixcbiAgICBhZGRpdGlvbmFsRGF0YTogQnVmZmVyLFxuICAgIG5vbmNlOiBCdWZmZXIsXG4gICAga2V5OiBBcnJheUJ1ZmZlckxpa2UpID0+XG4gICAge1xuICAgICAgcmV0dXJuIHNvZGl1bS5hcGkuY3J5cHRvX2FlYWRfeGNoYWNoYTIwcG9seTEzMDVfaWV0Zl9lbmNyeXB0KHBsYWludGV4dCwgYWRkaXRpb25hbERhdGEsIG51bGwsIG5vbmNlLCBrZXkpO1xuICAgIH1cbiAgfSksXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICdsaWJzb2RpdW0td3JhcHBlcnMnOiAoc29kaXVtOiBhbnkpOiBNZXRob2RzID0+ICh7XG4gICAgY3J5cHRvX2FlYWRfeGNoYWNoYTIwcG9seTEzMDVfaWV0Zl9lbmNyeXB0OiAoXG4gICAgcGxhaW50ZXh0OiBCdWZmZXIsXG4gICAgYWRkaXRpb25hbERhdGE6IEJ1ZmZlcixcbiAgICBub25jZTogQnVmZmVyLFxuICAgIGtleTogQXJyYXlCdWZmZXJMaWtlKSA9PlxuICAgIHtcbiAgICAgIHJldHVybiBzb2RpdW0uY3J5cHRvX2FlYWRfeGNoYWNoYTIwcG9seTEzMDVfaWV0Zl9lbmNyeXB0KHBsYWludGV4dCwgYWRkaXRpb25hbERhdGEsIG51bGwsIG5vbmNlLCBrZXkpO1xuICAgIH1cbiAgfSksXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICdAc3RhYmxlbGliL3hjaGFjaGEyMHBvbHkxMzA1JzogKHN0YWJsZWxpYjogYW55KTogTWV0aG9kcyA9PiAoe1xuICAgIGNyeXB0b19hZWFkX3hjaGFjaGEyMHBvbHkxMzA1X2lldGZfZW5jcnlwdChjaXBoZXJUZXh0LCBhZGRpdGlvbmFsRGF0YSwgbm9uY2UsIGtleSkge1xuICAgICAgY29uc3QgY3J5cHRvID0gbmV3IHN0YWJsZWxpYi5YQ2hhQ2hhMjBQb2x5MTMwNShrZXkpO1xuICAgICAgcmV0dXJuIGNyeXB0by5zZWFsKG5vbmNlLCBjaXBoZXJUZXh0LCBhZGRpdGlvbmFsRGF0YSk7XG4gICAgfVxuICB9KSxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgJ0Bub2JsZS9jaXBoZXJzL2NoYWNoYSc6IChub2JsZTogYW55KTogTWV0aG9kcyA9PiAoe1xuICAgIGNyeXB0b19hZWFkX3hjaGFjaGEyMHBvbHkxMzA1X2lldGZfZW5jcnlwdChwbGFpbnRleHQsIGFkZGl0aW9uYWxEYXRhLCBub25jZSwga2V5KSB7XG4gICAgICBjb25zdCBjaGFjaGEgPSBub2JsZS54Y2hhY2hhMjBwb2x5MTMwNShrZXksIG5vbmNlLCBhZGRpdGlvbmFsRGF0YSk7XG4gICAgICByZXR1cm4gY2hhY2hhLmVuY3J5cHQocGxhaW50ZXh0KTtcbiAgICB9XG4gIH0pXG59IGFzIGNvbnN0O1xuXG4vLyBAdHMtaWdub3JlXG5saWJzWydzb2RpdW0tamF2YXNjcmlwdCddID0gbGlic1snc29kaXVtLW5hdGl2ZSddO1xuXG5jb25zdCB2YWxpZExpYnMgPSBPYmplY3Qua2V5cyhsaWJzKTtcblxuY29uc3QgZmFsbGJhY2tFcnJvciA9ICgpID0+IHtcbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgIGBDYW5ub3QgcGxheSBhdWRpbyBhcyBubyB2YWxpZCBlbmNyeXB0aW9uIHBhY2thZ2UgaXMgaW5zdGFsbGVkLlxuLSBJbnN0YWxsIG9uZSBvZiB0aGUgZm9sbG93aW5nIHBhY2thZ2VzOiAke3ZhbGlkTGlicy5qb2luKCcsICcpfVxuLSBVc2UgdGhlIGdlbmVyYXRlRGVwZW5kZW5jeVJlcG9ydCgpIGZ1bmN0aW9uIGZvciBtb3JlIGluZm9ybWF0aW9uLlxcbmBcbiAgKTtcbn07XG5cbmNvbnN0IG1ldGhvZHM6IE1ldGhvZHMgPSB7XG4gIGNyeXB0b19hZWFkX3hjaGFjaGEyMHBvbHkxMzA1X2lldGZfZW5jcnlwdDogZmFsbGJhY2tFcnJvclxufTtcblxudm9pZCAoYXN5bmMgKCkgPT4ge1xuICBmb3IgKGNvbnN0IGxpYk5hbWUgb2YgT2JqZWN0LmtleXMobGlicykgYXMgKGtleW9mIHR5cGVvZiBsaWJzKVtdKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVxdWlyZS1pbXBvcnRzLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdmFyLXJlcXVpcmVzXG4gICAgICBjb25zdCBsaWIgPSBhd2FpdCBpbXBvcnQobGliTmFtZSk7XG4gICAgICBpZiAobGliTmFtZSA9PT0gJ2xpYnNvZGl1bS13cmFwcGVycycgJiYgbGliLnJlYWR5KSBhd2FpdCBsaWIucmVhZHk7XG4gICAgICBPYmplY3QuYXNzaWduKG1ldGhvZHMsIGxpYnNbbGliTmFtZV0obGliKSk7XG4gICAgICBicmVhaztcbiAgICB9IGNhdGNoIHtcblxuICAgICAgLy9cbiAgICB9fVxufSkoKTtcblxuZXhwb3J0IHsgbWV0aG9kcyB9OyIsICIvLyBDb3B5cmlnaHQgZGlzY29yZC1wbGF5ZXIgYXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC4gTUlUIExpY2Vuc2UuXG4vLyBDb3B5cmlnaHQgZGlzY29yZC5qcyBhdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLiBBcGFjaGUgTGljZW5zZSAyLjBcblxuZXhwb3J0IGNvbnN0IG5vb3AgPSAoKSA9PiB7fTsiLCAiLy8gQ29weXJpZ2h0IGRpc2NvcmQtcGxheWVyIGF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuIE1JVCBMaWNlbnNlLlxuLy8gQ29weXJpZ2h0IGRpc2NvcmQuanMgYXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC4gQXBhY2hlIExpY2Vuc2UgMi4wXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWRlY2xhcmF0aW9uLW1lcmdpbmcgKi9cblxuaW1wb3J0IHsgQnVmZmVyIH0gZnJvbSAnbm9kZTpidWZmZXInO1xuaW1wb3J0IHsgY3JlYXRlU29ja2V0LCB0eXBlIFNvY2tldCB9IGZyb20gJ25vZGU6ZGdyYW0nO1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnbm9kZTpldmVudHMnO1xuaW1wb3J0IHsgaXNJUHY0IH0gZnJvbSAnbm9kZTpuZXQnO1xuXG4vKipcbiAqIFN0b3JlcyBhbiBJUCBhZGRyZXNzIGFuZCBwb3J0LiBVc2VkIHRvIHN0b3JlIHNvY2tldCBkZXRhaWxzIGZvciB0aGUgbG9jYWwgY2xpZW50IGFzIHdlbGwgYXNcbiAqIGZvciBEaXNjb3JkLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFNvY2tldENvbmZpZyB7XG4gIGlwOiBzdHJpbmc7XG4gIHBvcnQ6IG51bWJlcjtcbn1cblxuLyoqXG4gKiBQYXJzZXMgdGhlIHJlc3BvbnNlIGZyb20gRGlzY29yZCB0byBhaWQgd2l0aCBsb2NhbCBJUCBkaXNjb3ZlcnkuXG4gKlxuICogQHBhcmFtIG1lc3NhZ2UgLSBUaGUgcmVjZWl2ZWQgbWVzc2FnZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VMb2NhbFBhY2tldChtZXNzYWdlOiBCdWZmZXIpOiBTb2NrZXRDb25maWcge1xuICBjb25zdCBwYWNrZXQgPSBCdWZmZXIuZnJvbShtZXNzYWdlKTtcblxuICBjb25zdCBpcCA9IHBhY2tldC5zbGljZSg4LCBwYWNrZXQuaW5kZXhPZigwLCA4KSkudG9TdHJpbmcoJ3V0ZjgnKTtcblxuICBpZiAoIWlzSVB2NChpcCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01hbGZvcm1lZCBJUCBhZGRyZXNzJyk7XG4gIH1cblxuICBjb25zdCBwb3J0ID0gcGFja2V0LnJlYWRVSW50MTZCRShwYWNrZXQubGVuZ3RoIC0gMik7XG5cbiAgcmV0dXJuIHsgaXAsIHBvcnQgfTtcbn1cblxuLyoqXG4gKiBUaGUgaW50ZXJ2YWwgaW4gbWlsbGlzZWNvbmRzIGF0IHdoaWNoIGtlZXAgYWxpdmUgZGF0YWdyYW1zIGFyZSBzZW50LlxuICovXG5jb25zdCBLRUVQX0FMSVZFX0lOVEVSVkFMID0gNWUzO1xuXG4vKipcbiAqIFRoZSBtYXhpbXVtIHZhbHVlIG9mIHRoZSBrZWVwIGFsaXZlIGNvdW50ZXIuXG4gKi9cbmNvbnN0IE1BWF9DT1VOVEVSX1ZBTFVFID0gMiAqKiAzMiAtIDE7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVm9pY2VVRFBTb2NrZXQgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBvbihldmVudDogJ2Vycm9yJywgbGlzdGVuZXI6IChlcnJvcjogRXJyb3IpID0+IHZvaWQpOiB0aGlzO1xuICBvbihldmVudDogJ2Nsb3NlJywgbGlzdGVuZXI6ICgpID0+IHZvaWQpOiB0aGlzO1xuICBvbihldmVudDogJ2RlYnVnJywgbGlzdGVuZXI6IChtZXNzYWdlOiBzdHJpbmcpID0+IHZvaWQpOiB0aGlzO1xuICBvbihldmVudDogJ21lc3NhZ2UnLCBsaXN0ZW5lcjogKG1lc3NhZ2U6IEJ1ZmZlcikgPT4gdm9pZCk6IHRoaXM7XG59XG5cbi8qKlxuICogTWFuYWdlcyB0aGUgVURQIG5ldHdvcmtpbmcgZm9yIGEgdm9pY2UgY29ubmVjdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIFZvaWNlVURQU29ja2V0IGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgLyoqXG4gICAqIFRoZSB1bmRlcmx5aW5nIG5ldHdvcmsgU29ja2V0IGZvciB0aGUgVm9pY2VVRFBTb2NrZXQuXG4gICAqL1xuICBwcml2YXRlIHJlYWRvbmx5IHNvY2tldDogU29ja2V0O1xuXG4gIC8qKlxuICAgKiBUaGUgc29ja2V0IGRldGFpbHMgZm9yIERpc2NvcmQgKHJlbW90ZSlcbiAgICovXG4gIHByaXZhdGUgcmVhZG9ubHkgcmVtb3RlOiBTb2NrZXRDb25maWc7XG5cbiAgLyoqXG4gICAqIFRoZSBjb3VudGVyIHVzZWQgaW4gdGhlIGtlZXAgYWxpdmUgbWVjaGFuaXNtLlxuICAgKi9cbiAgcHJpdmF0ZSBrZWVwQWxpdmVDb3VudGVyID0gMDtcblxuICAvKipcbiAgICogVGhlIGJ1ZmZlciB1c2VkIHRvIHdyaXRlIHRoZSBrZWVwIGFsaXZlIGNvdW50ZXIgaW50by5cbiAgICovXG4gIHByaXZhdGUgcmVhZG9ubHkga2VlcEFsaXZlQnVmZmVyOiBCdWZmZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBOb2RlLmpzIGludGVydmFsIGZvciB0aGUga2VlcC1hbGl2ZSBtZWNoYW5pc20uXG4gICAqL1xuICBwcml2YXRlIHJlYWRvbmx5IGtlZXBBbGl2ZUludGVydmFsOiBOb2RlSlMuVGltZW91dDtcblxuICAvKipcbiAgICogVGhlIHRpbWUgdGFrZW4gdG8gcmVjZWl2ZSBhIHJlc3BvbnNlIHRvIGtlZXAgYWxpdmUgbWVzc2FnZXMuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFRoaXMgZmllbGQgaXMgbm8gbG9uZ2VyIHVwZGF0ZWQgYXMga2VlcCBhbGl2ZSBtZXNzYWdlcyBhcmUgbm8gbG9uZ2VyIHRyYWNrZWQuXG4gICAqL1xuICBwdWJsaWMgcGluZz86IG51bWJlcjtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBWb2ljZVVEUFNvY2tldC5cbiAgICpcbiAgICogQHBhcmFtIHJlbW90ZSAtIERldGFpbHMgb2YgdGhlIHJlbW90ZSBzb2NrZXRcbiAgICovXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihyZW1vdGU6IFNvY2tldENvbmZpZykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5zb2NrZXQgPSBjcmVhdGVTb2NrZXQoJ3VkcDQnKTtcbiAgICB0aGlzLnNvY2tldC5vbignZXJyb3InLCAoZXJyb3I6IEVycm9yKSA9PiB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyb3IpKTtcbiAgICB0aGlzLnNvY2tldC5vbignbWVzc2FnZScsIChidWZmZXI6IEJ1ZmZlcikgPT4gdGhpcy5vbk1lc3NhZ2UoYnVmZmVyKSk7XG4gICAgdGhpcy5zb2NrZXQub24oJ2Nsb3NlJywgKCkgPT4gdGhpcy5lbWl0KCdjbG9zZScpKTtcbiAgICB0aGlzLnJlbW90ZSA9IHJlbW90ZTtcbiAgICB0aGlzLmtlZXBBbGl2ZUJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyg4KTtcbiAgICB0aGlzLmtlZXBBbGl2ZUludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4gdGhpcy5rZWVwQWxpdmUoKSwgS0VFUF9BTElWRV9JTlRFUlZBTCk7XG4gICAgc2V0SW1tZWRpYXRlKCgpID0+IHRoaXMua2VlcEFsaXZlKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIGEgbWVzc2FnZSBpcyByZWNlaXZlZCBvbiB0aGUgVURQIHNvY2tldC5cbiAgICpcbiAgICogQHBhcmFtIGJ1ZmZlciAtIFRoZSByZWNlaXZlZCBidWZmZXJcbiAgICovXG4gIHByaXZhdGUgb25NZXNzYWdlKGJ1ZmZlcjogQnVmZmVyKTogdm9pZCB7XG4gICAgLy8gUHJvcGFnYXRlIHRoZSBtZXNzYWdlXG4gICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgYnVmZmVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgYXQgYSByZWd1bGFyIGludGVydmFsIHRvIGNoZWNrIHdoZXRoZXIgd2UgYXJlIHN0aWxsIGFibGUgdG8gc2VuZCBkYXRhZ3JhbXMgdG8gRGlzY29yZC5cbiAgICovXG4gIHByaXZhdGUga2VlcEFsaXZlKCkge1xuICAgIHRoaXMua2VlcEFsaXZlQnVmZmVyLndyaXRlVUludDMyTEUodGhpcy5rZWVwQWxpdmVDb3VudGVyLCAwKTtcbiAgICB0aGlzLnNlbmQodGhpcy5rZWVwQWxpdmVCdWZmZXIpO1xuICAgIHRoaXMua2VlcEFsaXZlQ291bnRlcisrO1xuICAgIGlmICh0aGlzLmtlZXBBbGl2ZUNvdW50ZXIgPiBNQVhfQ09VTlRFUl9WQUxVRSkge1xuICAgICAgdGhpcy5rZWVwQWxpdmVDb3VudGVyID0gMDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgYSBidWZmZXIgdG8gRGlzY29yZC5cbiAgICpcbiAgICogQHBhcmFtIGJ1ZmZlciAtIFRoZSBidWZmZXIgdG8gc2VuZFxuICAgKi9cbiAgcHVibGljIHNlbmQoYnVmZmVyOiBCdWZmZXIpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5zb2NrZXQuc2VuZChidWZmZXIsIHRoaXMucmVtb3RlLnBvcnQsIHRoaXMucmVtb3RlLmlwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZXMgdGhlIHNvY2tldCwgdGhlIGluc3RhbmNlIHdpbGwgbm90IGJlIGFibGUgdG8gYmUgcmV1c2VkLlxuICAgKi9cbiAgcHVibGljIGRlc3Ryb3koKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuc29ja2V0LmNsb3NlKCk7XG4gICAgfSBjYXRjaCB7XG5cbiAgICAgIC8vXG4gICAgfVxuICAgIGNsZWFySW50ZXJ2YWwodGhpcy5rZWVwQWxpdmVJbnRlcnZhbCk7XG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybXMgSVAgZGlzY292ZXJ5IHRvIGRpc2NvdmVyIHRoZSBsb2NhbCBhZGRyZXNzIGFuZCBwb3J0IHRvIGJlIHVzZWQgZm9yIHRoZSB2b2ljZSBjb25uZWN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gc3NyYyAtIFRoZSBTU1JDIHJlY2VpdmVkIGZyb20gRGlzY29yZFxuICAgKi9cbiAgcHVibGljIGFzeW5jIHBlcmZvcm1JUERpc2NvdmVyeShzc3JjOiBudW1iZXIpOiBQcm9taXNlPFNvY2tldENvbmZpZz4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBsaXN0ZW5lciA9IChtZXNzYWdlOiBCdWZmZXIpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAobWVzc2FnZS5yZWFkVUludDE2QkUoMCkgIT09IDIpIHJldHVybjtcbiAgICAgICAgICBjb25zdCBwYWNrZXQgPSBwYXJzZUxvY2FsUGFja2V0KG1lc3NhZ2UpO1xuICAgICAgICAgIHRoaXMuc29ja2V0Lm9mZignbWVzc2FnZScsIGxpc3RlbmVyKTtcbiAgICAgICAgICByZXNvbHZlKHBhY2tldCk7XG4gICAgICAgIH0gY2F0Y2gge1xuXG4gICAgICAgICAgLy9cbiAgICAgICAgfX07XG5cbiAgICAgIHRoaXMuc29ja2V0Lm9uKCdtZXNzYWdlJywgbGlzdGVuZXIpO1xuICAgICAgdGhpcy5zb2NrZXQub25jZSgnY2xvc2UnLCAoKSA9PiByZWplY3QobmV3IEVycm9yKCdDYW5ub3QgcGVyZm9ybSBJUCBkaXNjb3ZlcnkgLSBzb2NrZXQgY2xvc2VkJykpKTtcblxuICAgICAgY29uc3QgZGlzY292ZXJ5QnVmZmVyID0gQnVmZmVyLmFsbG9jKDc0KTtcblxuICAgICAgZGlzY292ZXJ5QnVmZmVyLndyaXRlVUludDE2QkUoMSwgMCk7XG4gICAgICBkaXNjb3ZlcnlCdWZmZXIud3JpdGVVSW50MTZCRSg3MCwgMik7XG4gICAgICBkaXNjb3ZlcnlCdWZmZXIud3JpdGVVSW50MzJCRShzc3JjLCA0KTtcbiAgICAgIHRoaXMuc2VuZChkaXNjb3ZlcnlCdWZmZXIpO1xuICAgIH0pO1xuICB9XG59IiwgIi8vIENvcHlyaWdodCBkaXNjb3JkLXBsYXllciBhdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLiBNSVQgTGljZW5zZS5cbi8vIENvcHlyaWdodCBkaXNjb3JkLmpzIGF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuIEFwYWNoZSBMaWNlbnNlIDIuMFxuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWRlY2xhcmF0aW9uLW1lcmdpbmcgKi9cblxuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnbm9kZTpldmVudHMnO1xuaW1wb3J0IHsgVm9pY2VPcGNvZGVzIH0gZnJvbSAnZGlzY29yZC1hcGktdHlwZXMvdm9pY2UvdjQnO1xuaW1wb3J0IHsgV2ViU29ja2V0IH0gZnJvbSAnd3MnO1xuaW1wb3J0IHsgdW5zYWZlIH0gZnJvbSAnLi4vY29tbW9uL3R5cGVzJztcblxuZXhwb3J0IGludGVyZmFjZSBWb2ljZVdlYlNvY2tldCBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIG9uKGV2ZW50OiAnZXJyb3InLCBsaXN0ZW5lcjogKGVycm9yOiBFcnJvcikgPT4gdm9pZCk6IHRoaXM7XG4gIG9uKGV2ZW50OiAnb3BlbicsIGxpc3RlbmVyOiAoZXZlbnQ6IEV2ZW50KSA9PiB2b2lkKTogdGhpcztcbiAgb24oZXZlbnQ6ICdjbG9zZScsIGxpc3RlbmVyOiAoZXZlbnQ6IENsb3NlRXZlbnQpID0+IHZvaWQpOiB0aGlzO1xuICAvKipcbiAgICogRGVidWcgZXZlbnQgZm9yIFZvaWNlV2ViU29ja2V0LlxuICAgKlxuICAgKiBAZXZlbnRQcm9wZXJ0eVxuICAgKi9cbiAgb24oZXZlbnQ6ICdkZWJ1ZycsIGxpc3RlbmVyOiAobWVzc2FnZTogc3RyaW5nKSA9PiB2b2lkKTogdGhpcztcbiAgLyoqXG4gICAqIFBhY2tldCBldmVudC5cbiAgICpcbiAgICogQGV2ZW50UHJvcGVydHlcbiAgICovXG4gIG9uKGV2ZW50OiAncGFja2V0JywgbGlzdGVuZXI6IChwYWNrZXQ6IHVuc2FmZSkgPT4gdm9pZCk6IHRoaXM7XG59XG5cbi8qKlxuICogQW4gZXh0ZW5zaW9uIG9mIHRoZSBXZWJTb2NrZXQgY2xhc3MgdG8gcHJvdmlkZSBoZWxwZXIgZnVuY3Rpb25hbGl0eSB3aGVuIGludGVyYWN0aW5nXG4gKiB3aXRoIHRoZSBEaXNjb3JkIFZvaWNlIGdhdGV3YXkuXG4gKi9cbmV4cG9ydCBjbGFzcyBWb2ljZVdlYlNvY2tldCBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBoZWFydGJlYXQgaW50ZXJ2YWwsIGlmIGFueS5cbiAgICovXG4gIHByaXZhdGUgaGVhcnRiZWF0SW50ZXJ2YWw/OiBOb2RlSlMuVGltZW91dDtcblxuICAvKipcbiAgICogVGhlIHRpbWUgKG1pbGxpc2Vjb25kcyBzaW5jZSBVTklYIGVwb2NoKSB0aGF0IHRoZSBsYXN0IGhlYXJ0YmVhdCBhY2tub3dsZWRnZW1lbnQgcGFja2V0IHdhcyByZWNlaXZlZC5cbiAgICogVGhpcyBpcyBzZXQgdG8gMCBpZiBhbiBhY2tub3dsZWRnZW1lbnQgcGFja2V0IGhhc24ndCBiZWVuIHJlY2VpdmVkIHlldC5cbiAgICovXG4gIHByaXZhdGUgbGFzdEhlYXJ0YmVhdEFjazogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgdGltZSAobWlsbGlzZWNvbmRzIHNpbmNlIFVOSVggZXBvY2gpIHRoYXQgdGhlIGxhc3QgaGVhcnRiZWF0IHdhcyBzZW50LiBUaGlzIGlzIHNldCB0byAwIGlmIGEgaGVhcnRiZWF0XG4gICAqIGhhc24ndCBiZWVuIHNlbnQgeWV0LlxuICAgKi9cbiAgcHJpdmF0ZSBsYXN0SGVhcnRiZWF0U2VuZDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgbnVtYmVyIG9mIGNvbnNlY3V0aXZlbHkgbWlzc2VkIGhlYXJ0YmVhdHMuXG4gICAqL1xuICBwcml2YXRlIG1pc3NlZEhlYXJ0YmVhdHMgPSAwO1xuXG4gIC8qKlxuICAgKiBUaGUgbGFzdCByZWNvcmRlZCBwaW5nLlxuICAgKi9cbiAgcHVibGljIHBpbmc/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBkZWJ1ZyBsb2dnZXIgZnVuY3Rpb24sIGlmIGRlYnVnZ2luZyBpcyBlbmFibGVkLlxuICAgKi9cbiAgcHJpdmF0ZSByZWFkb25seSBkZWJ1ZzogKChtZXNzYWdlOiBzdHJpbmcpID0+IHZvaWQpIHwgbnVsbDtcblxuICAvKipcbiAgICogVGhlIHVuZGVybHlpbmcgV2ViU29ja2V0IG9mIHRoaXMgd3JhcHBlci5cbiAgICovXG4gIHByaXZhdGUgcmVhZG9ubHkgd3M6IFdlYlNvY2tldDtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBWb2ljZVdlYlNvY2tldC5cbiAgICpcbiAgICogQHBhcmFtIGFkZHJlc3MgLSBUaGUgYWRkcmVzcyB0byBjb25uZWN0IHRvXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3IoYWRkcmVzczogc3RyaW5nLCBkZWJ1ZzogYm9vbGVhbikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy53cyA9IG5ldyBXZWJTb2NrZXQoYWRkcmVzcyk7XG4gICAgdGhpcy53cy5vbm1lc3NhZ2UgPSAoZXJyKSA9PiB0aGlzLm9uTWVzc2FnZShlcnIgYXMgdW5rbm93biBhcyBNZXNzYWdlRXZlbnQpO1xuICAgIHRoaXMud3Mub25vcGVuID0gKGVycikgPT4gdGhpcy5lbWl0KCdvcGVuJywgZXJyKTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy53cy5vbmVycm9yID0gKGVycjogRXJyb3IgfCBFcnJvckV2ZW50KSA9PiB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIgOiBlcnIuZXJyb3IpO1xuICAgIHRoaXMud3Mub25jbG9zZSA9IChlcnIpID0+IHRoaXMuZW1pdCgnY2xvc2UnLCBlcnIpO1xuXG4gICAgdGhpcy5sYXN0SGVhcnRiZWF0QWNrID0gMDtcbiAgICB0aGlzLmxhc3RIZWFydGJlYXRTZW5kID0gMDtcblxuICAgIHRoaXMuZGVidWcgPSBkZWJ1ZyA/IChtZXNzYWdlOiBzdHJpbmcpID0+IHRoaXMuZW1pdCgnZGVidWcnLCBtZXNzYWdlKSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogRGVzdHJveXMgdGhlIFZvaWNlV2ViU29ja2V0LiBUaGUgaGVhcnRiZWF0IGludGVydmFsIGlzIGNsZWFyZWQsIGFuZCB0aGUgY29ubmVjdGlvbiBpcyBjbG9zZWQuXG4gICAqL1xuICBwdWJsaWMgZGVzdHJveSgpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5kZWJ1Zz8uKCdkZXN0cm95ZWQnKTtcbiAgICAgIHRoaXMuc2V0SGVhcnRiZWF0SW50ZXJ2YWwoLTEpO1xuICAgICAgdGhpcy53cy5jbG9zZSgxXzAwMCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnN0IGVyciA9IGVycm9yIGFzIEVycm9yO1xuICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgbWVzc2FnZSBldmVudHMgb24gdGhlIFdlYlNvY2tldC4gQXR0ZW1wdHMgdG8gSlNPTiBwYXJzZSB0aGUgbWVzc2FnZXMgYW5kIGVtaXQgdGhlbVxuICAgKiBhcyBwYWNrZXRzLlxuICAgKlxuICAgKiBAcGFyYW0gZXZlbnQgLSBUaGUgbWVzc2FnZSBldmVudFxuICAgKi9cbiAgcHVibGljIG9uTWVzc2FnZShldmVudDogTWVzc2FnZUV2ZW50KSB7XG4gICAgaWYgKHR5cGVvZiBldmVudC5kYXRhICE9PSAnc3RyaW5nJykgcmV0dXJuO1xuXG4gICAgdGhpcy5kZWJ1Zz8uKGA8PCAke2V2ZW50LmRhdGF9YCk7XG5cbiAgICBsZXQgcGFja2V0OiB1bnNhZmU7XG4gICAgdHJ5IHtcbiAgICAgIHBhY2tldCA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnN0IGVyciA9IGVycm9yIGFzIEVycm9yO1xuICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHBhY2tldC5vcCA9PT0gVm9pY2VPcGNvZGVzLkhlYXJ0YmVhdEFjaykge1xuICAgICAgdGhpcy5sYXN0SGVhcnRiZWF0QWNrID0gRGF0ZS5ub3coKTtcbiAgICAgIHRoaXMubWlzc2VkSGVhcnRiZWF0cyA9IDA7XG4gICAgICB0aGlzLnBpbmcgPSB0aGlzLmxhc3RIZWFydGJlYXRBY2sgLSB0aGlzLmxhc3RIZWFydGJlYXRTZW5kO1xuICAgIH1cblxuICAgIHRoaXMuZW1pdCgncGFja2V0JywgcGFja2V0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIEpTT04tc3RyaW5naWZpYWJsZSBwYWNrZXQgb3ZlciB0aGUgV2ViU29ja2V0LlxuICAgKlxuICAgKiBAcGFyYW0gcGFja2V0IC0gVGhlIHBhY2tldCB0byBzZW5kXG4gICAqL1xuICBwdWJsaWMgc2VuZFBhY2tldChwYWNrZXQ6IHVuc2FmZSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdHJpbmdpZmllZCA9IEpTT04uc3RyaW5naWZ5KHBhY2tldCk7XG4gICAgICB0aGlzLmRlYnVnPy4oYD4+ICR7c3RyaW5naWZpZWR9YCk7XG4gICAgICB0aGlzLndzLnNlbmQoc3RyaW5naWZpZWQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zdCBlcnIgPSBlcnJvciBhcyBFcnJvcjtcbiAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIGhlYXJ0YmVhdCBvdmVyIHRoZSBXZWJTb2NrZXQuXG4gICAqL1xuICBwcml2YXRlIHNlbmRIZWFydGJlYXQoKSB7XG4gICAgdGhpcy5sYXN0SGVhcnRiZWF0U2VuZCA9IERhdGUubm93KCk7XG4gICAgdGhpcy5taXNzZWRIZWFydGJlYXRzKys7XG4gICAgY29uc3Qgbm9uY2UgPSB0aGlzLmxhc3RIZWFydGJlYXRTZW5kO1xuICAgIHRoaXMuc2VuZFBhY2tldCh7XG4gICAgICBvcDogVm9pY2VPcGNvZGVzLkhlYXJ0YmVhdCxcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpZC1sZW5ndGhcbiAgICAgIGQ6IG5vbmNlXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cy9jbGVhcnMgYW4gaW50ZXJ2YWwgdG8gc2VuZCBoZWFydGJlYXRzIG92ZXIgdGhlIFdlYlNvY2tldC5cbiAgICpcbiAgICogQHBhcmFtIG1zIC0gVGhlIGludGVydmFsIGluIG1pbGxpc2Vjb25kcy4gSWYgbmVnYXRpdmUsIHRoZSBpbnRlcnZhbCB3aWxsIGJlIHVuc2V0XG4gICAqL1xuICBwdWJsaWMgc2V0SGVhcnRiZWF0SW50ZXJ2YWwobXM6IG51bWJlcikge1xuICAgIGlmICh0aGlzLmhlYXJ0YmVhdEludGVydmFsICE9PSB1bmRlZmluZWQpIGNsZWFySW50ZXJ2YWwodGhpcy5oZWFydGJlYXRJbnRlcnZhbCk7XG4gICAgaWYgKG1zID4gMCkge1xuICAgICAgdGhpcy5oZWFydGJlYXRJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMubGFzdEhlYXJ0YmVhdFNlbmQgIT09IDAgJiYgdGhpcy5taXNzZWRIZWFydGJlYXRzID49IDMpIHtcbiAgICAgICAgICAvLyBNaXNzZWQgdG9vIG1hbnkgaGVhcnRiZWF0cyAtIGRpc2Nvbm5lY3RcbiAgICAgICAgICB0aGlzLndzLmNsb3NlKCk7XG4gICAgICAgICAgdGhpcy5zZXRIZWFydGJlYXRJbnRlcnZhbCgtMSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNlbmRIZWFydGJlYXQoKTtcbiAgICAgIH0sIG1zKTtcbiAgICB9XG4gIH1cbn0iLCAiLy8gQ29weXJpZ2h0IGRpc2NvcmQtcGxheWVyIGF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuIE1JVCBMaWNlbnNlLlxuLy8gQ29weXJpZ2h0IGRpc2NvcmQuanMgYXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC4gQXBhY2hlIExpY2Vuc2UgMi4wXG5cbmltcG9ydCB0eXBlIHsgSm9pbkNvbmZpZyB9IGZyb20gJy4vRGF0YVN0b3JlJztcbmltcG9ydCB7IGNyZWF0ZVZvaWNlQ29ubmVjdGlvbiB9IGZyb20gJy4vVm9pY2VDb25uZWN0aW9uJztcbmltcG9ydCB0eXBlIHsgRGlzY29yZEdhdGV3YXlBZGFwdGVyQ3JlYXRvciB9IGZyb20gJy4vdXRpbC9hZGFwdGVyJztcblxuLyoqXG4gKiBUaGUgb3B0aW9ucyB0aGF0IGNhbiBiZSBnaXZlbiB3aGVuIGNyZWF0aW5nIGEgdm9pY2UgY29ubmVjdGlvbi5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDcmVhdGVWb2ljZUNvbm5lY3Rpb25PcHRpb25zIHtcbiAgYWRhcHRlckNyZWF0b3I6IERpc2NvcmRHYXRld2F5QWRhcHRlckNyZWF0b3I7XG5cbiAgLyoqXG4gICAqIElmIHRydWUsIGRlYnVnIG1lc3NhZ2VzIHdpbGwgYmUgZW5hYmxlZCBmb3IgdGhlIHZvaWNlIGNvbm5lY3Rpb24gYW5kIGl0c1xuICAgKiByZWxhdGVkIGNvbXBvbmVudHMuIERlZmF1bHRzIHRvIGZhbHNlLlxuICAgKi9cbiAgZGVidWc/OiBib29sZWFuIHwgdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIFRoZSBvcHRpb25zIHRoYXQgY2FuIGJlIGdpdmVuIHdoZW4gam9pbmluZyBhIHZvaWNlIGNoYW5uZWwuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSm9pblZvaWNlQ2hhbm5lbE9wdGlvbnMge1xuICAvKipcbiAgICogVGhlIGlkIG9mIHRoZSBEaXNjb3JkIHZvaWNlIGNoYW5uZWwgdG8gam9pbi5cbiAgICovXG4gIGNoYW5uZWxJZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBbiBvcHRpb25hbCBncm91cCBpZGVudGlmaWVyIGZvciB0aGUgdm9pY2UgY29ubmVjdGlvbi5cbiAgICovXG4gIGdyb3VwPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgaWQgb2YgdGhlIGd1aWxkIHRoYXQgdGhlIHZvaWNlIGNoYW5uZWwgYmVsb25ncyB0by5cbiAgICovXG4gIGd1aWxkSWQ6IHN0cmluZztcblxuICAvKipcbiAgICogV2hldGhlciB0byBqb2luIHRoZSBjaGFubmVsIGRlYWZlbmVkIChkZWZhdWx0cyB0byB0cnVlKVxuICAgKi9cbiAgc2VsZkRlYWY/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGpvaW4gdGhlIGNoYW5uZWwgbXV0ZWQgKGRlZmF1bHRzIHRvIHRydWUpXG4gICAqL1xuICBzZWxmTXV0ZT86IGJvb2xlYW47XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIFZvaWNlQ29ubmVjdGlvbiB0byBhIERpc2NvcmQgdm9pY2UgY2hhbm5lbC5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIHRoZSBvcHRpb25zIGZvciBqb2luaW5nIHRoZSB2b2ljZSBjaGFubmVsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBqb2luVm9pY2VDaGFubmVsKG9wdGlvbnM6IENyZWF0ZVZvaWNlQ29ubmVjdGlvbk9wdGlvbnMgJiBKb2luVm9pY2VDaGFubmVsT3B0aW9ucykge1xuICBjb25zdCBqb2luQ29uZmlnOiBKb2luQ29uZmlnID0ge1xuICAgIHNlbGZEZWFmOiB0cnVlLFxuICAgIHNlbGZNdXRlOiBmYWxzZSxcbiAgICBncm91cDogJ2RlZmF1bHQnLFxuICAgIC4uLm9wdGlvbnNcbiAgfTtcblxuICByZXR1cm4gY3JlYXRlVm9pY2VDb25uZWN0aW9uKGpvaW5Db25maWcsIHtcbiAgICBhZGFwdGVyQ3JlYXRvcjogb3B0aW9ucy5hZGFwdGVyQ3JlYXRvcixcbiAgICBkZWJ1Zzogb3B0aW9ucy5kZWJ1Z1xuICB9KTtcbn0iLCAiLy8gQ29weXJpZ2h0IGRpc2NvcmQtcGxheWVyIGF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuIE1JVCBMaWNlbnNlLlxuLy8gQ29weXJpZ2h0IGRpc2NvcmQuanMgYXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC4gQXBhY2hlIExpY2Vuc2UgMi4wXG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9wcmVmZXItdHMtZXhwZWN0LWVycm9yLCBAdHlwZXNjcmlwdC1lc2xpbnQvbWV0aG9kLXNpZ25hdHVyZS1zdHlsZSAqL1xuaW1wb3J0IHsgQnVmZmVyIH0gZnJvbSAnbm9kZTpidWZmZXInO1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnbm9kZTpldmVudHMnO1xuaW1wb3J0IHsgYWRkQXVkaW9QbGF5ZXIsIGRlbGV0ZUF1ZGlvUGxheWVyIH0gZnJvbSAnLi4vRGF0YVN0b3JlJztcbmltcG9ydCB7IFZvaWNlQ29ubmVjdGlvblN0YXR1cywgdHlwZSBWb2ljZUNvbm5lY3Rpb24gfSBmcm9tICcuLi9Wb2ljZUNvbm5lY3Rpb24nO1xuaW1wb3J0IHsgbm9vcCB9IGZyb20gJy4uL3V0aWwvdXRpbCc7XG5pbXBvcnQgeyBBdWRpb1BsYXllckVycm9yIH0gZnJvbSAnLi9BdWRpb1BsYXllckVycm9yJztcbmltcG9ydCB0eXBlIHsgQXVkaW9SZXNvdXJjZSB9IGZyb20gJy4vQXVkaW9SZXNvdXJjZSc7XG5pbXBvcnQgeyBQbGF5ZXJTdWJzY3JpcHRpb24gfSBmcm9tICcuL1BsYXllclN1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyB1bnNhZmUgfSBmcm9tICcuLi9jb21tb24vdHlwZXMnO1xuXG4vLyBUaGUgT3B1cyBcInNpbGVudFwiIGZyYW1lXG5leHBvcnQgY29uc3QgU0lMRU5DRV9GUkFNRSA9IEJ1ZmZlci5mcm9tKFsweGY4LCAweGZmLCAweGZlXSk7XG5cbi8qKlxuICogRGVzY3JpYmVzIHRoZSBiZWhhdmlvciBvZiB0aGUgcGxheWVyIHdoZW4gYW4gYXVkaW8gcGFja2V0IGlzIHBsYXllZCBidXQgdGhlcmUgYXJlIG5vIGF2YWlsYWJsZVxuICogdm9pY2UgY29ubmVjdGlvbnMgdG8gcGxheSB0by5cbiAqL1xuZXhwb3J0IGVudW0gTm9TdWJzY3JpYmVyQmVoYXZpb3Ige1xuICAvKipcbiAgICogUGF1c2VzIHBsYXlpbmcgdGhlIHN0cmVhbSB1bnRpbCBhIHZvaWNlIGNvbm5lY3Rpb24gYmVjb21lcyBhdmFpbGFibGUuXG4gICAqL1xuICBQYXVzZSA9ICdwYXVzZScsXG5cbiAgLyoqXG4gICAqIENvbnRpbnVlcyB0byBwbGF5IHRocm91Z2ggdGhlIHJlc291cmNlIHJlZ2FyZGxlc3MuXG4gICAqL1xuICBQbGF5ID0gJ3BsYXknLFxuXG4gIC8qKlxuICAgKiBUaGUgcGxheWVyIHN0b3BzIGFuZCBlbnRlcnMgdGhlIElkbGUgc3RhdGUuXG4gICAqL1xuICBTdG9wID0gJ3N0b3AnLFxufVxuXG5leHBvcnQgZW51bSBBdWRpb1BsYXllclN0YXR1cyB7XG4gIC8qKlxuICAgKiBXaGVuIHRoZSBwbGF5ZXIgaGFzIHBhdXNlZCBpdHNlbGYuIE9ubHkgcG9zc2libGUgd2l0aCB0aGUgXCJwYXVzZVwiIG5vIHN1YnNjcmliZXIgYmVoYXZpb3IuXG4gICAqL1xuICBBdXRvUGF1c2VkID0gJ2F1dG9wYXVzZWQnLFxuXG4gIC8qKlxuICAgKiBXaGVuIHRoZSBwbGF5ZXIgaXMgd2FpdGluZyBmb3IgYW4gYXVkaW8gcmVzb3VyY2UgdG8gYmVjb21lIHJlYWRhYmxlIGJlZm9yZSB0cmFuc2l0aW9uaW5nIHRvIFBsYXlpbmcuXG4gICAqL1xuICBCdWZmZXJpbmcgPSAnYnVmZmVyaW5nJyxcblxuICAvKipcbiAgICogV2hlbiB0aGVyZSBpcyBjdXJyZW50bHkgbm8gcmVzb3VyY2UgZm9yIHRoZSBwbGF5ZXIgdG8gYmUgcGxheWluZy5cbiAgICovXG4gIElkbGUgPSAnaWRsZScsXG5cbiAgLyoqXG4gICAqIFdoZW4gdGhlIHBsYXllciBoYXMgYmVlbiBtYW51YWxseSBwYXVzZWQuXG4gICAqL1xuICBQYXVzZWQgPSAncGF1c2VkJyxcblxuICAvKipcbiAgICogV2hlbiB0aGUgcGxheWVyIGlzIGFjdGl2ZWx5IHBsYXlpbmcgYW4gYXVkaW8gcmVzb3VyY2UuXG4gICAqL1xuICBQbGF5aW5nID0gJ3BsYXlpbmcnLFxufVxuXG4vKipcbiAqIE9wdGlvbnMgdGhhdCBjYW4gYmUgcGFzc2VkIHdoZW4gY3JlYXRpbmcgYW4gYXVkaW8gcGxheWVyLCB1c2VkIHRvIHNwZWNpZnkgaXRzIGJlaGF2aW9yLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIENyZWF0ZUF1ZGlvUGxheWVyT3B0aW9ucyB7XG4gIGJlaGF2aW9ycz86IHtcbiAgICBtYXhNaXNzZWRGcmFtZXM/OiBudW1iZXI7XG4gICAgbm9TdWJzY3JpYmVyPzogTm9TdWJzY3JpYmVyQmVoYXZpb3I7XG4gIH07XG4gIGRlYnVnPzogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBUaGUgc3RhdGUgdGhhdCBhbiBBdWRpb1BsYXllciBpcyBpbiB3aGVuIGl0IGhhcyBubyByZXNvdXJjZSB0byBwbGF5LiBUaGlzIGlzIHRoZSBzdGFydGluZyBzdGF0ZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBdWRpb1BsYXllcklkbGVTdGF0ZSB7XG4gIHN0YXR1czogQXVkaW9QbGF5ZXJTdGF0dXMuSWRsZTtcbn1cblxuLyoqXG4gKiBUaGUgc3RhdGUgdGhhdCBhbiBBdWRpb1BsYXllciBpcyBpbiB3aGVuIGl0IGlzIHdhaXRpbmcgZm9yIGEgcmVzb3VyY2UgdG8gYmVjb21lIHJlYWRhYmxlLiBPbmNlIHRoaXNcbiAqIGhhcHBlbnMsIHRoZSBBdWRpb1BsYXllciB3aWxsIGVudGVyIHRoZSBQbGF5aW5nIHN0YXRlLiBJZiB0aGUgcmVzb3VyY2UgZW5kcy9lcnJvcnMgYmVmb3JlIHRoaXMsIHRoZW5cbiAqIGl0IHdpbGwgcmUtZW50ZXIgdGhlIElkbGUgc3RhdGUuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQXVkaW9QbGF5ZXJCdWZmZXJpbmdTdGF0ZSB7XG4gIG9uRmFpbHVyZUNhbGxiYWNrOiAoKSA9PiB2b2lkO1xuICBvblJlYWRhYmxlQ2FsbGJhY2s6ICgpID0+IHZvaWQ7XG4gIG9uU3RyZWFtRXJyb3I6IChlcnJvcjogRXJyb3IpID0+IHZvaWQ7XG4gIC8qKlxuICAgKiBUaGUgcmVzb3VyY2UgdGhhdCB0aGUgQXVkaW9QbGF5ZXIgaXMgd2FpdGluZyBmb3JcbiAgICovXG4gIHJlc291cmNlOiBBdWRpb1Jlc291cmNlO1xuICBzdGF0dXM6IEF1ZGlvUGxheWVyU3RhdHVzLkJ1ZmZlcmluZztcbn1cblxuLyoqXG4gKiBUaGUgc3RhdGUgdGhhdCBhbiBBdWRpb1BsYXllciBpcyBpbiB3aGVuIGl0IGlzIGFjdGl2ZWx5IHBsYXlpbmcgYW4gQXVkaW9SZXNvdXJjZS4gV2hlbiBwbGF5YmFjayBlbmRzLFxuICogaXQgd2lsbCBlbnRlciB0aGUgSWRsZSBzdGF0ZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBdWRpb1BsYXllclBsYXlpbmdTdGF0ZSB7XG4gIC8qKlxuICAgKiBUaGUgbnVtYmVyIG9mIGNvbnNlY3V0aXZlIHRpbWVzIHRoYXQgdGhlIGF1ZGlvIHJlc291cmNlIGhhcyBiZWVuIHVuYWJsZSB0byBwcm92aWRlIGFuIE9wdXMgZnJhbWUuXG4gICAqL1xuICBtaXNzZWRGcmFtZXM6IG51bWJlcjtcbiAgb25TdHJlYW1FcnJvcjogKGVycm9yOiBFcnJvcikgPT4gdm9pZDtcblxuICAvKipcbiAgICogVGhlIHBsYXliYWNrIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcyBvZiB0aGUgY3VycmVudCBhdWRpbyByZXNvdXJjZS4gVGhpcyBpbmNsdWRlcyBmaWxsZXIgc2lsZW5jZSBwYWNrZXRzXG4gICAqIHRoYXQgaGF2ZSBiZWVuIHBsYXllZCB3aGVuIHRoZSByZXNvdXJjZSB3YXMgYnVmZmVyaW5nLlxuICAgKi9cbiAgcGxheWJhY2tEdXJhdGlvbjogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgcmVzb3VyY2UgdGhhdCBpcyBiZWluZyBwbGF5ZWQuXG4gICAqL1xuICByZXNvdXJjZTogQXVkaW9SZXNvdXJjZTtcblxuICBzdGF0dXM6IEF1ZGlvUGxheWVyU3RhdHVzLlBsYXlpbmc7XG59XG5cbi8qKlxuICogVGhlIHN0YXRlIHRoYXQgYW4gQXVkaW9QbGF5ZXIgaXMgaW4gd2hlbiBpdCBoYXMgZWl0aGVyIGJlZW4gZXhwbGljaXRseSBwYXVzZWQgYnkgdGhlIHVzZXIsIG9yIGRvbmVcbiAqIGF1dG9tYXRpY2FsbHkgYnkgdGhlIEF1ZGlvUGxheWVyIGl0c2VsZiBpZiB0aGVyZSBhcmUgbm8gYXZhaWxhYmxlIHN1YnNjcmliZXJzLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEF1ZGlvUGxheWVyUGF1c2VkU3RhdGUge1xuICBvblN0cmVhbUVycm9yOiAoZXJyb3I6IEVycm9yKSA9PiB2b2lkO1xuICAvKipcbiAgICogVGhlIHBsYXliYWNrIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcyBvZiB0aGUgY3VycmVudCBhdWRpbyByZXNvdXJjZS4gVGhpcyBpbmNsdWRlcyBmaWxsZXIgc2lsZW5jZSBwYWNrZXRzXG4gICAqIHRoYXQgaGF2ZSBiZWVuIHBsYXllZCB3aGVuIHRoZSByZXNvdXJjZSB3YXMgYnVmZmVyaW5nLlxuICAgKi9cbiAgcGxheWJhY2tEdXJhdGlvbjogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCByZXNvdXJjZSBvZiB0aGUgYXVkaW8gcGxheWVyLlxuICAgKi9cbiAgcmVzb3VyY2U6IEF1ZGlvUmVzb3VyY2U7XG5cbiAgLyoqXG4gICAqIEhvdyBtYW55IHNpbGVuY2UgcGFja2V0cyBzdGlsbCBuZWVkIHRvIGJlIHBsYXllZCB0byBhdm9pZCBhdWRpbyBpbnRlcnBvbGF0aW9uIGR1ZSB0byB0aGUgc3RyZWFtIHN1ZGRlbmx5IHBhdXNpbmcuXG4gICAqL1xuICBzaWxlbmNlUGFja2V0c1JlbWFpbmluZzogbnVtYmVyO1xuXG4gIHN0YXR1czogQXVkaW9QbGF5ZXJTdGF0dXMuQXV0b1BhdXNlZCB8IEF1ZGlvUGxheWVyU3RhdHVzLlBhdXNlZDtcbn1cblxuLyoqXG4gKiBUaGUgdmFyaW91cyBzdGF0ZXMgdGhhdCB0aGUgcGxheWVyIGNhbiBiZSBpbi5cbiAqL1xuZXhwb3J0IHR5cGUgQXVkaW9QbGF5ZXJTdGF0ZSA9XG5BdWRpb1BsYXllckJ1ZmZlcmluZ1N0YXRlIHxcbkF1ZGlvUGxheWVySWRsZVN0YXRlIHxcbkF1ZGlvUGxheWVyUGF1c2VkU3RhdGUgfFxuQXVkaW9QbGF5ZXJQbGF5aW5nU3RhdGU7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWRlY2xhcmF0aW9uLW1lcmdpbmdcbmV4cG9ydCBpbnRlcmZhY2UgQXVkaW9QbGF5ZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAvKipcbiAgICogRW1pdHRlZCB3aGVuIHRoZXJlIGlzIGFuIGVycm9yIGVtaXR0ZWQgZnJvbSB0aGUgYXVkaW8gcmVzb3VyY2UgcGxheWVkIGJ5IHRoZSBhdWRpbyBwbGF5ZXJcbiAgICpcbiAgICogQGV2ZW50UHJvcGVydHlcbiAgICovXG4gIG9uKGV2ZW50OiAnZXJyb3InLCBsaXN0ZW5lcjogKGVycm9yOiBBdWRpb1BsYXllckVycm9yKSA9PiB2b2lkKTogdGhpcztcbiAgLyoqXG4gICAqIEVtaXR0ZWQgZGVidWdnaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSBhdWRpbyBwbGF5ZXJcbiAgICpcbiAgICogQGV2ZW50UHJvcGVydHlcbiAgICovXG4gIG9uKGV2ZW50OiAnZGVidWcnLCBsaXN0ZW5lcjogKG1lc3NhZ2U6IHN0cmluZykgPT4gdm9pZCk6IHRoaXM7XG4gIC8qKlxuICAgKiBFbWl0dGVkIHdoZW4gdGhlIHN0YXRlIG9mIHRoZSBhdWRpbyBwbGF5ZXIgY2hhbmdlc1xuICAgKlxuICAgKiBAZXZlbnRQcm9wZXJ0eVxuICAgKi9cbiAgb24oZXZlbnQ6ICdzdGF0ZUNoYW5nZScsIGxpc3RlbmVyOiAob2xkU3RhdGU6IEF1ZGlvUGxheWVyU3RhdGUsIG5ld1N0YXRlOiBBdWRpb1BsYXllclN0YXRlKSA9PiB2b2lkKTogdGhpcztcbiAgLyoqXG4gICAqIEVtaXR0ZWQgd2hlbiB0aGUgYXVkaW8gcGxheWVyIGlzIHN1YnNjcmliZWQgdG8gYSB2b2ljZSBjb25uZWN0aW9uXG4gICAqXG4gICAqIEBldmVudFByb3BlcnR5XG4gICAqL1xuICBvbihldmVudDogJ3N1YnNjcmliZScgfCAndW5zdWJzY3JpYmUnLCBsaXN0ZW5lcjogKHN1YnNjcmlwdGlvbjogUGxheWVyU3Vic2NyaXB0aW9uKSA9PiB2b2lkKTogdGhpcztcbiAgLyoqXG4gICAqIEVtaXR0ZWQgd2hlbiB0aGUgc3RhdHVzIG9mIHN0YXRlIGNoYW5nZXMgdG8gYSBzcGVjaWZpYyBzdGF0dXNcbiAgICpcbiAgICogQGV2ZW50UHJvcGVydHlcbiAgICovXG4gIG9uPEV2ZW50IGV4dGVuZHMgQXVkaW9QbGF5ZXJTdGF0dXM+KFxuICBldmVudDogRXZlbnQsXG4gIGxpc3RlbmVyOiAob2xkU3RhdGU6IEF1ZGlvUGxheWVyU3RhdGUsIG5ld1N0YXRlOiBBdWRpb1BsYXllclN0YXRlICYge3N0YXR1czogRXZlbnQ7fSkgPT4gdm9pZClcbiAgOiB0aGlzO1xufVxuXG4vKipcbiAqIFN0cmluZ2lmaWVzIGFuIEF1ZGlvUGxheWVyU3RhdGUgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHN0YXRlIC0gVGhlIHN0YXRlIHRvIHN0cmluZ2lmeVxuICovXG5mdW5jdGlvbiBzdHJpbmdpZnlTdGF0ZShzdGF0ZTogQXVkaW9QbGF5ZXJTdGF0ZSkge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgIC4uLnN0YXRlLFxuICAgIHJlc291cmNlOiBSZWZsZWN0LmhhcyhzdGF0ZSwgJ3Jlc291cmNlJyksXG4gICAgc3RlcFRpbWVvdXQ6IFJlZmxlY3QuaGFzKHN0YXRlLCAnc3RlcFRpbWVvdXQnKVxuICB9KTtcbn1cblxuLyoqXG4gKiBVc2VkIHRvIHBsYXkgYXVkaW8gcmVzb3VyY2VzIChpLmUuIHRyYWNrcywgc3RyZWFtcykgdG8gdm9pY2UgY29ubmVjdGlvbnMuXG4gKlxuICogQHJlbWFya3NcbiAqIEF1ZGlvIHBsYXllcnMgYXJlIGRlc2lnbmVkIHRvIGJlIHJlLXVzZWQgLSBldmVuIGlmIGEgcmVzb3VyY2UgaGFzIGZpbmlzaGVkIHBsYXlpbmcsIHRoZSBwbGF5ZXIgaXRzZWxmXG4gKiBjYW4gc3RpbGwgYmUgdXNlZC5cbiAqXG4gKiBUaGUgQXVkaW9QbGF5ZXIgZHJpdmVzIHRoZSB0aW1pbmcgb2YgcGxheWJhY2ssIGFuZCB0aGVyZWZvcmUgaXMgdW5hZmZlY3RlZCBieSB2b2ljZSBjb25uZWN0aW9uc1xuICogYmVjb21pbmcgdW5hdmFpbGFibGUuIEl0cyBiZWhhdmlvciBpbiB0aGVzZSBzY2VuYXJpb3MgY2FuIGJlIGNvbmZpZ3VyZWQuXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWRlY2xhcmF0aW9uLW1lcmdpbmdcbmV4cG9ydCBjbGFzcyBBdWRpb1BsYXllciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIC8qKlxuICAgKiBUaGUgc3RhdGUgdGhhdCB0aGUgQXVkaW9QbGF5ZXIgaXMgaW4uXG4gICAqL1xuICBwcml2YXRlIF9zdGF0ZTogQXVkaW9QbGF5ZXJTdGF0ZTtcblxuICAvKipcbiAgICogQSBsaXN0IG9mIFZvaWNlQ29ubmVjdGlvbnMgdGhhdCBhcmUgcmVnaXN0ZXJlZCB0byB0aGlzIEF1ZGlvUGxheWVyLiBUaGUgcGxheWVyIHdpbGwgYXR0ZW1wdCB0byBwbGF5IGF1ZGlvXG4gICAqIHRvIHRoZSBzdHJlYW1zIGluIHRoaXMgbGlzdC5cbiAgICovXG4gIHByaXZhdGUgcmVhZG9ubHkgc3Vic2NyaWJlcnM6IFBsYXllclN1YnNjcmlwdGlvbltdID0gW107XG5cbiAgLyoqXG4gICAqIFRoZSBiZWhhdmlvciB0aGF0IHRoZSBwbGF5ZXIgc2hvdWxkIGZvbGxvdyB3aGVuIGl0IGVudGVycyBjZXJ0YWluIHNpdHVhdGlvbnMuXG4gICAqL1xuICBwcml2YXRlIHJlYWRvbmx5IGJlaGF2aW9yczoge1xuICAgIG1heE1pc3NlZEZyYW1lczogbnVtYmVyO1xuICAgIG5vU3Vic2NyaWJlcjogTm9TdWJzY3JpYmVyQmVoYXZpb3I7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoZSBkZWJ1ZyBsb2dnZXIgZnVuY3Rpb24sIGlmIGRlYnVnZ2luZyBpcyBlbmFibGVkLlxuICAgKi9cbiAgcHJpdmF0ZSByZWFkb25seSBkZWJ1ZzogKChtZXNzYWdlOiBzdHJpbmcpID0+IHZvaWQpIHwgbnVsbDtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBBdWRpb1BsYXllci5cbiAgICovXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihvcHRpb25zOiBDcmVhdGVBdWRpb1BsYXllck9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fc3RhdGUgPSB7IHN0YXR1czogQXVkaW9QbGF5ZXJTdGF0dXMuSWRsZSB9O1xuICAgIHRoaXMuYmVoYXZpb3JzID0ge1xuICAgICAgbm9TdWJzY3JpYmVyOiBOb1N1YnNjcmliZXJCZWhhdmlvci5QYXVzZSxcbiAgICAgIG1heE1pc3NlZEZyYW1lczogNSxcbiAgICAgIC4uLm9wdGlvbnMuYmVoYXZpb3JzXG4gICAgfTtcbiAgICB0aGlzLmRlYnVnID0gb3B0aW9ucy5kZWJ1ZyA9PT0gZmFsc2UgPyBudWxsIDogKG1lc3NhZ2U6IHN0cmluZykgPT4gdGhpcy5lbWl0KCdkZWJ1ZycsIG1lc3NhZ2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgbGlzdCBvZiBzdWJzY3JpYmVkIHZvaWNlIGNvbm5lY3Rpb25zIHRoYXQgY2FuIGN1cnJlbnRseSByZWNlaXZlIGF1ZGlvIHRvIHBsYXkuXG4gICAqL1xuICBwdWJsaWMgZ2V0IHBsYXlhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLnN1YnNjcmliZXJzLlxuICAgIGZpbHRlcigoeyBjb25uZWN0aW9uIH0pID0+IGNvbm5lY3Rpb24uc3RhdGUuc3RhdHVzID09PSBWb2ljZUNvbm5lY3Rpb25TdGF0dXMuUmVhZHkpLlxuICAgIG1hcCgoeyBjb25uZWN0aW9uIH0pID0+IGNvbm5lY3Rpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIFN1YnNjcmliZXMgYSBWb2ljZUNvbm5lY3Rpb24gdG8gdGhlIGF1ZGlvIHBsYXllcidzIHBsYXkgbGlzdC4gSWYgdGhlIFZvaWNlQ29ubmVjdGlvbiBpcyBhbHJlYWR5IHN1YnNjcmliZWQsXG4gICAqIHRoZW4gdGhlIGV4aXN0aW5nIHN1YnNjcmlwdGlvbiBpcyB1c2VkLlxuICAgKlxuICAgKiBAcmVtYXJrc1xuICAgKiBUaGlzIG1ldGhvZCBzaG91bGQgbm90IGJlIGRpcmVjdGx5IGNhbGxlZC4gSW5zdGVhZCwgdXNlIFZvaWNlQ29ubmVjdGlvbiNzdWJzY3JpYmUuXG4gICAqIEBwYXJhbSBjb25uZWN0aW9uIC0gVGhlIGNvbm5lY3Rpb24gdG8gc3Vic2NyaWJlXG4gICAqIEByZXR1cm5zIFRoZSBuZXcgc3Vic2NyaXB0aW9uIGlmIHRoZSB2b2ljZSBjb25uZWN0aW9uIGlzIG5vdCB5ZXQgc3Vic2NyaWJlZCwgb3RoZXJ3aXNlIHRoZSBleGlzdGluZyBzdWJzY3JpcHRpb25cbiAgICovXG4gIC8vIEB0cy1pZ25vcmVcbiAgcHJpdmF0ZSBzdWJzY3JpYmUoY29ubmVjdGlvbjogVm9pY2VDb25uZWN0aW9uKSB7XG4gICAgY29uc3QgZXhpc3RpbmdTdWJzY3JpcHRpb24gPSB0aGlzLnN1YnNjcmliZXJzLmZpbmQoKHN1YnNjcmlwdGlvbikgPT4gc3Vic2NyaXB0aW9uLmNvbm5lY3Rpb24gPT09IGNvbm5lY3Rpb24pO1xuICAgIGlmICghZXhpc3RpbmdTdWJzY3JpcHRpb24pIHtcbiAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IG5ldyBQbGF5ZXJTdWJzY3JpcHRpb24oY29ubmVjdGlvbiwgdGhpcyk7XG4gICAgICB0aGlzLnN1YnNjcmliZXJzLnB1c2goc3Vic2NyaXB0aW9uKTtcbiAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB0aGlzLmVtaXQoJ3N1YnNjcmliZScsIHN1YnNjcmlwdGlvbikpO1xuICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgICB9XG5cbiAgICByZXR1cm4gZXhpc3RpbmdTdWJzY3JpcHRpb247XG4gIH1cblxuICAvKipcbiAgICogVW5zdWJzY3JpYmVzIGEgc3Vic2NyaXB0aW9uIC0gaS5lLiByZW1vdmVzIGEgdm9pY2UgY29ubmVjdGlvbiBmcm9tIHRoZSBwbGF5IGxpc3Qgb2YgdGhlIGF1ZGlvIHBsYXllci5cbiAgICpcbiAgICogQHJlbWFya3NcbiAgICogVGhpcyBtZXRob2Qgc2hvdWxkIG5vdCBiZSBkaXJlY3RseSBjYWxsZWQuIEluc3RlYWQsIHVzZSBQbGF5ZXJTdWJzY3JpcHRpb24jdW5zdWJzY3JpYmUuXG4gICAqIEBwYXJhbSBzdWJzY3JpcHRpb24gLSBUaGUgc3Vic2NyaXB0aW9uIHRvIHJlbW92ZVxuICAgKiBAcmV0dXJucyBXaGV0aGVyIG9yIG5vdCB0aGUgc3Vic2NyaXB0aW9uIGV4aXN0ZWQgb24gdGhlIHBsYXllciBhbmQgd2FzIHJlbW92ZWRcbiAgICovXG4gIC8vIEB0cy1pZ25vcmVcbiAgcHJpdmF0ZSB1bnN1YnNjcmliZShzdWJzY3JpcHRpb246IFBsYXllclN1YnNjcmlwdGlvbikge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5zdWJzY3JpYmVycy5pbmRleE9mKHN1YnNjcmlwdGlvbik7XG4gICAgY29uc3QgZXhpc3RzID0gaW5kZXggIT09IC0xO1xuICAgIGlmIChleGlzdHMpIHtcbiAgICAgIHRoaXMuc3Vic2NyaWJlcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIHN1YnNjcmlwdGlvbi5jb25uZWN0aW9uLnNldFNwZWFraW5nKGZhbHNlKTtcbiAgICAgIHRoaXMuZW1pdCgndW5zdWJzY3JpYmUnLCBzdWJzY3JpcHRpb24pO1xuICAgIH1cblxuICAgIHJldHVybiBleGlzdHM7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHN0YXRlIHRoYXQgdGhlIHBsYXllciBpcyBpbi5cbiAgICovXG4gIHB1YmxpYyBnZXQgc3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgYSBuZXcgc3RhdGUgZm9yIHRoZSBwbGF5ZXIsIHBlcmZvcm1pbmcgY2xlYW4tdXAgb3BlcmF0aW9ucyB3aGVyZSBuZWNlc3NhcnkuXG4gICAqL1xuICBwdWJsaWMgc2V0IHN0YXRlKG5ld1N0YXRlOiBBdWRpb1BsYXllclN0YXRlKSB7XG4gICAgY29uc3Qgb2xkU3RhdGUgPSB0aGlzLl9zdGF0ZTtcbiAgICBjb25zdCBuZXdSZXNvdXJjZSA9IFJlZmxlY3QuZ2V0KG5ld1N0YXRlLCAncmVzb3VyY2UnKSBhcyBBdWRpb1Jlc291cmNlIHwgdW5kZWZpbmVkO1xuXG4gICAgaWYgKG9sZFN0YXRlLnN0YXR1cyAhPT0gQXVkaW9QbGF5ZXJTdGF0dXMuSWRsZSAmJiBvbGRTdGF0ZS5yZXNvdXJjZSAhPT0gbmV3UmVzb3VyY2UpIHtcbiAgICAgIG9sZFN0YXRlLnJlc291cmNlLnBsYXlTdHJlYW0ub24oJ2Vycm9yJywgbm9vcCk7XG4gICAgICBvbGRTdGF0ZS5yZXNvdXJjZS5wbGF5U3RyZWFtLm9mZignZXJyb3InLCBvbGRTdGF0ZS5vblN0cmVhbUVycm9yKTtcbiAgICAgIG9sZFN0YXRlLnJlc291cmNlLmF1ZGlvUGxheWVyID0gdW5kZWZpbmVkO1xuICAgICAgb2xkU3RhdGUucmVzb3VyY2UucGxheVN0cmVhbS5kZXN0cm95KCk7XG4gICAgICBvbGRTdGF0ZS5yZXNvdXJjZS5wbGF5U3RyZWFtLnJlYWQoKTsgLy8gcmVxdWlyZWQgdG8gZW5zdXJlIGJ1ZmZlcmVkIGRhdGEgaXMgZHJhaW5lZCwgcHJldmVudHMgbWVtb3J5IGxlYWtcbiAgICB9XG5cbiAgICAvLyBXaGVuIGxlYXZpbmcgdGhlIEJ1ZmZlcmluZyBzdGF0ZSAob3IgYnVmZmVyaW5nIGEgbmV3IHJlc291cmNlKSwgdGhlbiByZW1vdmUgdGhlIGV2ZW50IGxpc3RlbmVycyBmcm9tIGl0XG4gICAgaWYgKFxuICAgIG9sZFN0YXRlLnN0YXR1cyA9PT0gQXVkaW9QbGF5ZXJTdGF0dXMuQnVmZmVyaW5nICYmIChcbiAgICBuZXdTdGF0ZS5zdGF0dXMgIT09IEF1ZGlvUGxheWVyU3RhdHVzLkJ1ZmZlcmluZyB8fCBuZXdTdGF0ZS5yZXNvdXJjZSAhPT0gb2xkU3RhdGUucmVzb3VyY2UpKVxuICAgIHtcbiAgICAgIG9sZFN0YXRlLnJlc291cmNlLnBsYXlTdHJlYW0ub2ZmKCdlbmQnLCBvbGRTdGF0ZS5vbkZhaWx1cmVDYWxsYmFjayk7XG4gICAgICBvbGRTdGF0ZS5yZXNvdXJjZS5wbGF5U3RyZWFtLm9mZignY2xvc2UnLCBvbGRTdGF0ZS5vbkZhaWx1cmVDYWxsYmFjayk7XG4gICAgICBvbGRTdGF0ZS5yZXNvdXJjZS5wbGF5U3RyZWFtLm9mZignZmluaXNoJywgb2xkU3RhdGUub25GYWlsdXJlQ2FsbGJhY2spO1xuICAgICAgb2xkU3RhdGUucmVzb3VyY2UucGxheVN0cmVhbS5vZmYoJ3JlYWRhYmxlJywgb2xkU3RhdGUub25SZWFkYWJsZUNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICAvLyB0cmFuc2l0aW9uaW5nIGludG8gYW4gaWRsZSBzaG91bGQgZW5zdXJlIHRoYXQgY29ubmVjdGlvbnMgc3RvcCBzcGVha2luZ1xuICAgIGlmIChuZXdTdGF0ZS5zdGF0dXMgPT09IEF1ZGlvUGxheWVyU3RhdHVzLklkbGUpIHtcbiAgICAgIHRoaXMuX3NpZ25hbFN0b3BTcGVha2luZygpO1xuICAgICAgZGVsZXRlQXVkaW9QbGF5ZXIodGhpcyk7XG4gICAgfVxuXG4gICAgLy8gYXR0YWNoIHRvIHRoZSBnbG9iYWwgYXVkaW8gcGxheWVyIHRpbWVyXG4gICAgaWYgKG5ld1Jlc291cmNlKSB7XG4gICAgICBhZGRBdWRpb1BsYXllcih0aGlzKTtcbiAgICB9XG5cbiAgICAvLyBwbGF5aW5nIC0+IHBsYXlpbmcgc3RhdGUgY2hhbmdlcyBzaG91bGQgc3RpbGwgdHJhbnNpdGlvbiBpZiBhIHJlc291cmNlIGNoYW5nZWQgKHNlZW1zIGxpa2UgaXQgd291bGQgYmUgdXNlZnVsISlcbiAgICBjb25zdCBkaWRDaGFuZ2VSZXNvdXJjZXMgPVxuICAgIG9sZFN0YXRlLnN0YXR1cyAhPT0gQXVkaW9QbGF5ZXJTdGF0dXMuSWRsZSAmJlxuICAgIG5ld1N0YXRlLnN0YXR1cyA9PT0gQXVkaW9QbGF5ZXJTdGF0dXMuUGxheWluZyAmJlxuICAgIG9sZFN0YXRlLnJlc291cmNlICE9PSBuZXdTdGF0ZS5yZXNvdXJjZTtcblxuICAgIHRoaXMuX3N0YXRlID0gbmV3U3RhdGU7XG5cbiAgICB0aGlzLmVtaXQoJ3N0YXRlQ2hhbmdlJywgb2xkU3RhdGUsIHRoaXMuX3N0YXRlKTtcbiAgICBpZiAob2xkU3RhdGUuc3RhdHVzICE9PSBuZXdTdGF0ZS5zdGF0dXMgfHwgZGlkQ2hhbmdlUmVzb3VyY2VzKSB7XG4gICAgICB0aGlzLmVtaXQobmV3U3RhdGUuc3RhdHVzLCBvbGRTdGF0ZSwgdGhpcy5fc3RhdGUgYXMgdW5zYWZlKTtcbiAgICB9XG5cbiAgICB0aGlzLmRlYnVnPy4oYHN0YXRlIGNoYW5nZTpcXG5mcm9tICR7c3RyaW5naWZ5U3RhdGUob2xkU3RhdGUpfVxcbnRvICR7c3RyaW5naWZ5U3RhdGUobmV3U3RhdGUpfWApO1xuICB9XG5cbiAgLyoqXG4gICAqIFBsYXlzIGEgbmV3IHJlc291cmNlIG9uIHRoZSBwbGF5ZXIuIElmIHRoZSBwbGF5ZXIgaXMgYWxyZWFkeSBwbGF5aW5nIGEgcmVzb3VyY2UsIHRoZSBleGlzdGluZyByZXNvdXJjZSBpcyBkZXN0cm95ZWRcbiAgICogKGl0IGNhbm5vdCBiZSByZXVzZWQsIGV2ZW4gaW4gYW5vdGhlciBwbGF5ZXIpIGFuZCBpcyByZXBsYWNlZCB3aXRoIHRoZSBuZXcgcmVzb3VyY2UuXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIFRoZSBwbGF5ZXIgd2lsbCB0cmFuc2l0aW9uIHRvIHRoZSBQbGF5aW5nIHN0YXRlIG9uY2UgcGxheWJhY2sgYmVnaW5zLCBhbmQgd2lsbCByZXR1cm4gdG8gdGhlIElkbGUgc3RhdGUgb25jZVxuICAgKiBwbGF5YmFjayBpcyBlbmRlZC5cbiAgICpcbiAgICogSWYgdGhlIHBsYXllciB3YXMgcHJldmlvdXNseSBwbGF5aW5nIGEgcmVzb3VyY2UgYW5kIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCwgdGhlIHBsYXllciB3aWxsIG5vdCB0cmFuc2l0aW9uIHRvIHRoZVxuICAgKiBJZGxlIHN0YXRlIGR1cmluZyB0aGUgc3dhcCBvdmVyLlxuICAgKiBAcGFyYW0gcmVzb3VyY2UgLSBUaGUgcmVzb3VyY2UgdG8gcGxheVxuICAgKiBAdGhyb3dzIFdpbGwgdGhyb3cgaWYgYXR0ZW1wdGluZyB0byBwbGF5IGFuIGF1ZGlvIHJlc291cmNlIHRoYXQgaGFzIGFscmVhZHkgZW5kZWQsIG9yIGlzIGJlaW5nIHBsYXllZCBieSBhbm90aGVyIHBsYXllclxuICAgKi9cbiAgcHVibGljIHBsYXk8TWV0YWRhdGE+KHJlc291cmNlOiBBdWRpb1Jlc291cmNlPE1ldGFkYXRhPikge1xuICAgIGlmIChyZXNvdXJjZS5lbmRlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcGxheSBhIHJlc291cmNlIHRoYXQgaGFzIGFscmVhZHkgZW5kZWQuJyk7XG4gICAgfVxuXG4gICAgaWYgKHJlc291cmNlLmF1ZGlvUGxheWVyKSB7XG4gICAgICBpZiAocmVzb3VyY2UuYXVkaW9QbGF5ZXIgPT09IHRoaXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc291cmNlIGlzIGFscmVhZHkgYmVpbmcgcGxheWVkIGJ5IGFub3RoZXIgYXVkaW8gcGxheWVyLicpO1xuICAgIH1cblxuICAgIHJlc291cmNlLmF1ZGlvUGxheWVyID0gdGhpcztcblxuICAgIC8vIEF0dGFjaCBlcnJvciBsaXN0ZW5lcnMgdG8gdGhlIHN0cmVhbSB0aGF0IHdpbGwgcHJvcGFnYXRlIHRoZSBlcnJvciBhbmQgdGhlbiByZXR1cm4gdG8gdGhlIElkbGVcbiAgICAvLyBzdGF0ZSBpZiB0aGUgcmVzb3VyY2UgaXMgc3RpbGwgYmVpbmcgdXNlZC5cbiAgICBjb25zdCBvblN0cmVhbUVycm9yID0gKGVycm9yOiBFcnJvcikgPT4ge1xuICAgICAgaWYgKHRoaXMuc3RhdGUuc3RhdHVzICE9PSBBdWRpb1BsYXllclN0YXR1cy5JZGxlKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgQXVkaW9QbGF5ZXJFcnJvcihlcnJvciwgdGhpcy5zdGF0ZS5yZXNvdXJjZSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zdGF0ZS5zdGF0dXMgIT09IEF1ZGlvUGxheWVyU3RhdHVzLklkbGUgJiYgdGhpcy5zdGF0ZS5yZXNvdXJjZSA9PT0gcmVzb3VyY2UpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICBzdGF0dXM6IEF1ZGlvUGxheWVyU3RhdHVzLklkbGVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmVzb3VyY2UucGxheVN0cmVhbS5vbmNlKCdlcnJvcicsIG9uU3RyZWFtRXJyb3IpO1xuXG4gICAgaWYgKHJlc291cmNlLnN0YXJ0ZWQpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgIHN0YXR1czogQXVkaW9QbGF5ZXJTdGF0dXMuUGxheWluZyxcbiAgICAgICAgbWlzc2VkRnJhbWVzOiAwLFxuICAgICAgICBwbGF5YmFja0R1cmF0aW9uOiAwLFxuICAgICAgICByZXNvdXJjZSxcbiAgICAgICAgb25TdHJlYW1FcnJvclxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgb25SZWFkYWJsZUNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5zdGF0dXMgPT09IEF1ZGlvUGxheWVyU3RhdHVzLkJ1ZmZlcmluZyAmJiB0aGlzLnN0YXRlLnJlc291cmNlID09PSByZXNvdXJjZSkge1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBzdGF0dXM6IEF1ZGlvUGxheWVyU3RhdHVzLlBsYXlpbmcsXG4gICAgICAgICAgICBtaXNzZWRGcmFtZXM6IDAsXG4gICAgICAgICAgICBwbGF5YmFja0R1cmF0aW9uOiAwLFxuICAgICAgICAgICAgcmVzb3VyY2UsXG4gICAgICAgICAgICBvblN0cmVhbUVycm9yXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgY29uc3Qgb25GYWlsdXJlQ2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnN0YXR1cyA9PT0gQXVkaW9QbGF5ZXJTdGF0dXMuQnVmZmVyaW5nICYmIHRoaXMuc3RhdGUucmVzb3VyY2UgPT09IHJlc291cmNlKSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHN0YXR1czogQXVkaW9QbGF5ZXJTdGF0dXMuSWRsZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHJlc291cmNlLnBsYXlTdHJlYW0ub25jZSgncmVhZGFibGUnLCBvblJlYWRhYmxlQ2FsbGJhY2spO1xuXG4gICAgICByZXNvdXJjZS5wbGF5U3RyZWFtLm9uY2UoJ2VuZCcsIG9uRmFpbHVyZUNhbGxiYWNrKTtcbiAgICAgIHJlc291cmNlLnBsYXlTdHJlYW0ub25jZSgnY2xvc2UnLCBvbkZhaWx1cmVDYWxsYmFjayk7XG4gICAgICByZXNvdXJjZS5wbGF5U3RyZWFtLm9uY2UoJ2ZpbmlzaCcsIG9uRmFpbHVyZUNhbGxiYWNrKTtcblxuICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgc3RhdHVzOiBBdWRpb1BsYXllclN0YXR1cy5CdWZmZXJpbmcsXG4gICAgICAgIHJlc291cmNlLFxuICAgICAgICBvblJlYWRhYmxlQ2FsbGJhY2ssXG4gICAgICAgIG9uRmFpbHVyZUNhbGxiYWNrLFxuICAgICAgICBvblN0cmVhbUVycm9yXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQYXVzZXMgcGxheWJhY2sgb2YgdGhlIGN1cnJlbnQgcmVzb3VyY2UsIGlmIGFueS5cbiAgICpcbiAgICogQHBhcmFtIGludGVycG9sYXRlU2lsZW5jZSAtIElmIHRydWUsIHRoZSBwbGF5ZXIgd2lsbCBwbGF5IDUgcGFja2V0cyBvZiBzaWxlbmNlIGFmdGVyIHBhdXNpbmcgdG8gcHJldmVudCBhdWRpbyBnbGl0Y2hlc1xuICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHBsYXllciB3YXMgc3VjY2Vzc2Z1bGx5IHBhdXNlZCwgb3RoZXJ3aXNlIGBmYWxzZWBcbiAgICovXG4gIHB1YmxpYyBwYXVzZShpbnRlcnBvbGF0ZVNpbGVuY2UgPSB0cnVlKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUuc3RhdHVzICE9PSBBdWRpb1BsYXllclN0YXR1cy5QbGF5aW5nKSByZXR1cm4gZmFsc2U7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIC4uLnRoaXMuc3RhdGUsXG4gICAgICBzdGF0dXM6IEF1ZGlvUGxheWVyU3RhdHVzLlBhdXNlZCxcbiAgICAgIHNpbGVuY2VQYWNrZXRzUmVtYWluaW5nOiBpbnRlcnBvbGF0ZVNpbGVuY2UgPyA1IDogMFxuICAgIH07XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogVW5wYXVzZXMgcGxheWJhY2sgb2YgdGhlIGN1cnJlbnQgcmVzb3VyY2UsIGlmIGFueS5cbiAgICpcbiAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBwbGF5ZXIgd2FzIHN1Y2Nlc3NmdWxseSB1bnBhdXNlZCwgb3RoZXJ3aXNlIGBmYWxzZWBcbiAgICovXG4gIHB1YmxpYyB1bnBhdXNlKCkge1xuICAgIGlmICh0aGlzLnN0YXRlLnN0YXR1cyAhPT0gQXVkaW9QbGF5ZXJTdGF0dXMuUGF1c2VkKSByZXR1cm4gZmFsc2U7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIC4uLnRoaXMuc3RhdGUsXG4gICAgICBzdGF0dXM6IEF1ZGlvUGxheWVyU3RhdHVzLlBsYXlpbmcsXG4gICAgICBtaXNzZWRGcmFtZXM6IDBcbiAgICB9O1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3BzIHBsYXliYWNrIG9mIHRoZSBjdXJyZW50IHJlc291cmNlIGFuZCBkZXN0cm95cyB0aGUgcmVzb3VyY2UuIFRoZSBwbGF5ZXIgd2lsbCBlaXRoZXIgdHJhbnNpdGlvbiB0byB0aGUgSWRsZSBzdGF0ZSxcbiAgICogb3IgcmVtYWluIGluIGl0cyBjdXJyZW50IHN0YXRlIHVudGlsIHRoZSBzaWxlbmNlIHBhZGRpbmcgZnJhbWVzIG9mIHRoZSByZXNvdXJjZSBoYXZlIGJlZW4gcGxheWVkLlxuICAgKlxuICAgKiBAcGFyYW0gZm9yY2UgLSBJZiB0cnVlLCB3aWxsIGZvcmNlIHRoZSBwbGF5ZXIgdG8gZW50ZXIgdGhlIElkbGUgc3RhdGUgZXZlbiBpZiB0aGUgcmVzb3VyY2UgaGFzIHNpbGVuY2UgcGFkZGluZyBmcmFtZXNcbiAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBwbGF5ZXIgd2lsbCBjb21lIHRvIGEgc3RvcCwgb3RoZXJ3aXNlIGBmYWxzZWBcbiAgICovXG4gIHB1YmxpYyBzdG9wKGZvcmNlID0gZmFsc2UpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5zdGF0dXMgPT09IEF1ZGlvUGxheWVyU3RhdHVzLklkbGUpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZm9yY2UgfHwgdGhpcy5zdGF0ZS5yZXNvdXJjZS5zaWxlbmNlUGFkZGluZ0ZyYW1lcyA9PT0gMCkge1xuICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgc3RhdHVzOiBBdWRpb1BsYXllclN0YXR1cy5JZGxlXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZS5yZXNvdXJjZS5zaWxlbmNlUmVtYWluaW5nID09PSAtMSkge1xuICAgICAgdGhpcy5zdGF0ZS5yZXNvdXJjZS5zaWxlbmNlUmVtYWluaW5nID0gdGhpcy5zdGF0ZS5yZXNvdXJjZS5zaWxlbmNlUGFkZGluZ0ZyYW1lcztcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciB0aGUgdW5kZXJseWluZyByZXNvdXJjZSAoaWYgYW55KSBpcyBwbGF5YWJsZSAocmVhZGFibGUpXG4gICAqXG4gICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgcmVzb3VyY2UgaXMgcGxheWFibGUsIG90aGVyd2lzZSBgZmFsc2VgXG4gICAqL1xuICBwdWJsaWMgY2hlY2tQbGF5YWJsZSgpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX3N0YXRlO1xuICAgIGlmIChzdGF0ZS5zdGF0dXMgPT09IEF1ZGlvUGxheWVyU3RhdHVzLklkbGUgfHwgc3RhdGUuc3RhdHVzID09PSBBdWRpb1BsYXllclN0YXR1cy5CdWZmZXJpbmcpIHJldHVybiBmYWxzZTtcblxuICAgIC8vIElmIHRoZSBzdHJlYW0gaGFzIGJlZW4gZGVzdHJveWVkIG9yIGlzIG5vIGxvbmdlciByZWFkYWJsZSwgdGhlbiB0cmFuc2l0aW9uIHRvIHRoZSBJZGxlIHN0YXRlLlxuICAgIGlmICghc3RhdGUucmVzb3VyY2UucmVhZGFibGUpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgIHN0YXR1czogQXVkaW9QbGF5ZXJTdGF0dXMuSWRsZVxuICAgICAgfTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgcm91Z2hseSBldmVyeSAyMG1zIGJ5IHRoZSBnbG9iYWwgYXVkaW8gcGxheWVyIHRpbWVyLiBEaXNwYXRjaGVzIGFueSBhdWRpbyBwYWNrZXRzIHRoYXQgYXJlIGJ1ZmZlcmVkXG4gICAqIGJ5IHRoZSBhY3RpdmUgY29ubmVjdGlvbnMgb2YgdGhpcyBhdWRpbyBwbGF5ZXIuXG4gICAqL1xuICAvLyBAdHMtaWdub3JlXG4gIHByaXZhdGUgX3N0ZXBEaXNwYXRjaCgpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX3N0YXRlO1xuXG4gICAgLy8gR3VhcmQgYWdhaW5zdCB0aGUgSWRsZSBzdGF0ZVxuICAgIGlmIChzdGF0ZS5zdGF0dXMgPT09IEF1ZGlvUGxheWVyU3RhdHVzLklkbGUgfHwgc3RhdGUuc3RhdHVzID09PSBBdWRpb1BsYXllclN0YXR1cy5CdWZmZXJpbmcpIHJldHVybjtcblxuICAgIC8vIERpc3BhdGNoIGFueSBhdWRpbyBwYWNrZXRzIHRoYXQgd2VyZSBwcmVwYXJlZCBpbiB0aGUgcHJldmlvdXMgY3ljbGVcbiAgICBmb3IgKGNvbnN0IGNvbm5lY3Rpb24gb2YgdGhpcy5wbGF5YWJsZSkge1xuICAgICAgY29ubmVjdGlvbi5kaXNwYXRjaEF1ZGlvKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCByb3VnaGx5IGV2ZXJ5IDIwbXMgYnkgdGhlIGdsb2JhbCBhdWRpbyBwbGF5ZXIgdGltZXIuIEF0dGVtcHRzIHRvIHJlYWQgYW4gYXVkaW8gcGFja2V0IGZyb20gdGhlXG4gICAqIHVuZGVybHlpbmcgcmVzb3VyY2Ugb2YgdGhlIHN0cmVhbSwgYW5kIHRoZW4gaGFzIGFsbCB0aGUgYWN0aXZlIGNvbm5lY3Rpb25zIG9mIHRoZSBhdWRpbyBwbGF5ZXIgcHJlcGFyZSBpdFxuICAgKiAoZW5jcnlwdCBpdCwgYXBwZW5kIGhlYWRlciBkYXRhKSBzbyB0aGF0IGl0IGlzIHJlYWR5IHRvIHBsYXkgYXQgdGhlIHN0YXJ0IG9mIHRoZSBuZXh0IGN5Y2xlLlxuICAgKi9cbiAgLy8gQHRzLWlnbm9yZVxuICBwcml2YXRlIF9zdGVwUHJlcGFyZSgpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX3N0YXRlO1xuXG4gICAgLy8gR3VhcmQgYWdhaW5zdCB0aGUgSWRsZSBzdGF0ZVxuICAgIGlmIChzdGF0ZS5zdGF0dXMgPT09IEF1ZGlvUGxheWVyU3RhdHVzLklkbGUgfHwgc3RhdGUuc3RhdHVzID09PSBBdWRpb1BsYXllclN0YXR1cy5CdWZmZXJpbmcpIHJldHVybjtcblxuICAgIC8vIExpc3Qgb2YgY29ubmVjdGlvbnMgdGhhdCBjYW4gcmVjZWl2ZSB0aGUgcGFja2V0XG4gICAgY29uc3QgcGxheWFibGUgPSB0aGlzLnBsYXlhYmxlO1xuXG4gICAgLyogSWYgdGhlIHBsYXllciB3YXMgcHJldmlvdXNseSBpbiB0aGUgQXV0b1BhdXNlZCBzdGF0ZSwgY2hlY2sgdG8gc2VlIHdoZXRoZXIgdGhlcmUgYXJlIG5ld2x5IGF2YWlsYWJsZVxuICAgICBjb25uZWN0aW9ucywgYWxsb3dpbmcgdXMgdG8gdHJhbnNpdGlvbiBvdXQgb2YgdGhlIEF1dG9QYXVzZWQgc3RhdGUgYmFjayBpbnRvIHRoZSBQbGF5aW5nIHN0YXRlICovXG4gICAgaWYgKHN0YXRlLnN0YXR1cyA9PT0gQXVkaW9QbGF5ZXJTdGF0dXMuQXV0b1BhdXNlZCAmJiBwbGF5YWJsZS5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgc3RhdHVzOiBBdWRpb1BsYXllclN0YXR1cy5QbGF5aW5nLFxuICAgICAgICBtaXNzZWRGcmFtZXM6IDBcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyogSWYgdGhlIHBsYXllciBpcyAoYXV0bylwYXVzZWQsIGNoZWNrIHRvIHNlZSB3aGV0aGVyIHNpbGVuY2UgcGFja2V0cyBzaG91bGQgYmUgcGxheWVkIGFuZFxuICAgICBzZXQgYSB0aW1lb3V0IHRvIGJlZ2luIHRoZSBuZXh0IGN5Y2xlLCBlbmRpbmcgdGhlIGN1cnJlbnQgY3ljbGUgaGVyZS4gKi9cbiAgICBpZiAoc3RhdGUuc3RhdHVzID09PSBBdWRpb1BsYXllclN0YXR1cy5QYXVzZWQgfHwgc3RhdGUuc3RhdHVzID09PSBBdWRpb1BsYXllclN0YXR1cy5BdXRvUGF1c2VkKSB7XG4gICAgICBpZiAoc3RhdGUuc2lsZW5jZVBhY2tldHNSZW1haW5pbmcgPiAwKSB7XG4gICAgICAgIHN0YXRlLnNpbGVuY2VQYWNrZXRzUmVtYWluaW5nLS07XG4gICAgICAgIHRoaXMuX3ByZXBhcmVQYWNrZXQoU0lMRU5DRV9GUkFNRSwgcGxheWFibGUsIHN0YXRlKTtcbiAgICAgICAgaWYgKHN0YXRlLnNpbGVuY2VQYWNrZXRzUmVtYWluaW5nID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fc2lnbmFsU3RvcFNwZWFraW5nKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIElmIHRoZXJlIGFyZSBubyBhdmFpbGFibGUgY29ubmVjdGlvbnMgaW4gdGhpcyBjeWNsZSwgb2JzZXJ2ZSB0aGUgY29uZmlndXJlZCBcIm5vIHN1YnNjcmliZXJcIiBiZWhhdmlvci5cbiAgICBpZiAocGxheWFibGUubGVuZ3RoID09PSAwKSB7XG4gICAgICBpZiAodGhpcy5iZWhhdmlvcnMubm9TdWJzY3JpYmVyID09PSBOb1N1YnNjcmliZXJCZWhhdmlvci5QYXVzZSkge1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgIHN0YXR1czogQXVkaW9QbGF5ZXJTdGF0dXMuQXV0b1BhdXNlZCxcbiAgICAgICAgICBzaWxlbmNlUGFja2V0c1JlbWFpbmluZzogNVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuYmVoYXZpb3JzLm5vU3Vic2NyaWJlciA9PT0gTm9TdWJzY3JpYmVyQmVoYXZpb3IuU3RvcCkge1xuICAgICAgICB0aGlzLnN0b3AodHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXR0ZW1wdCB0byByZWFkIGFuIE9wdXMgcGFja2V0IGZyb20gdGhlIHJlc291cmNlLiBJZiB0aGVyZSBpc24ndCBhbiBhdmFpbGFibGUgcGFja2V0LFxuICAgICAqIHBsYXkgYSBzaWxlbmNlIHBhY2tldC4gSWYgdGhlcmUgYXJlIDUgY29uc2VjdXRpdmUgY3ljbGVzIHdpdGggZmFpbGVkIHJlYWRzLCB0aGVuIHRoZVxuICAgICAqIHBsYXliYWNrIHdpbGwgZW5kLlxuICAgICAqL1xuICAgIGNvbnN0IHBhY2tldDogQnVmZmVyIHwgbnVsbCA9IHN0YXRlLnJlc291cmNlLnJlYWQoKTtcblxuICAgIGlmIChzdGF0ZS5zdGF0dXMgPT09IEF1ZGlvUGxheWVyU3RhdHVzLlBsYXlpbmcpIHtcbiAgICAgIGlmIChwYWNrZXQpIHtcbiAgICAgICAgdGhpcy5fcHJlcGFyZVBhY2tldChwYWNrZXQsIHBsYXlhYmxlLCBzdGF0ZSk7XG4gICAgICAgIHN0YXRlLm1pc3NlZEZyYW1lcyA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9wcmVwYXJlUGFja2V0KFNJTEVOQ0VfRlJBTUUsIHBsYXlhYmxlLCBzdGF0ZSk7XG4gICAgICAgIHN0YXRlLm1pc3NlZEZyYW1lcysrO1xuICAgICAgICBpZiAoc3RhdGUubWlzc2VkRnJhbWVzID49IHRoaXMuYmVoYXZpb3JzLm1heE1pc3NlZEZyYW1lcykge1xuICAgICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNpZ25hbHMgdG8gYWxsIHRoZSBzdWJzY3JpYmVkIGNvbm5lY3Rpb25zIHRoYXQgdGhleSBzaG91bGQgc2VuZCBhIHBhY2tldCB0byBEaXNjb3JkIGluZGljYXRpbmdcbiAgICogdGhleSBhcmUgbm8gbG9uZ2VyIHNwZWFraW5nLiBDYWxsZWQgb25jZSBwbGF5YmFjayBvZiBhIHJlc291cmNlIGVuZHMuXG4gICAqL1xuICBwcml2YXRlIF9zaWduYWxTdG9wU3BlYWtpbmcoKSB7XG4gICAgZm9yIChjb25zdCB7IGNvbm5lY3Rpb24gfSBvZiB0aGlzLnN1YnNjcmliZXJzKSB7XG4gICAgICBjb25uZWN0aW9uLnNldFNwZWFraW5nKGZhbHNlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5zdHJ1Y3RzIHRoZSBnaXZlbiBjb25uZWN0aW9ucyB0byBlYWNoIHByZXBhcmUgdGhpcyBwYWNrZXQgdG8gYmUgcGxheWVkIGF0IHRoZSBzdGFydCBvZiB0aGVcbiAgICogbmV4dCBjeWNsZS5cbiAgICpcbiAgICogQHBhcmFtIHBhY2tldCAtIFRoZSBPcHVzIHBhY2tldCB0byBiZSBwcmVwYXJlZCBieSBlYWNoIHJlY2VpdmVyXG4gICAqIEBwYXJhbSByZWNlaXZlcnMgLSBUaGUgY29ubmVjdGlvbnMgdGhhdCBzaG91bGQgcGxheSB0aGlzIHBhY2tldFxuICAgKi9cbiAgcHJpdmF0ZSBfcHJlcGFyZVBhY2tldChcbiAgcGFja2V0OiBCdWZmZXIsXG4gIHJlY2VpdmVyczogVm9pY2VDb25uZWN0aW9uW10sXG4gIHN0YXRlOiBBdWRpb1BsYXllclBhdXNlZFN0YXRlIHwgQXVkaW9QbGF5ZXJQbGF5aW5nU3RhdGUpXG4gIHtcbiAgICBzdGF0ZS5wbGF5YmFja0R1cmF0aW9uICs9IDIwO1xuICAgIGZvciAoY29uc3QgY29ubmVjdGlvbiBvZiByZWNlaXZlcnMpIHtcbiAgICAgIGNvbm5lY3Rpb24ucHJlcGFyZUF1ZGlvUGFja2V0KHBhY2tldCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBBdWRpb1BsYXllciB0byBiZSB1c2VkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQXVkaW9QbGF5ZXIob3B0aW9ucz86IENyZWF0ZUF1ZGlvUGxheWVyT3B0aW9ucykge1xuICByZXR1cm4gbmV3IEF1ZGlvUGxheWVyKG9wdGlvbnMpO1xufSIsICIvLyBDb3B5cmlnaHQgZGlzY29yZC1wbGF5ZXIgYXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC4gTUlUIExpY2Vuc2UuXG4vLyBDb3B5cmlnaHQgZGlzY29yZC5qcyBhdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLiBBcGFjaGUgTGljZW5zZSAyLjBcblxuaW1wb3J0IHR5cGUgeyBBdWRpb1Jlc291cmNlIH0gZnJvbSAnLi9BdWRpb1Jlc291cmNlJztcblxuLyoqXG4gKiBBbiBlcnJvciBlbWl0dGVkIGJ5IGFuIEF1ZGlvUGxheWVyLiBDb250YWlucyBhbiBhdHRhY2hlZCByZXNvdXJjZSB0byBhaWQgd2l0aFxuICogZGVidWdnaW5nIGFuZCBpZGVudGlmeWluZyB3aGVyZSB0aGUgZXJyb3IgY2FtZSBmcm9tLlxuICovXG5leHBvcnQgY2xhc3MgQXVkaW9QbGF5ZXJFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgLyoqXG4gICAqIFRoZSByZXNvdXJjZSBhc3NvY2lhdGVkIHdpdGggdGhlIGF1ZGlvIHBsYXllciBhdCB0aGUgdGltZSB0aGUgZXJyb3Igd2FzIHRocm93bi5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSByZXNvdXJjZTogQXVkaW9SZXNvdXJjZTtcblxuICBwdWJsaWMgY29uc3RydWN0b3IoZXJyb3I6IEVycm9yLCByZXNvdXJjZTogQXVkaW9SZXNvdXJjZSkge1xuICAgIHN1cGVyKGVycm9yLm1lc3NhZ2UpO1xuICAgIHRoaXMucmVzb3VyY2UgPSByZXNvdXJjZTtcbiAgICB0aGlzLm5hbWUgPSBlcnJvci5uYW1lO1xuICAgIHRoaXMuc3RhY2sgPSBlcnJvci5zdGFjayE7XG4gIH1cbn0iLCAiLy8gQ29weXJpZ2h0IGRpc2NvcmQtcGxheWVyIGF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuIE1JVCBMaWNlbnNlLlxuLy8gQ29weXJpZ2h0IGRpc2NvcmQuanMgYXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC4gQXBhY2hlIExpY2Vuc2UgMi4wXG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9kb3Qtbm90YXRpb24gKi9cbmltcG9ydCB0eXBlIHsgVm9pY2VDb25uZWN0aW9uIH0gZnJvbSAnLi4vVm9pY2VDb25uZWN0aW9uJztcbmltcG9ydCB0eXBlIHsgQXVkaW9QbGF5ZXIgfSBmcm9tICcuL0F1ZGlvUGxheWVyJztcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgc3Vic2NyaXB0aW9uIG9mIGEgdm9pY2UgY29ubmVjdGlvbiB0byBhbiBhdWRpbyBwbGF5ZXIsIGFsbG93aW5nXG4gKiB0aGUgYXVkaW8gcGxheWVyIHRvIHBsYXkgYXVkaW8gb24gdGhlIHZvaWNlIGNvbm5lY3Rpb24uXG4gKi9cbmV4cG9ydCBjbGFzcyBQbGF5ZXJTdWJzY3JpcHRpb24ge1xuICAvKipcbiAgICogVGhlIHZvaWNlIGNvbm5lY3Rpb24gb2YgdGhpcyBzdWJzY3JpcHRpb24uXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgY29ubmVjdGlvbjogVm9pY2VDb25uZWN0aW9uO1xuXG4gIC8qKlxuICAgKiBUaGUgYXVkaW8gcGxheWVyIG9mIHRoaXMgc3Vic2NyaXB0aW9uLlxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IHBsYXllcjogQXVkaW9QbGF5ZXI7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKGNvbm5lY3Rpb246IFZvaWNlQ29ubmVjdGlvbiwgcGxheWVyOiBBdWRpb1BsYXllcikge1xuICAgIHRoaXMuY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XG4gICAgdGhpcy5wbGF5ZXIgPSBwbGF5ZXI7XG4gIH1cblxuICAvKipcbiAgICogVW5zdWJzY3JpYmVzIHRoZSBjb25uZWN0aW9uIGZyb20gdGhlIGF1ZGlvIHBsYXllciwgbWVhbmluZyB0aGF0IHRoZVxuICAgKiBhdWRpbyBwbGF5ZXIgY2Fubm90IHN0cmVhbSBhdWRpbyB0byBpdCB1bnRpbCBhIG5ldyBzdWJzY3JpcHRpb24gaXMgbWFkZS5cbiAgICovXG4gIHB1YmxpYyB1bnN1YnNjcmliZSgpIHtcbiAgICB0aGlzLmNvbm5lY3Rpb25bJ29uU3Vic2NyaXB0aW9uUmVtb3ZlZCddKHRoaXMpO1xuICAgIHRoaXMucGxheWVyWyd1bnN1YnNjcmliZSddKHRoaXMpO1xuICB9XG59IiwgIi8vIENvcHlyaWdodCBkaXNjb3JkLXBsYXllciBhdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLiBNSVQgTGljZW5zZS5cbi8vIENvcHlyaWdodCBkaXNjb3JkLmpzIGF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuIEFwYWNoZSBMaWNlbnNlIDIuMFxuXG5pbXBvcnQgdHlwZSB7IEJ1ZmZlciB9IGZyb20gJ25vZGU6YnVmZmVyJztcbmltcG9ydCB7IHBpcGVsaW5lLCB0eXBlIFJlYWRhYmxlIH0gZnJvbSAnbm9kZTpzdHJlYW0nO1xuaW1wb3J0IHsgbm9vcCB9IGZyb20gJy4uL3V0aWwvdXRpbCc7XG5pbXBvcnQgeyBTSUxFTkNFX0ZSQU1FLCB0eXBlIEF1ZGlvUGxheWVyIH0gZnJvbSAnLi9BdWRpb1BsYXllcic7XG5pbXBvcnQgeyBmaW5kUGlwZWxpbmUsIFN0cmVhbVR5cGUsIFRyYW5zZm9ybWVyVHlwZSwgdHlwZSBFZGdlIH0gZnJvbSAnLi9UcmFuc2Zvcm1lckdyYXBoJztcbmltcG9ydCB7IE9nZ0RlbXV4ZXIsIE9wdXNEZWNvZGVyLCBPcHVzRW5jb2RlciwgV2VibURlbXV4ZXIgfSBmcm9tICdAZGlzY29yZC1wbGF5ZXIvb3B1cyc7XG5pbXBvcnQgeyBWb2x1bWVUcmFuc2Zvcm1lciB9IGZyb20gJ0BkaXNjb3JkLXBsYXllci9lcXVhbGl6ZXInO1xuXG4vKipcbiAqIE9wdGlvbnMgdGhhdCBhcmUgc2V0IHdoZW4gY3JlYXRpbmcgYSBuZXcgYXVkaW8gcmVzb3VyY2UuXG4gKlxuICogQHR5cGVQYXJhbSBNZXRhZGF0YSAtIHRoZSB0eXBlIGZvciB0aGUgbWV0YWRhdGEgKGlmIGFueSkgb2YgdGhlIGF1ZGlvIHJlc291cmNlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ3JlYXRlQXVkaW9SZXNvdXJjZU9wdGlvbnM8TWV0YWRhdGE+IHtcbiAgLyoqXG4gICAqIFdoZXRoZXIgb3Igbm90IGlubGluZSB2b2x1bWUgc2hvdWxkIGJlIGVuYWJsZWQuIElmIGVuYWJsZWQsIHlvdSB3aWxsIGJlIGFibGUgdG8gY2hhbmdlIHRoZSB2b2x1bWVcbiAgICogb2YgdGhlIHN0cmVhbSBvbi10aGUtZmx5LiBIb3dldmVyLCB0aGlzIGFsc28gaW5jcmVhc2VzIHRoZSBwZXJmb3JtYW5jZSBjb3N0IG9mIHBsYXliYWNrLiBEZWZhdWx0cyB0byBgZmFsc2VgLlxuICAgKi9cbiAgaW5saW5lVm9sdW1lPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogVGhlIHR5cGUgb2YgdGhlIGlucHV0IHN0cmVhbS4gRGVmYXVsdHMgdG8gYFN0cmVhbVR5cGUuQXJiaXRyYXJ5YC5cbiAgICovXG4gIGlucHV0VHlwZT86IFN0cmVhbVR5cGU7XG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsIG1ldGFkYXRhIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIHRoZSByZXNvdXJjZSAoZS5nLiB0cmFjayB0aXRsZSwgcmFuZG9tIGlkKS5cbiAgICogVGhpcyBpcyB1c2VmdWwgZm9yIGlkZW50aWZpY2F0aW9uIHB1cnBvc2VzIHdoZW4gdGhlIHJlc291cmNlIGlzIHBhc3NlZCBhcm91bmQgaW4gZXZlbnRzLlxuICAgKiBTZWUge0BsaW5rIEF1ZGlvUmVzb3VyY2UubWV0YWRhdGF9XG4gICAqL1xuICBtZXRhZGF0YT86IE1ldGFkYXRhO1xuXG4gIC8qKlxuICAgKiBUaGUgbnVtYmVyIG9mIHNpbGVuY2UgZnJhbWVzIHRvIGFwcGVuZCB0byB0aGUgZW5kIG9mIHRoZSByZXNvdXJjZSdzIGF1ZGlvIHN0cmVhbSwgdG8gcHJldmVudCBpbnRlcnBvbGF0aW9uIGdsaXRjaGVzLlxuICAgKiBEZWZhdWx0cyB0byA1LlxuICAgKi9cbiAgc2lsZW5jZVBhZGRpbmdGcmFtZXM/OiBudW1iZXI7XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhbiBhdWRpbyByZXNvdXJjZSB0aGF0IGNhbiBiZSBwbGF5ZWQgYnkgYW4gYXVkaW8gcGxheWVyLlxuICpcbiAqIEB0eXBlUGFyYW0gTWV0YWRhdGEgLSB0aGUgdHlwZSBmb3IgdGhlIG1ldGFkYXRhIChpZiBhbnkpIG9mIHRoZSBhdWRpbyByZXNvdXJjZVxuICovXG5leHBvcnQgY2xhc3MgQXVkaW9SZXNvdXJjZTxNZXRhZGF0YSA9IHVua25vd24+IHtcbiAgLyoqXG4gICAqIEFuIG9iamVjdC1tb2RlIFJlYWRhYmxlIHN0cmVhbSB0aGF0IGVtaXRzIE9wdXMgcGFja2V0cy4gVGhpcyBpcyB3aGF0IGlzIHBsYXllZCBieSBhdWRpbyBwbGF5ZXJzLlxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IHBsYXlTdHJlYW06IFJlYWRhYmxlO1xuXG4gIC8qKlxuICAgKiBUaGUgcGlwZWxpbmUgdXNlZCB0byBjb252ZXJ0IHRoZSBpbnB1dCBzdHJlYW0gaW50byBhIHBsYXlhYmxlIGZvcm1hdC4gRm9yIGV4YW1wbGUsIHRoaXMgbWF5XG4gICAqIGNvbnRhaW4gYW4gRkZtcGVnIGNvbXBvbmVudCBmb3IgYXJiaXRyYXJ5IGlucHV0cywgYW5kIGl0IG1heSBjb250YWluIGEgVm9sdW1lVHJhbnNmb3JtZXIgY29tcG9uZW50XG4gICAqIGZvciByZXNvdXJjZXMgd2l0aCBpbmxpbmUgdm9sdW1lIHRyYW5zZm9ybWF0aW9uIGVuYWJsZWQuXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgZWRnZXM6IHJlYWRvbmx5IEVkZ2VbXTtcblxuICAvKipcbiAgICogT3B0aW9uYWwgbWV0YWRhdGEgdGhhdCBjYW4gYmUgdXNlZCB0byBpZGVudGlmeSB0aGUgcmVzb3VyY2UuXG4gICAqL1xuICBwdWJsaWMgbWV0YWRhdGE6IE1ldGFkYXRhO1xuXG4gIC8qKlxuICAgKiBJZiB0aGUgcmVzb3VyY2Ugd2FzIGNyZWF0ZWQgd2l0aCBpbmxpbmUgdm9sdW1lIHRyYW5zZm9ybWF0aW9uIGVuYWJsZWQsIHRoZW4gdGhpcyB3aWxsIGJlIGFcbiAgICogYEBkaXNjb3JkLXBsYXllci9lcXVhbGl6ZXJgIFZvbHVtZVRyYW5zZm9ybWVyLiBZb3UgY2FuIHVzZSB0aGlzIHRvIGFsdGVyIHRoZSB2b2x1bWUgb2YgdGhlIHN0cmVhbS5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSB2b2x1bWU/OiBWb2x1bWVUcmFuc2Zvcm1lcjtcblxuICAvKipcbiAgICogSWYgdXNpbmcgYW4gT3B1cyBlbmNvZGVyIHRvIGNyZWF0ZSB0aGlzIGF1ZGlvIHJlc291cmNlLCB0aGVuIHRoaXMgd2lsbCBiZSBhYEBkaXNjb3JkLXBsYXllci9vcHVzYCBvcHVzLkVuY29kZXIuXG4gICAqIFlvdSBjYW4gdXNlIHRoaXMgdG8gY29udHJvbCBzZXR0aW5ncyBzdWNoIGFzIGJpdHJhdGUsIEZFQywgUExQLlxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IGVuY29kZXI/OiBPcHVzRW5jb2RlcjtcblxuICAvKipcbiAgICogVGhlIGF1ZGlvIHBsYXllciB0aGF0IHRoZSByZXNvdXJjZSBpcyBzdWJzY3JpYmVkIHRvLCBpZiBhbnkuXG4gICAqL1xuICBwdWJsaWMgYXVkaW9QbGF5ZXI/OiBBdWRpb1BsYXllciB8IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogVGhlIHBsYXliYWNrIGR1cmF0aW9uIG9mIHRoaXMgYXVkaW8gcmVzb3VyY2UsIGdpdmVuIGluIG1pbGxpc2Vjb25kcy5cbiAgICovXG4gIHB1YmxpYyBwbGF5YmFja0R1cmF0aW9uID0gMDtcblxuICAvKipcbiAgICogV2hldGhlciBvciBub3QgdGhlIHN0cmVhbSBmb3IgdGhpcyByZXNvdXJjZSBoYXMgc3RhcnRlZCAoZGF0YSBoYXMgYmVjb21lIHJlYWRhYmxlKVxuICAgKi9cbiAgcHVibGljIHN0YXJ0ZWQgPSBmYWxzZTtcblxuICAvKipcbiAgICogVGhlIG51bWJlciBvZiBzaWxlbmNlIGZyYW1lcyB0byBhcHBlbmQgdG8gdGhlIGVuZCBvZiB0aGUgcmVzb3VyY2UncyBhdWRpbyBzdHJlYW0sIHRvIHByZXZlbnQgaW50ZXJwb2xhdGlvbiBnbGl0Y2hlcy5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBzaWxlbmNlUGFkZGluZ0ZyYW1lczogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgbnVtYmVyIG9mIHJlbWFpbmluZyBzaWxlbmNlIGZyYW1lcyB0byBwbGF5LiBJZiAtMSwgdGhlIGZyYW1lcyBoYXZlIG5vdCB5ZXQgc3RhcnRlZCBwbGF5aW5nLlxuICAgKi9cbiAgcHVibGljIHNpbGVuY2VSZW1haW5pbmcgPSAtMTtcblxuICBwdWJsaWMgY29uc3RydWN0b3IoXG4gIGVkZ2VzOiByZWFkb25seSBFZGdlW10sXG4gIHN0cmVhbXM6IHJlYWRvbmx5IFJlYWRhYmxlW10sXG4gIG1ldGFkYXRhOiBNZXRhZGF0YSxcbiAgc2lsZW5jZVBhZGRpbmdGcmFtZXM6IG51bWJlcilcbiAge1xuICAgIHRoaXMuZWRnZXMgPSBlZGdlcztcbiAgICB0aGlzLnBsYXlTdHJlYW0gPSBzdHJlYW1zLmxlbmd0aCA+IDEgPyBwaXBlbGluZShzdHJlYW1zLCBub29wKSBhcyB1bmtub3duIGFzIFJlYWRhYmxlIDogc3RyZWFtc1swXSE7XG4gICAgdGhpcy5tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgIHRoaXMuc2lsZW5jZVBhZGRpbmdGcmFtZXMgPSBzaWxlbmNlUGFkZGluZ0ZyYW1lcztcblxuICAgIGZvciAoY29uc3Qgc3RyZWFtIG9mIHN0cmVhbXMpIHtcbiAgICAgIGlmIChzdHJlYW0gaW5zdGFuY2VvZiBWb2x1bWVUcmFuc2Zvcm1lcikge1xuICAgICAgICB0aGlzLnZvbHVtZSA9IHN0cmVhbTtcbiAgICAgIH0gZWxzZSBpZiAoc3RyZWFtIGluc3RhbmNlb2YgT3B1c0VuY29kZXIpIHtcbiAgICAgICAgdGhpcy5lbmNvZGVyID0gc3RyZWFtO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMucGxheVN0cmVhbS5vbmNlKCdyZWFkYWJsZScsICgpID0+IHRoaXMuc3RhcnRlZCA9IHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhpcyByZXNvdXJjZSBpcyByZWFkYWJsZS4gSWYgdGhlIHVuZGVybHlpbmcgcmVzb3VyY2UgaXMgbm8gbG9uZ2VyIHJlYWRhYmxlLCB0aGlzIHdpbGwgc3RpbGwgcmV0dXJuIHRydWVcbiAgICogd2hpbGUgdGhlcmUgYXJlIHNpbGVuY2UgcGFkZGluZyBmcmFtZXMgbGVmdCB0byBwbGF5LlxuICAgKi9cbiAgcHVibGljIGdldCByZWFkYWJsZSgpIHtcbiAgICBpZiAodGhpcy5zaWxlbmNlUmVtYWluaW5nID09PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgcmVhbCA9IHRoaXMucGxheVN0cmVhbS5yZWFkYWJsZTtcbiAgICBpZiAoIXJlYWwpIHtcbiAgICAgIGlmICh0aGlzLnNpbGVuY2VSZW1haW5pbmcgPT09IC0xKSB0aGlzLnNpbGVuY2VSZW1haW5pbmcgPSB0aGlzLnNpbGVuY2VQYWRkaW5nRnJhbWVzO1xuICAgICAgcmV0dXJuIHRoaXMuc2lsZW5jZVJlbWFpbmluZyAhPT0gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVhbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoaXMgcmVzb3VyY2UgaGFzIGVuZGVkIG9yIG5vdC5cbiAgICovXG4gIHB1YmxpYyBnZXQgZW5kZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMucGxheVN0cmVhbS5yZWFkYWJsZUVuZGVkIHx8IHRoaXMucGxheVN0cmVhbS5kZXN0cm95ZWQgfHwgdGhpcy5zaWxlbmNlUmVtYWluaW5nID09PSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEF0dGVtcHRzIHRvIHJlYWQgYW4gT3B1cyBwYWNrZXQgZnJvbSB0aGUgYXVkaW8gcmVzb3VyY2UuIElmIGEgcGFja2V0IGlzIGF2YWlsYWJsZSwgdGhlIHBsYXliYWNrRHVyYXRpb25cbiAgICogaXMgaW5jcmVtZW50ZWQuXG4gICAqXG4gICAqIEByZW1hcmtzXG4gICAqIEl0IGlzIGFkdmlzYWJsZSB0byBjaGVjayB0aGF0IHRoZSBwbGF5U3RyZWFtIGlzIHJlYWRhYmxlIGJlZm9yZSBjYWxsaW5nIHRoaXMgbWV0aG9kLiBXaGlsZSBubyBydW50aW1lXG4gICAqIGVycm9ycyB3aWxsIGJlIHRocm93biwgeW91IHNob3VsZCBjaGVjayB0aGF0IHRoZSByZXNvdXJjZSBpcyBzdGlsbCBhdmFpbGFibGUgYmVmb3JlIGF0dGVtcHRpbmcgdG9cbiAgICogcmVhZCBmcm9tIGl0LlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHB1YmxpYyByZWFkKCk6IEJ1ZmZlciB8IG51bGwge1xuICAgIGlmICh0aGlzLnNpbGVuY2VSZW1haW5pbmcgPT09IDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zaWxlbmNlUmVtYWluaW5nID4gMCkge1xuICAgICAgdGhpcy5zaWxlbmNlUmVtYWluaW5nLS07XG4gICAgICByZXR1cm4gU0lMRU5DRV9GUkFNRTtcbiAgICB9XG5cbiAgICBjb25zdCBwYWNrZXQgPSB0aGlzLnBsYXlTdHJlYW0ucmVhZCgpIGFzIEJ1ZmZlciB8IG51bGw7XG4gICAgaWYgKHBhY2tldCkge1xuICAgICAgdGhpcy5wbGF5YmFja0R1cmF0aW9uICs9IDIwO1xuICAgIH1cblxuICAgIHJldHVybiBwYWNrZXQ7XG4gIH1cbn1cblxuLyoqXG4gKiBFbnN1cmVzIHRoYXQgYSBwYXRoIGNvbnRhaW5zIGF0IGxlYXN0IG9uZSB2b2x1bWUgdHJhbnNmb3JtaW5nIGNvbXBvbmVudC5cbiAqXG4gKiBAcGFyYW0gcGF0aCAtIFRoZSBwYXRoIHRvIHZhbGlkYXRlIGNvbnN0cmFpbnRzIG9uXG4gKi9cbmV4cG9ydCBjb25zdCBWT0xVTUVfQ09OU1RSQUlOVCA9IChwYXRoOiBFZGdlW10pID0+IHBhdGguc29tZSgoZWRnZSkgPT4gZWRnZS50eXBlID09PSBUcmFuc2Zvcm1lclR5cGUuSW5saW5lVm9sdW1lKTtcblxuZXhwb3J0IGNvbnN0IE5PX0NPTlNUUkFJTlQgPSAoKSA9PiB0cnVlO1xuXG4vKipcbiAqIFRyaWVzIHRvIGluZmVyIHRoZSB0eXBlIG9mIGEgc3RyZWFtIHRvIGFpZCB3aXRoIHRyYW5zY29kZXIgcGlwZWxpbmluZy5cbiAqXG4gKiBAcGFyYW0gc3RyZWFtIC0gVGhlIHN0cmVhbSB0byBpbmZlciB0aGUgdHlwZSBvZlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5mZXJTdHJlYW1UeXBlKHN0cmVhbTogUmVhZGFibGUpOiB7XG4gIGhhc1ZvbHVtZTogYm9vbGVhbjtcbiAgc3RyZWFtVHlwZTogU3RyZWFtVHlwZTtcbn0ge1xuICBpZiAoc3RyZWFtIGluc3RhbmNlb2YgT3B1c0VuY29kZXIpIHtcbiAgICByZXR1cm4geyBzdHJlYW1UeXBlOiBTdHJlYW1UeXBlLk9wdXMsIGhhc1ZvbHVtZTogZmFsc2UgfTtcbiAgfSBlbHNlIGlmIChzdHJlYW0gaW5zdGFuY2VvZiBPcHVzRGVjb2Rlcikge1xuICAgIHJldHVybiB7IHN0cmVhbVR5cGU6IFN0cmVhbVR5cGUuUmF3LCBoYXNWb2x1bWU6IGZhbHNlIH07XG4gIH0gZWxzZSBpZiAoc3RyZWFtIGluc3RhbmNlb2YgVm9sdW1lVHJhbnNmb3JtZXIpIHtcbiAgICByZXR1cm4geyBzdHJlYW1UeXBlOiBTdHJlYW1UeXBlLlJhdywgaGFzVm9sdW1lOiB0cnVlIH07XG4gIH0gZWxzZSBpZiAoc3RyZWFtIGluc3RhbmNlb2YgT2dnRGVtdXhlcikge1xuICAgIHJldHVybiB7IHN0cmVhbVR5cGU6IFN0cmVhbVR5cGUuT3B1cywgaGFzVm9sdW1lOiBmYWxzZSB9O1xuICB9IGVsc2UgaWYgKHN0cmVhbSBpbnN0YW5jZW9mIFdlYm1EZW11eGVyKSB7XG4gICAgcmV0dXJuIHsgc3RyZWFtVHlwZTogU3RyZWFtVHlwZS5PcHVzLCBoYXNWb2x1bWU6IGZhbHNlIH07XG4gIH1cblxuICByZXR1cm4geyBzdHJlYW1UeXBlOiBTdHJlYW1UeXBlLkFyYml0cmFyeSwgaGFzVm9sdW1lOiBmYWxzZSB9O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXVkaW8gcmVzb3VyY2UgdGhhdCBjYW4gYmUgcGxheWVkIGJ5IGF1ZGlvIHBsYXllcnMuXG4gKlxuICogQHJlbWFya3NcbiAqIElmIHRoZSBpbnB1dCBpcyBnaXZlbiBhcyBhIHN0cmluZywgdGhlbiB0aGUgaW5wdXRUeXBlIG9wdGlvbiB3aWxsIGJlIG92ZXJyaWRkZW4gYW5kIEZGbXBlZyB3aWxsIGJlIHVzZWQuXG4gKlxuICogSWYgdGhlIGlucHV0IGlzIG5vdCBpbiB0aGUgY29ycmVjdCBmb3JtYXQsIHRoZW4gYSBwaXBlbGluZSBvZiB0cmFuc2NvZGVycyBhbmQgdHJhbnNmb3JtZXJzIHdpbGwgYmUgY3JlYXRlZFxuICogdG8gZW5zdXJlIHRoYXQgdGhlIHJlc3VsdGFudCBzdHJlYW0gaXMgaW4gdGhlIGNvcnJlY3QgZm9ybWF0IGZvciBwbGF5YmFjay4gVGhpcyBjb3VsZCBpbnZvbHZlIHVzaW5nIEZGbXBlZyxcbiAqIE9wdXMgdHJhbnNjb2RlcnMsIGFuZCBPZ2cvV2ViTSBkZW11eGVycy5cbiAqIEBwYXJhbSBpbnB1dCAtIFRoZSByZXNvdXJjZSB0byBwbGF5XG4gKiBAcGFyYW0gb3B0aW9ucyAtIENvbmZpZ3VyYWJsZSBvcHRpb25zIGZvciBjcmVhdGluZyB0aGUgcmVzb3VyY2VcbiAqIEB0eXBlUGFyYW0gTWV0YWRhdGEgLSB0aGUgdHlwZSBmb3IgdGhlIG1ldGFkYXRhIChpZiBhbnkpIG9mIHRoZSBhdWRpbyByZXNvdXJjZVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQXVkaW9SZXNvdXJjZTxNZXRhZGF0YT4oXG5pbnB1dDogUmVhZGFibGUgfCBzdHJpbmcsXG5vcHRpb25zOiBDcmVhdGVBdWRpb1Jlc291cmNlT3B0aW9uczxNZXRhZGF0YT4gJlxuUGljazxcbiAgTWV0YWRhdGEgZXh0ZW5kcyBudWxsIHwgdW5kZWZpbmVkID9cbiAgQ3JlYXRlQXVkaW9SZXNvdXJjZU9wdGlvbnM8TWV0YWRhdGE+IDpcbiAgUmVxdWlyZWQ8Q3JlYXRlQXVkaW9SZXNvdXJjZU9wdGlvbnM8TWV0YWRhdGE+PixcbiAgJ21ldGFkYXRhJz4pXG5cbjogQXVkaW9SZXNvdXJjZTxNZXRhZGF0YSBleHRlbmRzIG51bGwgfCB1bmRlZmluZWQgPyBudWxsIDogTWV0YWRhdGE+O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXVkaW8gcmVzb3VyY2UgdGhhdCBjYW4gYmUgcGxheWVkIGJ5IGF1ZGlvIHBsYXllcnMuXG4gKlxuICogQHJlbWFya3NcbiAqIElmIHRoZSBpbnB1dCBpcyBnaXZlbiBhcyBhIHN0cmluZywgdGhlbiB0aGUgaW5wdXRUeXBlIG9wdGlvbiB3aWxsIGJlIG92ZXJyaWRkZW4gYW5kIEZGbXBlZyB3aWxsIGJlIHVzZWQuXG4gKlxuICogSWYgdGhlIGlucHV0IGlzIG5vdCBpbiB0aGUgY29ycmVjdCBmb3JtYXQsIHRoZW4gYSBwaXBlbGluZSBvZiB0cmFuc2NvZGVycyBhbmQgdHJhbnNmb3JtZXJzIHdpbGwgYmUgY3JlYXRlZFxuICogdG8gZW5zdXJlIHRoYXQgdGhlIHJlc3VsdGFudCBzdHJlYW0gaXMgaW4gdGhlIGNvcnJlY3QgZm9ybWF0IGZvciBwbGF5YmFjay4gVGhpcyBjb3VsZCBpbnZvbHZlIHVzaW5nIEZGbXBlZyxcbiAqIE9wdXMgdHJhbnNjb2RlcnMsIGFuZCBPZ2cvV2ViTSBkZW11eGVycy5cbiAqIEBwYXJhbSBpbnB1dCAtIFRoZSByZXNvdXJjZSB0byBwbGF5XG4gKiBAcGFyYW0gb3B0aW9ucyAtIENvbmZpZ3VyYWJsZSBvcHRpb25zIGZvciBjcmVhdGluZyB0aGUgcmVzb3VyY2VcbiAqIEB0eXBlUGFyYW0gTWV0YWRhdGEgLSB0aGUgdHlwZSBmb3IgdGhlIG1ldGFkYXRhIChpZiBhbnkpIG9mIHRoZSBhdWRpbyByZXNvdXJjZVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQXVkaW9SZXNvdXJjZTxNZXRhZGF0YSBleHRlbmRzIG51bGwgfCB1bmRlZmluZWQ+KFxuaW5wdXQ6IFJlYWRhYmxlIHwgc3RyaW5nLFxub3B0aW9ucz86IE9taXQ8Q3JlYXRlQXVkaW9SZXNvdXJjZU9wdGlvbnM8TWV0YWRhdGE+LCAnbWV0YWRhdGEnPilcbjogQXVkaW9SZXNvdXJjZTxudWxsPjtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGF1ZGlvIHJlc291cmNlIHRoYXQgY2FuIGJlIHBsYXllZCBieSBhdWRpbyBwbGF5ZXJzLlxuICpcbiAqIEByZW1hcmtzXG4gKiBJZiB0aGUgaW5wdXQgaXMgZ2l2ZW4gYXMgYSBzdHJpbmcsIHRoZW4gdGhlIGlucHV0VHlwZSBvcHRpb24gd2lsbCBiZSBvdmVycmlkZGVuIGFuZCBGRm1wZWcgd2lsbCBiZSB1c2VkLlxuICpcbiAqIElmIHRoZSBpbnB1dCBpcyBub3QgaW4gdGhlIGNvcnJlY3QgZm9ybWF0LCB0aGVuIGEgcGlwZWxpbmUgb2YgdHJhbnNjb2RlcnMgYW5kIHRyYW5zZm9ybWVycyB3aWxsIGJlIGNyZWF0ZWRcbiAqIHRvIGVuc3VyZSB0aGF0IHRoZSByZXN1bHRhbnQgc3RyZWFtIGlzIGluIHRoZSBjb3JyZWN0IGZvcm1hdCBmb3IgcGxheWJhY2suIFRoaXMgY291bGQgaW52b2x2ZSB1c2luZyBGRm1wZWcsXG4gKiBPcHVzIHRyYW5zY29kZXJzLCBhbmQgT2dnL1dlYk0gZGVtdXhlcnMuXG4gKiBAcGFyYW0gaW5wdXQgLSBUaGUgcmVzb3VyY2UgdG8gcGxheVxuICogQHBhcmFtIG9wdGlvbnMgLSBDb25maWd1cmFibGUgb3B0aW9ucyBmb3IgY3JlYXRpbmcgdGhlIHJlc291cmNlXG4gKiBAdHlwZVBhcmFtIE1ldGFkYXRhIC0gdGhlIHR5cGUgZm9yIHRoZSBtZXRhZGF0YSAoaWYgYW55KSBvZiB0aGUgYXVkaW8gcmVzb3VyY2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUF1ZGlvUmVzb3VyY2U8TWV0YWRhdGE+KFxuaW5wdXQ6IFJlYWRhYmxlIHwgc3RyaW5nLFxub3B0aW9uczogQ3JlYXRlQXVkaW9SZXNvdXJjZU9wdGlvbnM8TWV0YWRhdGE+ID0ge30pXG46IEF1ZGlvUmVzb3VyY2U8TWV0YWRhdGE+IHtcbiAgbGV0IGlucHV0VHlwZSA9IG9wdGlvbnMuaW5wdXRUeXBlO1xuICBsZXQgbmVlZHNJbmxpbmVWb2x1bWUgPSBCb29sZWFuKG9wdGlvbnMuaW5saW5lVm9sdW1lKTtcblxuICAvLyBzdHJpbmcgaW5wdXRzIGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBGRm1wZWdcbiAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICBpbnB1dFR5cGUgPSBTdHJlYW1UeXBlLkFyYml0cmFyeTtcbiAgfSBlbHNlIGlmIChpbnB1dFR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IGFuYWx5c2lzID0gaW5mZXJTdHJlYW1UeXBlKGlucHV0KTtcbiAgICBpbnB1dFR5cGUgPSBhbmFseXNpcy5zdHJlYW1UeXBlO1xuICAgIG5lZWRzSW5saW5lVm9sdW1lID0gbmVlZHNJbmxpbmVWb2x1bWUgJiYgIWFuYWx5c2lzLmhhc1ZvbHVtZTtcbiAgfVxuXG4gIGNvbnN0IHRyYW5zZm9ybWVyUGlwZWxpbmUgPSBmaW5kUGlwZWxpbmUoaW5wdXRUeXBlLCBuZWVkc0lubGluZVZvbHVtZSA/IFZPTFVNRV9DT05TVFJBSU5UIDogTk9fQ09OU1RSQUlOVCk7XG5cbiAgaWYgKHRyYW5zZm9ybWVyUGlwZWxpbmUubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwaXBlbGluZSBjb25zdHJ1Y3RlZCBmb3Igc3RyaW5nIHJlc291cmNlICcke2lucHV0fSdgKTtcbiAgICAvLyBObyBhZGp1c3RtZW50cyByZXF1aXJlZFxuICAgIHJldHVybiBuZXcgQXVkaW9SZXNvdXJjZTxNZXRhZGF0YT4oXG4gICAgICBbXSxcbiAgICAgIFtpbnB1dF0sXG4gICAgICAob3B0aW9ucy5tZXRhZGF0YSA/PyBudWxsKSBhcyBNZXRhZGF0YSxcbiAgICAgIG9wdGlvbnMuc2lsZW5jZVBhZGRpbmdGcmFtZXMgPz8gNVxuICAgICk7XG4gIH1cblxuICBjb25zdCBzdHJlYW1zID0gdHJhbnNmb3JtZXJQaXBlbGluZS5tYXAoKGVkZ2UpID0+IGVkZ2UudHJhbnNmb3JtZXIoaW5wdXQpKTtcbiAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHN0cmVhbXMudW5zaGlmdChpbnB1dCk7XG5cbiAgcmV0dXJuIG5ldyBBdWRpb1Jlc291cmNlPE1ldGFkYXRhPihcbiAgICB0cmFuc2Zvcm1lclBpcGVsaW5lLFxuICAgIHN0cmVhbXMsXG4gICAgKG9wdGlvbnMubWV0YWRhdGEgPz8gbnVsbCkgYXMgTWV0YWRhdGEsXG4gICAgb3B0aW9ucy5zaWxlbmNlUGFkZGluZ0ZyYW1lcyA/PyA1XG4gICk7XG59IiwgIi8vIENvcHlyaWdodCBkaXNjb3JkLXBsYXllciBhdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLiBNSVQgTGljZW5zZS5cbi8vIENvcHlyaWdodCBkaXNjb3JkLmpzIGF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuIEFwYWNoZSBMaWNlbnNlIDIuMFxuXG5pbXBvcnQgdHlwZSB7IFJlYWRhYmxlIH0gZnJvbSAnbm9kZTpzdHJlYW0nO1xuaW1wb3J0IHsgT3B1c0VuY29kZXIsIE9wdXNEZWNvZGVyLCBPZ2dEZW11eGVyLCBXZWJtRGVtdXhlciB9IGZyb20gJ0BkaXNjb3JkLXBsYXllci9vcHVzJztcbmltcG9ydCB7IGNyZWF0ZUZGbXBlZ0FyZ3MsIEZGbXBlZyB9IGZyb20gJ0BkaXNjb3JkLXBsYXllci9mZm1wZWcnO1xuaW1wb3J0IHsgVm9sdW1lVHJhbnNmb3JtZXIgfSBmcm9tICdAZGlzY29yZC1wbGF5ZXIvZXF1YWxpemVyJztcblxuY29uc3QgRkZNUEVHX1BDTV9BUkdVTUVOVFMgPSBjcmVhdGVGRm1wZWdBcmdzKHtcbiAgYW5hbHl6ZWR1cmF0aW9uOiAnMCcsXG4gIGxvZ2xldmVsOiAnMCcsXG4gIGY6ICdzMTZsZScsXG4gIGFyOiAnNDgwMDAnLFxuICBhYzogJzInXG59KTtcblxuY29uc3QgRkZNUEVHX09QVVNfQVJHVU1FTlRTID0gY3JlYXRlRkZtcGVnQXJncyh7XG4gIGFuYWx5emVkdXJhdGlvbjogJzAnLFxuICBsb2dsZXZlbDogJzAnLFxuICBhY29kZWM6ICdsaWJvcHVzJyxcbiAgZjogJ29wdXMnLFxuICBhcjogJzQ4MDAwJyxcbiAgYWM6ICcyJ1xufSk7XG5cbi8qKlxuICogVGhlIGRpZmZlcmVudCB0eXBlcyBvZiBzdHJlYW0gdGhhdCBjYW4gZXhpc3Qgd2l0aGluIHRoZSBwaXBlbGluZS5cbiAqL1xuZXhwb3J0IGVudW0gU3RyZWFtVHlwZSB7XG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiB0aGUgc3RyZWFtIGF0IHRoaXMgcG9pbnQgaXMgdW5rbm93bi5cbiAgICovXG4gIEFyYml0cmFyeSA9ICdhcmJpdHJhcnknLFxuICAvKipcbiAgICogVGhlIHN0cmVhbSBhdCB0aGlzIHBvaW50IGlzIE9wdXMgYXVkaW8gZW5jb2RlZCBpbiBhbiBPZ2cgd3JhcHBlci5cbiAgICovXG4gIE9nZ09wdXMgPSAnb2dnL29wdXMnLFxuICAvKipcbiAgICogVGhlIHN0cmVhbSBhdCB0aGlzIHBvaW50IGlzIE9wdXMgYXVkaW8sIGFuZCB0aGUgc3RyZWFtIGlzIGluIG9iamVjdC1tb2RlLiBUaGlzIGlzIHJlYWR5IHRvIHBsYXkuXG4gICAqL1xuICBPcHVzID0gJ29wdXMnLFxuICAvKipcbiAgICogVGhlIHN0cmVhbSBhdCB0aGlzIHBvaW50IGlzIHMxNmxlIFBDTS5cbiAgICovXG4gIFJhdyA9ICdyYXcnLFxuICAvKipcbiAgICogVGhlIHN0cmVhbSBhdCB0aGlzIHBvaW50IGlzIE9wdXMgYXVkaW8gZW5jb2RlZCBpbiBhIFdlYk0gd3JhcHBlci5cbiAgICovXG4gIFdlYm1PcHVzID0gJ3dlYm0vb3B1cycsXG59XG5cbi8qKlxuICogVGhlIGRpZmZlcmVudCB0eXBlcyBvZiB0cmFuc2Zvcm1lcnMgdGhhdCBjYW4gZXhpc3Qgd2l0aGluIHRoZSBwaXBlbGluZS5cbiAqL1xuZXhwb3J0IGVudW0gVHJhbnNmb3JtZXJUeXBlIHtcbiAgRkZtcGVnT2dnID0gJ2ZmbXBlZyBvZ2cnLFxuICBGRm1wZWdQQ00gPSAnZmZtcGVnIHBjbScsXG4gIElubGluZVZvbHVtZSA9ICd2b2x1bWUgdHJhbnNmb3JtZXInLFxuICBPZ2dPcHVzRGVtdXhlciA9ICdvZ2cvb3B1cyBkZW11eGVyJyxcbiAgT3B1c0RlY29kZXIgPSAnb3B1cyBkZWNvZGVyJyxcbiAgT3B1c0VuY29kZXIgPSAnb3B1cyBlbmNvZGVyJyxcbiAgV2VibU9wdXNEZW11eGVyID0gJ3dlYm0vb3B1cyBkZW11eGVyJyxcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgcGF0aHdheSBmcm9tIG9uZSBzdHJlYW0gdHlwZSB0byBhbm90aGVyIHVzaW5nIGEgdHJhbnNmb3JtZXIuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRWRnZSB7XG4gIGNvc3Q6IG51bWJlcjtcbiAgZnJvbTogTm9kZTtcbiAgdG86IE5vZGU7XG4gIHRyYW5zZm9ybWVyKGlucHV0OiBSZWFkYWJsZSB8IHN0cmluZyk6IFJlYWRhYmxlO1xuICB0eXBlOiBUcmFuc2Zvcm1lclR5cGU7XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIHR5cGUgb2Ygc3RyZWFtIHdpdGhpbiB0aGUgZ3JhcGgsIGUuZy4gYW4gT3B1cyBzdHJlYW0sIG9yIGEgc3RyZWFtIG9mIHJhdyBhdWRpby5cbiAqL1xuZXhwb3J0IGNsYXNzIE5vZGUge1xuICAvKipcbiAgICogVGhlIG91dGJvdW5kIGVkZ2VzIGZyb20gdGhpcyBub2RlLlxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IGVkZ2VzOiBFZGdlW10gPSBbXTtcblxuICAvKipcbiAgICogVGhlIHR5cGUgb2Ygc3RyZWFtIGZvciB0aGlzIG5vZGUuXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgdHlwZTogU3RyZWFtVHlwZTtcblxuICBwdWJsaWMgY29uc3RydWN0b3IodHlwZTogU3RyZWFtVHlwZSkge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBvdXRib3VuZCBlZGdlIGZyb20gdGhpcyBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0gZWRnZSAtIFRoZSBlZGdlIHRvIGNyZWF0ZVxuICAgKi9cbiAgcHVibGljIGFkZEVkZ2UoZWRnZTogT21pdDxFZGdlLCAnZnJvbSc+KSB7XG4gICAgdGhpcy5lZGdlcy5wdXNoKHsgLi4uZWRnZSwgZnJvbTogdGhpcyB9KTtcbiAgfVxufVxuXG4vLyBDcmVhdGUgYSBub2RlIGZvciBlYWNoIHN0cmVhbSB0eXBlXG5sZXQgTk9ERVM6IE1hcDxTdHJlYW1UeXBlLCBOb2RlPiB8IG51bGwgPSBudWxsO1xuXG5mdW5jdGlvbiBjYW5FbmFibGVGRm1wZWdPcHRpbWl6YXRpb25zKCk6IGJvb2xlYW4ge1xuICByZXR1cm4gRkZtcGVnLnJlc29sdmVTYWZlKCk/LnJlc3VsdC5pbmNsdWRlcygnLS1lbmFibGUtbGlib3B1cycpID09PSB0cnVlO1xufVxuXG4vKipcbiAqIEdldHMgYSBub2RlIGZyb20gaXRzIHN0cmVhbSB0eXBlLlxuICpcbiAqIEBwYXJhbSB0eXBlIC0gVGhlIHN0cmVhbSB0eXBlIG9mIHRoZSB0YXJnZXQgbm9kZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Tm9kZSh0eXBlOiBTdHJlYW1UeXBlKSB7XG4gIGNvbnN0IG5vZGUgPSAoTk9ERVMgPz89IGluaXRpYWxpemVOb2RlcygpKS5nZXQodHlwZSk7XG4gIGlmICghbm9kZSkgdGhyb3cgbmV3IEVycm9yKGBOb2RlIHR5cGUgJyR7dHlwZX0nIGRvZXMgbm90IGV4aXN0IWApO1xuICByZXR1cm4gbm9kZTtcbn1cblxuZnVuY3Rpb24gaW5pdGlhbGl6ZU5vZGVzKCk6IE1hcDxTdHJlYW1UeXBlLCBOb2RlPiB7XG4gIGNvbnN0IG5vZGVzID0gbmV3IE1hcDxTdHJlYW1UeXBlLCBOb2RlPigpO1xuICBmb3IgKGNvbnN0IHN0cmVhbVR5cGUgb2YgT2JqZWN0LnZhbHVlcyhTdHJlYW1UeXBlKSkge1xuICAgIG5vZGVzLnNldChzdHJlYW1UeXBlLCBuZXcgTm9kZShzdHJlYW1UeXBlKSk7XG4gIH1cblxuICBub2Rlcy5nZXQoU3RyZWFtVHlwZS5SYXcpIS5hZGRFZGdlKHtcbiAgICB0eXBlOiBUcmFuc2Zvcm1lclR5cGUuT3B1c0VuY29kZXIsXG4gICAgdG86IG5vZGVzLmdldChTdHJlYW1UeXBlLk9wdXMpISxcbiAgICBjb3N0OiAxLjUsXG4gICAgdHJhbnNmb3JtZXI6ICgpID0+IG5ldyBPcHVzRW5jb2Rlcih7IHJhdGU6IDQ4XzAwMCwgY2hhbm5lbHM6IDIsIGZyYW1lU2l6ZTogOTYwIH0pXG4gIH0pO1xuXG4gIG5vZGVzLmdldChTdHJlYW1UeXBlLk9wdXMpIS5hZGRFZGdlKHtcbiAgICB0eXBlOiBUcmFuc2Zvcm1lclR5cGUuT3B1c0RlY29kZXIsXG4gICAgdG86IG5vZGVzLmdldChTdHJlYW1UeXBlLlJhdykhLFxuICAgIGNvc3Q6IDEuNSxcbiAgICB0cmFuc2Zvcm1lcjogKCkgPT4gbmV3IE9wdXNEZWNvZGVyKHsgcmF0ZTogNDhfMDAwLCBjaGFubmVsczogMiwgZnJhbWVTaXplOiA5NjAgfSlcbiAgfSk7XG5cbiAgbm9kZXMuZ2V0KFN0cmVhbVR5cGUuT2dnT3B1cykhLmFkZEVkZ2Uoe1xuICAgIHR5cGU6IFRyYW5zZm9ybWVyVHlwZS5PZ2dPcHVzRGVtdXhlcixcbiAgICB0bzogbm9kZXMuZ2V0KFN0cmVhbVR5cGUuT3B1cykhLFxuICAgIGNvc3Q6IDEsXG4gICAgdHJhbnNmb3JtZXI6ICgpID0+IG5ldyBPZ2dEZW11eGVyKClcbiAgfSk7XG5cbiAgbm9kZXMuZ2V0KFN0cmVhbVR5cGUuV2VibU9wdXMpIS5hZGRFZGdlKHtcbiAgICB0eXBlOiBUcmFuc2Zvcm1lclR5cGUuV2VibU9wdXNEZW11eGVyLFxuICAgIHRvOiBub2Rlcy5nZXQoU3RyZWFtVHlwZS5PcHVzKSEsXG4gICAgY29zdDogMSxcbiAgICB0cmFuc2Zvcm1lcjogKCkgPT4gbmV3IFdlYm1EZW11eGVyKClcbiAgfSk7XG5cbiAgY29uc3QgRkZNUEVHX1BDTV9FREdFOiBPbWl0PEVkZ2UsICdmcm9tJz4gPSB7XG4gICAgdHlwZTogVHJhbnNmb3JtZXJUeXBlLkZGbXBlZ1BDTSxcbiAgICB0bzogbm9kZXMuZ2V0KFN0cmVhbVR5cGUuUmF3KSEsXG4gICAgY29zdDogMixcbiAgICB0cmFuc2Zvcm1lcjogKGlucHV0KSA9PlxuICAgIG5ldyBGRm1wZWcoe1xuICAgICAgYXJnczogWyctaScsIHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycgPyBpbnB1dCA6ICctJywgLi4uRkZNUEVHX1BDTV9BUkdVTUVOVFNdXG4gICAgfSlcbiAgfTtcblxuICBub2Rlcy5nZXQoU3RyZWFtVHlwZS5BcmJpdHJhcnkpIS5hZGRFZGdlKEZGTVBFR19QQ01fRURHRSk7XG4gIG5vZGVzLmdldChTdHJlYW1UeXBlLk9nZ09wdXMpIS5hZGRFZGdlKEZGTVBFR19QQ01fRURHRSk7XG4gIG5vZGVzLmdldChTdHJlYW1UeXBlLldlYm1PcHVzKSEuYWRkRWRnZShGRk1QRUdfUENNX0VER0UpO1xuXG4gIG5vZGVzLmdldChTdHJlYW1UeXBlLlJhdykhLmFkZEVkZ2Uoe1xuICAgIHR5cGU6IFRyYW5zZm9ybWVyVHlwZS5JbmxpbmVWb2x1bWUsXG4gICAgdG86IG5vZGVzLmdldChTdHJlYW1UeXBlLlJhdykhLFxuICAgIGNvc3Q6IDAuNSxcbiAgICB0cmFuc2Zvcm1lcjogKCkgPT4gbmV3IFZvbHVtZVRyYW5zZm9ybWVyKHsgdHlwZTogJ3MxNmxlJyB9KVxuICB9KTtcblxuICBpZiAoY2FuRW5hYmxlRkZtcGVnT3B0aW1pemF0aW9ucygpKSB7XG4gICAgY29uc3QgRkZNUEVHX09HR19FREdFOiBPbWl0PEVkZ2UsICdmcm9tJz4gPSB7XG4gICAgICB0eXBlOiBUcmFuc2Zvcm1lclR5cGUuRkZtcGVnT2dnLFxuICAgICAgdG86IG5vZGVzLmdldChTdHJlYW1UeXBlLk9nZ09wdXMpISxcbiAgICAgIGNvc3Q6IDIsXG4gICAgICB0cmFuc2Zvcm1lcjogKGlucHV0KSA9PlxuICAgICAgbmV3IEZGbXBlZyh7XG4gICAgICAgIGFyZ3M6IFsnLWknLCB0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnID8gaW5wdXQgOiAnLScsIC4uLkZGTVBFR19PUFVTX0FSR1VNRU5UU11cbiAgICAgIH0pXG4gICAgfTtcbiAgICBub2Rlcy5nZXQoU3RyZWFtVHlwZS5BcmJpdHJhcnkpIS5hZGRFZGdlKEZGTVBFR19PR0dfRURHRSk7XG4gICAgLy8gSW5jbHVkZSBPZ2cgYW5kIFdlYk0gYXMgd2VsbCBpbiBjYXNlIHRoZXkgaGF2ZSBkaWZmZXJlbnQgc2FtcGxpbmcgcmF0ZXMgb3IgYXJlIG1vbm8gaW5zdGVhZCBvZiBzdGVyZW9cbiAgICAvLyBhdCB0aGUgbW9tZW50LCB0aGlzIHdpbGwgbm90IGRvIGFueXRoaW5nLiBIb3dldmVyLCBpZi93aGVuIGRldGVjdGlvbiBmb3IgY29ycmVjdCBPcHVzIGhlYWRlcnMgaXNcbiAgICAvLyBpbXBsZW1lbnRlZCwgdGhpcyB3aWxsIGhlbHAgaW5mb3JtIHRoZSB2b2ljZSBlbmdpbmUgdGhhdCBpdCBpcyBhYmxlIHRvIHRyYW5zY29kZSB0aGUgYXVkaW8uXG4gICAgbm9kZXMuZ2V0KFN0cmVhbVR5cGUuT2dnT3B1cykhLmFkZEVkZ2UoRkZNUEVHX09HR19FREdFKTtcbiAgICBub2Rlcy5nZXQoU3RyZWFtVHlwZS5XZWJtT3B1cykhLmFkZEVkZ2UoRkZNUEVHX09HR19FREdFKTtcbiAgfVxuXG4gIHJldHVybiBub2Rlcztcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgc3RlcCBpbiB0aGUgcGF0aCBmcm9tIG5vZGUgQSB0byBub2RlIEIuXG4gKi9cbmludGVyZmFjZSBTdGVwIHtcbiAgLyoqXG4gICAqIFRoZSBjb3N0IG9mIHRoZSBzdGVwcyBhZnRlciB0aGlzIHN0ZXAuXG4gICAqL1xuICBjb3N0OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBlZGdlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHN0ZXAuXG4gICAqL1xuICBlZGdlPzogRWRnZTtcblxuICAvKipcbiAgICogVGhlIG5leHQgc3RlcC5cbiAgICovXG4gIG5leHQ/OiBTdGVwO1xufVxuXG4vKipcbiAqIEZpbmRzIHRoZSBzaG9ydGVzdCBjb3N0IHBhdGggZnJvbSBub2RlIEEgdG8gbm9kZSBCLlxuICpcbiAqIEBwYXJhbSBmcm9tIC0gVGhlIHN0YXJ0IG5vZGVcbiAqIEBwYXJhbSBjb25zdHJhaW50cyAtIEV4dHJhIHZhbGlkYXRpb24gZm9yIGEgcG90ZW50aWFsIHNvbHV0aW9uLiBUYWtlcyBhIHBhdGgsIHJldHVybnMgdHJ1ZSBpZiB0aGUgcGF0aCBpcyB2YWxpZFxuICogQHBhcmFtIGdvYWwgLSBUaGUgdGFyZ2V0IG5vZGVcbiAqIEBwYXJhbSBwYXRoIC0gVGhlIHJ1bm5pbmcgcGF0aFxuICogQHBhcmFtIGRlcHRoIC0gVGhlIG51bWJlciBvZiByZW1haW5pbmcgcmVjdXJzaW9uc1xuICovXG5mdW5jdGlvbiBmaW5kUGF0aChcbmZyb206IE5vZGUsXG5jb25zdHJhaW50czogKHBhdGg6IEVkZ2VbXSkgPT4gYm9vbGVhbixcbmdvYWwgPSBnZXROb2RlKFN0cmVhbVR5cGUuT3B1cyksXG5wYXRoOiBFZGdlW10gPSBbXSxcbmRlcHRoID0gNSlcbjogU3RlcCB7XG4gIGlmIChmcm9tID09PSBnb2FsICYmIGNvbnN0cmFpbnRzKHBhdGgpKSB7XG4gICAgcmV0dXJuIHsgY29zdDogMCB9O1xuICB9IGVsc2UgaWYgKGRlcHRoID09PSAwKSB7XG4gICAgcmV0dXJuIHsgY29zdDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZIH07XG4gIH1cblxuICBsZXQgY3VycmVudEJlc3Q6IFN0ZXAgfCB1bmRlZmluZWQ7XG4gIGZvciAoY29uc3QgZWRnZSBvZiBmcm9tLmVkZ2VzKSB7XG4gICAgaWYgKGN1cnJlbnRCZXN0ICYmIGVkZ2UuY29zdCA+IGN1cnJlbnRCZXN0LmNvc3QpIGNvbnRpbnVlO1xuICAgIGNvbnN0IG5leHQgPSBmaW5kUGF0aChlZGdlLnRvLCBjb25zdHJhaW50cywgZ29hbCwgWy4uLnBhdGgsIGVkZ2VdLCBkZXB0aCAtIDEpO1xuICAgIGNvbnN0IGNvc3QgPSBlZGdlLmNvc3QgKyBuZXh0LmNvc3Q7XG4gICAgaWYgKCFjdXJyZW50QmVzdCB8fCBjb3N0IDwgY3VycmVudEJlc3QuY29zdCkge1xuICAgICAgY3VycmVudEJlc3QgPSB7IGNvc3QsIGVkZ2UsIG5leHQgfTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY3VycmVudEJlc3QgPz8geyBjb3N0OiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgfTtcbn1cblxuLyoqXG4gKiBUYWtlcyB0aGUgc29sdXRpb24gZnJvbSBmaW5kUGF0aCBhbmQgYXNzZW1ibGVzIGl0IGludG8gYSBsaXN0IG9mIGVkZ2VzLlxuICpcbiAqIEBwYXJhbSBzdGVwIC0gVGhlIGZpcnN0IHN0ZXAgb2YgdGhlIHBhdGhcbiAqL1xuZnVuY3Rpb24gY29uc3RydWN0UGlwZWxpbmUoc3RlcDogU3RlcCkge1xuICBjb25zdCBlZGdlczogRWRnZVtdID0gW107XG4gIGxldCBjdXJyZW50OiBTdGVwIHwgdW5kZWZpbmVkID0gc3RlcDtcbiAgd2hpbGUgKGN1cnJlbnQ/LmVkZ2UpIHtcbiAgICBlZGdlcy5wdXNoKGN1cnJlbnQuZWRnZSk7XG4gICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgfVxuXG4gIHJldHVybiBlZGdlcztcbn1cblxuLyoqXG4gKiBGaW5kcyB0aGUgbG93ZXN0LWNvc3QgcGlwZWxpbmUgdG8gY29udmVydCB0aGUgaW5wdXQgc3RyZWFtIHR5cGUgaW50byBhbiBPcHVzIHN0cmVhbS5cbiAqXG4gKiBAcGFyYW0gZnJvbSAtIFRoZSBzdHJlYW0gdHlwZSB0byBzdGFydCBmcm9tXG4gKiBAcGFyYW0gY29uc3RyYWludCAtIEV4dHJhIGNvbnN0cmFpbnRzIHRoYXQgbWF5IGJlIGltcG9zZWQgb24gcG90ZW50aWFsIHNvbHV0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kUGlwZWxpbmUoZnJvbTogU3RyZWFtVHlwZSwgY29uc3RyYWludDogKHBhdGg6IEVkZ2VbXSkgPT4gYm9vbGVhbikge1xuICByZXR1cm4gY29uc3RydWN0UGlwZWxpbmUoZmluZFBhdGgoZ2V0Tm9kZShmcm9tKSwgY29uc3RyYWludCkpO1xufSIsICIvLyBDb3B5cmlnaHQgZGlzY29yZC1wbGF5ZXIgYXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC4gTUlUIExpY2Vuc2UuXG4vLyBDb3B5cmlnaHQgZGlzY29yZC5qcyBhdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLiBBcGFjaGUgTGljZW5zZSAyLjBcblxuaW1wb3J0IHsgdHlwZSBFdmVudEVtaXR0ZXIsIG9uY2UgfSBmcm9tICdub2RlOmV2ZW50cyc7XG5pbXBvcnQgdHlwZSB7IFZvaWNlQ29ubmVjdGlvbiwgVm9pY2VDb25uZWN0aW9uU3RhdHVzIH0gZnJvbSAnLi4vVm9pY2VDb25uZWN0aW9uJztcbmltcG9ydCB0eXBlIHsgQXVkaW9QbGF5ZXIsIEF1ZGlvUGxheWVyU3RhdHVzIH0gZnJvbSAnLi4vYXVkaW8vQXVkaW9QbGF5ZXInO1xuaW1wb3J0IHsgYWJvcnRBZnRlciB9IGZyb20gJy4vYWJvcnRBZnRlcic7XG5cbi8qKlxuICogQWxsb3dzIGEgdm9pY2UgY29ubmVjdGlvbiBhIHNwZWNpZmllZCBhbW91bnQgb2YgdGltZSB0byBlbnRlciBhIGdpdmVuIHN0YXRlLCBvdGhlcndpc2UgcmVqZWN0cyB3aXRoIGFuIGVycm9yLlxuICpcbiAqIEBwYXJhbSB0YXJnZXQgLSBUaGUgdm9pY2UgY29ubmVjdGlvbiB0aGF0IHdlIHdhbnQgdG8gb2JzZXJ2ZSB0aGUgc3RhdGUgY2hhbmdlIGZvclxuICogQHBhcmFtIHN0YXR1cyAtIFRoZSBzdGF0dXMgdGhhdCB0aGUgdm9pY2UgY29ubmVjdGlvbiBzaG91bGQgYmUgaW5cbiAqIEBwYXJhbSB0aW1lb3V0T3JTaWduYWwgLSBUaGUgbWF4aW11bSB0aW1lIHdlIGFyZSBhbGxvd2luZyBmb3IgdGhpcyB0byBvY2N1ciwgb3IgYSBzaWduYWwgdGhhdCB3aWxsIGFib3J0IHRoZSBvcGVyYXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVudGVyc1N0YXRlKFxudGFyZ2V0OiBWb2ljZUNvbm5lY3Rpb24sXG5zdGF0dXM6IFZvaWNlQ29ubmVjdGlvblN0YXR1cyxcbnRpbWVvdXRPclNpZ25hbDogQWJvcnRTaWduYWwgfCBudW1iZXIpXG46IFByb21pc2U8Vm9pY2VDb25uZWN0aW9uPjtcblxuLyoqXG4gKiBBbGxvd3MgYW4gYXVkaW8gcGxheWVyIGEgc3BlY2lmaWVkIGFtb3VudCBvZiB0aW1lIHRvIGVudGVyIGEgZ2l2ZW4gc3RhdGUsIG90aGVyd2lzZSByZWplY3RzIHdpdGggYW4gZXJyb3IuXG4gKlxuICogQHBhcmFtIHRhcmdldCAtIFRoZSBhdWRpbyBwbGF5ZXIgdGhhdCB3ZSB3YW50IHRvIG9ic2VydmUgdGhlIHN0YXRlIGNoYW5nZSBmb3JcbiAqIEBwYXJhbSBzdGF0dXMgLSBUaGUgc3RhdHVzIHRoYXQgdGhlIGF1ZGlvIHBsYXllciBzaG91bGQgYmUgaW5cbiAqIEBwYXJhbSB0aW1lb3V0T3JTaWduYWwgLSBUaGUgbWF4aW11bSB0aW1lIHdlIGFyZSBhbGxvd2luZyBmb3IgdGhpcyB0byBvY2N1ciwgb3IgYSBzaWduYWwgdGhhdCB3aWxsIGFib3J0IHRoZSBvcGVyYXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVudGVyc1N0YXRlKFxudGFyZ2V0OiBBdWRpb1BsYXllcixcbnN0YXR1czogQXVkaW9QbGF5ZXJTdGF0dXMsXG50aW1lb3V0T3JTaWduYWw6IEFib3J0U2lnbmFsIHwgbnVtYmVyKVxuOiBQcm9taXNlPEF1ZGlvUGxheWVyPjtcblxuLyoqXG4gKiBBbGxvd3MgYSB0YXJnZXQgYSBzcGVjaWZpZWQgYW1vdW50IG9mIHRpbWUgdG8gZW50ZXIgYSBnaXZlbiBzdGF0ZSwgb3RoZXJ3aXNlIHJlamVjdHMgd2l0aCBhbiBlcnJvci5cbiAqXG4gKiBAcGFyYW0gdGFyZ2V0IC0gVGhlIG9iamVjdCB0aGF0IHdlIHdhbnQgdG8gb2JzZXJ2ZSB0aGUgc3RhdGUgY2hhbmdlIGZvclxuICogQHBhcmFtIHN0YXR1cyAtIFRoZSBzdGF0dXMgdGhhdCB0aGUgdGFyZ2V0IHNob3VsZCBiZSBpblxuICogQHBhcmFtIHRpbWVvdXRPclNpZ25hbCAtIFRoZSBtYXhpbXVtIHRpbWUgd2UgYXJlIGFsbG93aW5nIGZvciB0aGlzIHRvIG9jY3VyLCBvciBhIHNpZ25hbCB0aGF0IHdpbGwgYWJvcnQgdGhlIG9wZXJhdGlvblxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZW50ZXJzU3RhdGU8VGFyZ2V0IGV4dGVuZHMgQXVkaW9QbGF5ZXIgfCBWb2ljZUNvbm5lY3Rpb24+KFxudGFyZ2V0OiBUYXJnZXQsXG5zdGF0dXM6IEF1ZGlvUGxheWVyU3RhdHVzIHwgVm9pY2VDb25uZWN0aW9uU3RhdHVzLFxudGltZW91dE9yU2lnbmFsOiBBYm9ydFNpZ25hbCB8IG51bWJlcilcbntcbiAgaWYgKHRhcmdldC5zdGF0ZS5zdGF0dXMgIT09IHN0YXR1cykge1xuICAgIGNvbnN0IFthYywgc2lnbmFsXSA9XG4gICAgdHlwZW9mIHRpbWVvdXRPclNpZ25hbCA9PT0gJ251bWJlcicgPyBhYm9ydEFmdGVyKHRpbWVvdXRPclNpZ25hbCkgOiBbdW5kZWZpbmVkLCB0aW1lb3V0T3JTaWduYWxdO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBvbmNlKHRhcmdldCBhcyBFdmVudEVtaXR0ZXIsIHN0YXR1cywgeyBzaWduYWwgfSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGFjPy5hYm9ydCgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59IiwgIi8vIENvcHlyaWdodCBkaXNjb3JkLXBsYXllciBhdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLiBNSVQgTGljZW5zZS5cbi8vIENvcHlyaWdodCBkaXNjb3JkLmpzIGF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuIEFwYWNoZSBMaWNlbnNlIDIuMFxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYWJvcnQgY29udHJvbGxlciB0aGF0IGFib3J0cyBhZnRlciB0aGUgZ2l2ZW4gdGltZS5cbiAqXG4gKiBAcGFyYW0gZGVsYXkgLSBUaGUgdGltZSBpbiBtaWxsaXNlY29uZHMgdG8gd2FpdCBiZWZvcmUgYWJvcnRpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFib3J0QWZ0ZXIoZGVsYXk6IG51bWJlcik6IFtBYm9ydENvbnRyb2xsZXIsIEFib3J0U2lnbmFsXSB7XG4gIGNvbnN0IGFjID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiBhYy5hYm9ydCgpLCBkZWxheSk7XG4gIGFjLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+IGNsZWFyVGltZW91dCh0aW1lb3V0KSk7XG4gIHJldHVybiBbYWMsIGFjLnNpZ25hbF07XG59IiwgIlxuXG5cblxuXG5cbmV4cG9ydCBjb25zdCB2ZXJzaW9uID0gLyogQF9fTUFDUk9fXyBnZXRWZXJzaW9uICovXCI3LjAuMFwiOyJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOzs7QUNNQSxJQUFBQSxzQkFBNkI7OztBQ0g3QixpQkFBK0I7QUFrQnhCLFNBQVMsOEJBQThCLFFBQW9CO0FBQ2hFLFNBQU87QUFBQSxJQUNMLElBQUksMEJBQWU7QUFBQTtBQUFBLElBRW5CLEdBQUc7QUFBQSxNQUNELFVBQVUsT0FBTztBQUFBLE1BQ2pCLFlBQVksT0FBTztBQUFBLE1BQ25CLFdBQVcsT0FBTztBQUFBLE1BQ2xCLFdBQVcsT0FBTztBQUFB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UUFBSSxPQUFPLFVBQVUsU0FBVSxPQUFNLElBQUksTUFBTSxxREFBcUQsS0FBSyxHQUFHO0FBRTVHLFdBQU8sSUFBSTtBQUFBLE1BQ1QsQ0FBQztBQUFBLE1BQ0QsQ0FBQyxLQUFLO0FBQUEsTUFDTCxRQUFRLFlBQVk7QUFBQSxNQUNyQixRQUFRLHdCQUF3QjtBQUFBLElBQ2xDO0FBQUEsRUFDRjtBQUVBLFFBQU0sVUFBVSxvQkFBb0IsSUFBSSxDQUFDLFNBQVMsS0FBSyxZQUFZLEtBQUssQ0FBQztBQUN6RSxNQUFJLE9BQU8sVUFBVSxTQUFVLFNBQVEsUUFBUSxLQUFLO0FBRXBELFNBQU8sSUFBSTtBQUFBLElBQ1Q7QUFBQSxJQUNBO0FBQUEsSUFDQyxRQUFRLFlBQVk7QUFBQSxJQUNyQixRQUFRLHdCQUF3QjtBQUFBLEVBQ2xDO0FBQ0Y7QUF0Q2dCOzs7QUVsUWhCLElBQUFDLHNCQUF3Qzs7O0FDS2pDLFNBQVMsV0FBVyxPQUErQztBQUN4RSxRQUFNLEtBQUssSUFBSSxnQkFBZ0I7QUFDL0IsUUFBTSxVQUFVLFdBQVcsTUFBTSxHQUFHLE1BQU0sR0FBRyxLQUFLO0FBQ2xELEtBQUcsT0FBTyxpQkFBaUIsU0FBUyxNQUFNLGFBQWEsT0FBTyxDQUFDO0FBQy9ELFNBQU8sQ0FBQyxJQUFJLEdBQUcsTUFBTTtBQUN2QjtBQUxnQjs7O0FEaUNoQixlQUFzQixZQUN0QixRQUNBLFFBQ0EsaUJBQ0E7QUFDRSxNQUFJLE9BQU8sTUFBTSxXQUFXLFFBQVE7QUFDbEMsVUFBTSxDQUFDLElBQUksTUFBTSxJQUNqQixPQUFPLG9CQUFvQixXQUFXLFdBQVcsZUFBZSxJQUFJLENBQUMsUUFBVyxlQUFlO0FBQy9GLFFBQUk7QUFDRixnQkFBTSwwQkFBSyxRQUF3QixRQUFRLEVBQUUsT0FBTyxDQUFDO0FBQUEsSUFDdkQsVUFBRTtBQUNBLFVBQUksTUFBTTtBQUFBLElBQ1o7QUFBQSxFQUNGO0FBRUEsU0FBTztBQUNUO0FBaEJzQjs7O0FFbkNmLElBQU07QUFBQTtBQUFBLEVBQXFDO0FBQUE7IiwKICAibmFtZXMiOiBbImltcG9ydF9ub2RlX2V2ZW50cyIsICJpbXBvcnRfbm9kZV9idWZmZXIiLCAiaW1wb3J0X25vZGVfZXZlbnRzIiwgImltcG9ydF92NCIsICJub25jZSIsICJjcnlwdG8iLCAiaW1wb3J0X25vZGVfYnVmZmVyIiwgImltcG9ydF9ub2RlX2V2ZW50cyIsICJub25jZSIsICJjcnlwdG8iLCAib3B0aW9uIiwgImNyeXB0byIsICJWb2ljZUNvbm5lY3Rpb25TdGF0dXMiLCAiVm9pY2VDb25uZWN0aW9uRGlzY29ubmVjdFJlYXNvbiIsICJpbXBvcnRfbm9kZV9idWZmZXIiLCAiaW1wb3J0X25vZGVfZXZlbnRzIiwgIk5vU3Vic2NyaWJlckJlaGF2aW9yIiwgIkF1ZGlvUGxheWVyU3RhdHVzIiwgInN0cmluZ2lmeVN0YXRlIiwgIlN0cmVhbVR5cGUiLCAiaW1wb3J0X29wdXMiLCAiaW1wb3J0X2VxdWFsaXplciIsICJpbXBvcnRfbm9kZV9ldmVudHMiXQp9Cg==