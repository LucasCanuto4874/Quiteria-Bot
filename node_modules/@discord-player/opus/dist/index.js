"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  CTL: () => CTL,
  OggDemuxer: () => OggDemuxer,
  OpusDecoder: () => OpusDecoder,
  OpusEncoder: () => OpusEncoder,
  OpusStream: () => OpusStream,
  WebmDemuxer: () => WebmDemuxer,
  addLibopusProvider: () => addLibopusProvider,
  removeLibopusProvider: () => removeLibopusProvider,
  setLibopusProvider: () => setLibopusProvider,
  version: () => version
});
module.exports = __toCommonJS(src_exports);

// src/OggDemuxer.ts
var import_node_stream = require("stream");
var OGG_PAGE_HEADER_SIZE = 26;
var STREAM_STRUCTURE_VERSION = 0;
var charCode = /* @__PURE__ */ __name((x) => x.charCodeAt(0), "charCode");
var OGGS_HEADER = Buffer.from([..."OggS"].map(charCode));
var OPUS_HEAD = Buffer.from([..."OpusHead"].map(charCode));
var OPUS_TAGS = Buffer.from([..."OpusTags"].map(charCode));
var _OggDemuxer = class _OggDemuxer extends import_node_stream.Transform {
  /**
   * Creates a new OggOpus demuxer.
   * @param {Object} [options] options that you would pass to a regular Transform stream.
   * @memberof opus
   */
  constructor(options = {}) {
    super(Object.assign({ readableObjectMode: true }, options));
    __publicField(this, "_remainder", null);
    __publicField(this, "_head", null);
    __publicField(this, "_bitstream", null);
    this._remainder = null;
    this._head = null;
    this._bitstream = null;
  }
  _transform(chunk, encoding, done) {
    if (this._remainder) {
      chunk = Buffer.concat([this._remainder, chunk]);
      this._remainder = null;
    }
    try {
      while (chunk) {
        const result = this._readPage(chunk);
        if (result) chunk = result;
        else
          break;
      }
    } catch (error) {
      done(error);
      return;
    }
    this._remainder = chunk;
    done();
  }
  /**
   * Reads a page from a buffer
   * @private
   * @param {Buffer} chunk the chunk containing the page
   * @returns {boolean|Buffer} if a buffer, it will be a slice of the excess data of the original, otherwise it will be
   * false and would indicate that there is not enough data to go ahead with reading this page.
   */
  _readPage(chunk) {
    if (chunk.length < OGG_PAGE_HEADER_SIZE) {
      return false;
    }
    if (!chunk.subarray(0, 4).equals(OGGS_HEADER)) {
      throw Error(`capture_pattern is not ${OGGS_HEADER}`);
    }
    if (chunk.readUInt8(4) !== STREAM_STRUCTURE_VERSION) {
      throw Error(`stream_structure_version is not ${STREAM_STRUCTURE_VERSION}`);
    }
    if (chunk.length < 27) return false;
    const pageSegments = chunk.readUInt8(26);
    if (chunk.length < 27 + pageSegments) return false;
    const table = chunk.subarray(27, 27 + pageSegments);
    const bitstream = chunk.readUInt32BE(14);
    const sizes = [];
    let totalSize = 0;
    for (let i = 0; i < pageSegments; ) {
      let size = 0, x = 255;
      while (x === 255) {
        if (i >= table.length) return false;
        x = table.readUInt8(i);
        i++;
        size += x;
      }
      sizes.push(size);
      totalSize += size;
    }
    if (chunk.length < 27 + pageSegments + totalSize) return false;
    let start = 27 + pageSegments;
    for (const size of sizes) {
      const segment = chunk.subarray(start, start + size);
      const header = segment.subarray(0, 8);
      if (this._head) {
        if (header.equals(OPUS_TAGS)) this.emit("tags", segment);
        else if (this._bitstream === bitstream) this.push(segment);
      } else if (header.equals(OPUS_HEAD)) {
        this.emit("head", segment);
        this._head = segment;
        this._bitstream = bitstream;
      } else {
        this.emit("unknownSegment", segment);
      }
      start += size;
    }
    return chunk.subarray(start);
  }
  _destroy(err, cb) {
    this._cleanup();
    return cb ? cb(err) : void 0;
  }
  _final(cb) {
    this._cleanup();
    cb();
  }
  /**
   * Cleans up the demuxer when it is no longer required.
   * @private
   */
  _cleanup() {
    this._remainder = null;
    this._head = null;
    this._bitstream = null;
  }
};
__name(_OggDemuxer, "OggDemuxer");
var OggDemuxer = _OggDemuxer;

// src/OpusEncoder.ts
var import_node_stream2 = require("stream");
var loadModule = /* @__PURE__ */ __name((modules) => {
  const errors = [];
  for (const [name, fn] of modules) {
    try {
      return {
        // eslint-disable-next-line @typescript-eslint/no-var-requires
        ...fn(require(name)),
        name
      };
    } catch (e) {
      errors.push(`Failed to load ${name}: ${e}`);
      continue;
    }
  }
  throw new Error(
    `Could not load opus module, tried ${modules.length} different modules. Errors: ${errors.join("\n")}`
  );
}, "loadModule");
var CTL = {
  BITRATE: 4002,
  FEC: 4012,
  PLP: 4014
};
var OPUS_MOD_REGISTRY = [
  [
    "mediaplex",
    (mod) => {
      if (!mod.OpusEncoder) throw new Error("Unsupported mediaplex version");
      return { Encoder: mod.OpusEncoder };
    }
  ],
  ["@discordjs/opus", (opus) => ({ Encoder: opus.OpusEncoder })],
  ["opusscript", (opus) => ({ Encoder: opus })],
  [
    "@evan/opus",
    (opus) => {
      const { Encoder, Decoder } = opus;
      const _OpusEncoder2 = class _OpusEncoder2 {
        constructor(_rate, _channels, _application) {
          this._rate = _rate;
          this._channels = _channels;
          this._application = _application;
          __publicField(this, "_encoder");
          __publicField(this, "_decoder");
        }
        _ensureEncoder() {
          if (this._encoder) return;
          this._encoder = new Encoder({
            channels: this._channels,
            sample_rate: this._rate,
            application: {
              2048: "voip",
              2049: "audio",
              2051: "restricted_lowdelay"
            }[this._application]
          });
        }
        _ensureDecoder() {
          if (this._decoder) return;
          this._decoder = new Decoder({
            channels: this._channels,
            sample_rate: this._rate
          });
        }
        encode(buffer) {
          this._ensureEncoder();
          return Buffer.from(this._encoder.encode(buffer));
        }
        decode(buffer) {
          this._ensureDecoder();
          return Buffer.from(this._decoder.decode(buffer));
        }
        applyEncoderCTL(ctl, value) {
          this._ensureEncoder();
          this._encoder.ctl(ctl, value);
        }
        delete() {
          this._encoder = null;
          this._decoder = null;
        }
      };
      __name(_OpusEncoder2, "OpusEncoder");
      let OpusEncoder2 = _OpusEncoder2;
      return { Encoder: OpusEncoder2 };
    }
  ],
  ["node-opus", (opus) => ({ Encoder: opus.OpusEncoder })]
];
var Opus = {};
var addLibopusProvider = /* @__PURE__ */ __name((provider) => {
  if (OPUS_MOD_REGISTRY.some(([, fn]) => fn === provider[1])) return;
  OPUS_MOD_REGISTRY.push(provider);
}, "addLibopusProvider");
var removeLibopusProvider = /* @__PURE__ */ __name((name) => {
  const index = OPUS_MOD_REGISTRY.findIndex((o) => o[0] === name);
  if (index === -1) return false;
  OPUS_MOD_REGISTRY.splice(index, 1);
  return true;
}, "removeLibopusProvider");
var setLibopusProvider = /* @__PURE__ */ __name((provider, name) => {
  Opus = { Encoder: provider, name };
}, "setLibopusProvider");
function loadOpus(refresh = false) {
  if (Opus.Encoder && !refresh) return Opus;
  Opus = loadModule(OPUS_MOD_REGISTRY);
  return Opus;
}
__name(loadOpus, "loadOpus");
var charCode2 = /* @__PURE__ */ __name((x) => x.charCodeAt(0), "charCode");
var OPUS_HEAD2 = Buffer.from([..."OpusHead"].map(charCode2));
var OPUS_TAGS2 = Buffer.from([..."OpusTags"].map(charCode2));
var _OpusStream = class _OpusStream extends import_node_stream2.Transform {
  /**
   * Creates a new Opus transformer.
   * @private
   * @memberof opus
   * @param {Object} [options] options that you would pass to a regular Transform stream
   */
  constructor(options = {}) {
    if (!loadOpus().Encoder) {
      throw Error(
        `Could not find an Opus module! Please install one of ${OPUS_MOD_REGISTRY.map((o) => o[0]).join(", ")}.`
      );
    }
    super(Object.assign({ readableObjectMode: true }, options));
    __publicField(this, "encoder", null);
    __publicField(this, "_options");
    __publicField(this, "_required");
    const lib = Opus;
    if (lib.name === "opusscript") {
      options.application = lib.Encoder.Application[options.application];
    }
    this.encoder = new lib.Encoder(options.rate, options.channels, options.application);
    this._options = options;
    this._required = this._options.frameSize * this._options.channels * 2;
  }
  _encode(buffer) {
    if (Opus.name === "opusscript") {
      return this.encoder.encode(buffer, this._options.frameSize);
    } else {
      return this.encoder.encode(buffer);
    }
  }
  _decode(buffer) {
    if (Opus.name === "opusscript") {
      return this.encoder.decode(buffer, this._options.frameSize);
    } else {
      return this.encoder.decode(buffer);
    }
  }
  /**
   * Returns the Opus module being used - `mediaplex`, `opusscript`, `node-opus`, or `@discordjs/opus`.
   * @type {string}
   * @readonly
   * @example
   * console.log(`Using Opus module ${OpusEncoder.type}`);
   */
  static get type() {
    return Opus.name;
  }
  /**
   * Sets the bitrate of the stream.
   * @param {number} bitrate the bitrate to use use, e.g. 48000
   * @public
   */
  setBitrate(bitrate) {
    (this.encoder.applyEncoderCTL || this.encoder.encoderCTL).apply(
      this.encoder,
      [
        CTL.BITRATE,
        Math.min(128e3, Math.max(16e3, bitrate))
      ]
    );
  }
  /**
   * Enables or disables forward error correction.
   * @param {boolean} enabled whether or not to enable FEC.
   * @public
   */
  setFEC(enabled) {
    (this.encoder.applyEncoderCTL || this.encoder.encoderCTL).apply(this.encoder, [CTL.FEC, enabled ? 1 : 0]);
  }
  /**
   * Sets the expected packet loss over network transmission.
   * @param {number} [percentage] a percentage (represented between 0 and 1)
   */
  setPLP(percentage) {
    (this.encoder.applyEncoderCTL || this.encoder.encoderCTL).apply(
      this.encoder,
      [
        CTL.PLP,
        Math.min(100, Math.max(0, percentage * 100))
      ]
    );
  }
  _final(cb) {
    this._cleanup();
    cb();
  }
  _destroy(err, cb) {
    this._cleanup();
    return cb ? cb(err) : void 0;
  }
  /**
   * Cleans up the Opus stream when it is no longer needed
   * @private
   */
  _cleanup() {
    if (typeof this.encoder?.delete === "function") this.encoder.delete();
    this.encoder = null;
  }
};
__name(_OpusStream, "OpusStream");
var OpusStream = _OpusStream;
var _OpusEncoder = class _OpusEncoder extends OpusStream {
  /**
   * Creates a new Opus encoder stream.
   * @memberof opus
   * @param {Object} options options that you would pass to a regular OpusStream, plus a few more:
   * @param {number} options.frameSize the frame size in bytes to use (e.g. 960 for stereo audio at 48KHz with a frame
   * duration of 20ms)
   * @param {number} options.channels the number of channels to use
   * @param {number} options.rate the sampling rate in Hz
   */
  constructor(options = {}) {
    super(options);
    __publicField(this, "_buffer", Buffer.allocUnsafe(0));
  }
  _transform(newChunk, encoding, done) {
    const chunk = Buffer.concat([this._buffer, newChunk]);
    let i = 0;
    while (chunk.length >= i + this._required) {
      const pcm = chunk.slice(i, i + this._required);
      let opus;
      try {
        opus = this.encoder.encode(pcm);
      } catch (error) {
        done(error);
        return;
      }
      this.push(opus);
      i += this._required;
    }
    if (i > 0) this._buffer = chunk.slice(i);
    done();
  }
  _destroy(err, cb) {
    super._destroy(err, cb);
    this._buffer = Buffer.allocUnsafe(0);
  }
};
__name(_OpusEncoder, "OpusEncoder");
var OpusEncoder = _OpusEncoder;
var _OpusDecoder = class _OpusDecoder extends OpusStream {
  _transform(chunk, encoding, done) {
    const signature = chunk.slice(0, 8);
    if (chunk.length >= 8 && signature.equals(OPUS_HEAD2)) {
      this.emit("format", {
        channels: this._options.channels,
        sampleRate: this._options.rate,
        bitDepth: 16,
        float: false,
        signed: true,
        version: chunk.readUInt8(8),
        preSkip: chunk.readUInt16LE(10),
        gain: chunk.readUInt16LE(16)
      });
      return done();
    }
    if (chunk.length >= 8 && signature.equals(OPUS_TAGS2)) {
      this.emit("tags", chunk);
      return done();
    }
    try {
      this.push(this._decode(chunk));
    } catch (e) {
      return done(e);
    }
    return done();
  }
};
__name(_OpusDecoder, "OpusDecoder");
var OpusDecoder = _OpusDecoder;

// src/WebmBase.ts
var import_node_stream3 = require("stream");
var _WebmBaseDemuxer = class _WebmBaseDemuxer extends import_node_stream3.Transform {
  /**
   * Creates a new Webm demuxer.
   * @param {Object} [options] options that you would pass to a regular Transform stream.
   */
  constructor(options = {}) {
    super(Object.assign({ readableObjectMode: true }, options));
    __publicField(this, "_remainder", null);
    __publicField(this, "_length", 0);
    __publicField(this, "_count", 0);
    __publicField(this, "_skipUntil", null);
    __publicField(this, "_track", null);
    __publicField(this, "_incompleteTrack", {});
    __publicField(this, "_ebmlFound", false);
    this._remainder = null;
    this._length = 0;
    this._count = 0;
    this._skipUntil = null;
    this._track = null;
    this._incompleteTrack = {};
    this._ebmlFound = false;
  }
  _checkHead(data) {
  }
  _transform(chunk, encoding, done) {
    this._length += chunk.length;
    if (this._remainder) {
      chunk = Buffer.concat([this._remainder, chunk]);
      this._remainder = null;
    }
    let offset = 0;
    if (this._skipUntil && this._length > this._skipUntil) {
      offset = this._skipUntil - this._count;
      this._skipUntil = null;
    } else if (this._skipUntil) {
      this._count += chunk.length;
      done();
      return;
    }
    let result;
    while (result !== _WebmBaseDemuxer.TOO_SHORT) {
      try {
        result = this._readTag(chunk, offset);
      } catch (error) {
        done(error);
        return;
      }
      if (result === _WebmBaseDemuxer.TOO_SHORT) break;
      if (result._skipUntil) {
        this._skipUntil = result._skipUntil;
        break;
      }
      if (result.offset) offset = result.offset;
      else
        break;
    }
    this._count += offset;
    this._remainder = chunk.subarray(offset);
    done();
    return;
  }
  /**
   * Reads an EBML ID from a buffer.
   * @private
   * @param {Buffer} chunk the buffer to read from.
   * @param {number} offset the offset in the buffer.
   * @returns {Object|Symbol} contains an `id` property (buffer) and the new `offset` (number).
   * Returns the TOO_SHORT symbol if the data wasn't big enough to facilitate the request.
   */
  _readEBMLId(chunk, offset) {
    const idLength = vintLength(chunk, offset);
    if (idLength === _WebmBaseDemuxer.TOO_SHORT) return _WebmBaseDemuxer.TOO_SHORT;
    return {
      id: chunk.subarray(offset, offset + idLength),
      offset: offset + idLength
    };
  }
  /**
   * Reads a size variable-integer to calculate the length of the data of a tag.
   * @private
   * @param {Buffer} chunk the buffer to read from.
   * @param {number} offset the offset in the buffer.
   * @returns {Object|Symbol} contains property `offset` (number), `dataLength` (number) and `sizeLength` (number).
   * Returns the TOO_SHORT symbol if the data wasn't big enough to facilitate the request.
   */
  _readTagDataSize(chunk, offset) {
    const sizeLength = vintLength(chunk, offset);
    if (sizeLength === _WebmBaseDemuxer.TOO_SHORT) return _WebmBaseDemuxer.TOO_SHORT;
    const dataLength = expandVint(chunk, offset, offset + sizeLength);
    return { offset: offset + sizeLength, dataLength, sizeLength };
  }
  /**
   * Takes a buffer and attempts to read and process a tag.
   * @private
   * @param {Buffer} chunk the buffer to read from.
   * @param {number} offset the offset in the buffer.
   * @returns {Object|Symbol} contains the new `offset` (number) and optionally the `_skipUntil` property,
   * indicating that the stream should ignore any data until a certain length is reached.
   * Returns the TOO_SHORT symbol if the data wasn't big enough to facilitate the request.
   */
  _readTag(chunk, offset) {
    const idData = this._readEBMLId(chunk, offset);
    if (idData === _WebmBaseDemuxer.TOO_SHORT) return _WebmBaseDemuxer.TOO_SHORT;
    const ebmlID = idData.id.toString("hex");
    if (!this._ebmlFound) {
      if (ebmlID === "1a45dfa3") this._ebmlFound = true;
      else
        throw Error("Did not find the EBML tag at the start of the stream");
    }
    offset = idData.offset;
    const sizeData = this._readTagDataSize(chunk, offset);
    if (sizeData === _WebmBaseDemuxer.TOO_SHORT) return _WebmBaseDemuxer.TOO_SHORT;
    const { dataLength } = sizeData;
    offset = sizeData.offset;
    if (typeof _WebmBaseDemuxer.TAGS[ebmlID] === "undefined") {
      if (chunk.length > offset + dataLength) {
        return { offset: offset + dataLength };
      }
      return { offset, _skipUntil: this._count + offset + dataLength };
    }
    const tagHasChildren = _WebmBaseDemuxer.TAGS[ebmlID];
    if (tagHasChildren) {
      return { offset };
    }
    if (offset + dataLength > chunk.length) return _WebmBaseDemuxer.TOO_SHORT;
    const data = chunk.subarray(offset, offset + dataLength);
    if (!this._track) {
      if (ebmlID === "ae") this._incompleteTrack = {};
      if (ebmlID === "d7") this._incompleteTrack.number = data[0];
      if (ebmlID === "83") this._incompleteTrack.type = data[0];
      if (this._incompleteTrack.type === 2 && typeof this._incompleteTrack.number !== "undefined") {
        this._track = this._incompleteTrack;
      }
    }
    if (ebmlID === "63a2") {
      this._checkHead(data);
      this.emit("head", data);
    } else if (ebmlID === "a3") {
      if (!this._track) throw Error("No audio track in this webm!");
      if ((data[0] & 15) === this._track.number) {
        this.push(data.subarray(4));
      }
    }
    return { offset: offset + dataLength };
  }
  _destroy(err, cb) {
    this._cleanup();
    return cb ? cb(err) : void 0;
  }
  _final(cb) {
    this._cleanup();
    cb();
  }
  /**
   * Cleans up the demuxer when it is no longer required.
   * @private
   */
  _cleanup() {
    this._remainder = null;
    this._incompleteTrack = {};
  }
};
__name(_WebmBaseDemuxer, "WebmBaseDemuxer");
__publicField(_WebmBaseDemuxer, "TAGS", {
  // value is true if the element has children
  "1a45dfa3": true,
  // EBML
  "18538067": true,
  // Segment
  "1f43b675": true,
  // Cluster
  "1654ae6b": true,
  // Tracks
  ae: true,
  // TrackEntry
  d7: false,
  // TrackNumber
  "83": false,
  // TrackType
  a3: false,
  // SimpleBlock
  "63a2": false
});
__publicField(_WebmBaseDemuxer, "TOO_SHORT", Symbol("TOO_SHORT"));
var WebmBaseDemuxer = _WebmBaseDemuxer;
function vintLength(buffer, index) {
  if (index < 0 || index > buffer.length - 1) {
    return WebmBaseDemuxer.TOO_SHORT;
  }
  let i = 0;
  for (; i < 8; i++) if (1 << 7 - i & buffer[index]) break;
  i++;
  if (index + i > buffer.length) {
    return WebmBaseDemuxer.TOO_SHORT;
  }
  return i;
}
__name(vintLength, "vintLength");
function expandVint(buffer, start, end) {
  const length = vintLength(buffer, start);
  if (end > buffer.length || length === WebmBaseDemuxer.TOO_SHORT) return WebmBaseDemuxer.TOO_SHORT;
  const mask = (1 << 8 - length) - 1;
  let value = buffer[start] & mask;
  for (let i = start + 1; i < end; i++) {
    value = (value << 8) + buffer[i];
  }
  return value;
}
__name(expandVint, "expandVint");

// src/WebmDemuxer.ts
var OPUS_HEAD3 = Buffer.from([..."OpusHead"].map((x) => x.charCodeAt(0)));
var _WebmDemuxer = class _WebmDemuxer extends WebmBaseDemuxer {
  _checkHead(data) {
    if (!data.subarray(0, 8).equals(OPUS_HEAD3)) {
      throw Error("Audio codec is not Opus!");
    }
  }
};
__name(_WebmDemuxer, "WebmDemuxer");
var WebmDemuxer = _WebmDemuxer;

// src/version.ts
var version = (
  /* @__MACRO__ getVersion */
  "7.0.0"
);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  CTL,
  OggDemuxer,
  OpusDecoder,
  OpusEncoder,
  OpusStream,
  WebmDemuxer,
  addLibopusProvider,
  removeLibopusProvider,
  setLibopusProvider,
  version
});
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vc3JjL2luZGV4LnRzIiwgIi4uL3NyYy9PZ2dEZW11eGVyLnRzIiwgIi4uL3NyYy9PcHVzRW5jb2Rlci50cyIsICIuLi9zcmMvV2VibUJhc2UudHMiLCAiLi4vc3JjL1dlYm1EZW11eGVyLnRzIiwgIi4uL3NyYy92ZXJzaW9uLnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyJleHBvcnQgKiBmcm9tICcuL09nZ0RlbXV4ZXInO1xuZXhwb3J0ICogZnJvbSAnLi9PcHVzRW5jb2Rlcic7XG5leHBvcnQgKiBmcm9tICcuL1dlYm1EZW11eGVyJztcblxuZXhwb3J0IHsgdmVyc2lvbiB9IGZyb20gJy4vdmVyc2lvbic7IiwgIi8vIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9hbWlzaHNoYWgvcHJpc20tbWVkaWEvYmxvYi80ZWYxZDZmOWY1MzA0MmMwODVjMWY2ODYyN2U4ODkwMDNlMjQ4ZDc3L3NyYy9vcHVzL09nZ0RlbXV4ZXIuanNcblxuaW1wb3J0IHsgVHJhbnNmb3JtLCBUcmFuc2Zvcm1DYWxsYmFjayB9IGZyb20gJ25vZGU6c3RyZWFtJztcblxuY29uc3QgT0dHX1BBR0VfSEVBREVSX1NJWkUgPSAyNjtcbmNvbnN0IFNUUkVBTV9TVFJVQ1RVUkVfVkVSU0lPTiA9IDA7XG5cbmNvbnN0IGNoYXJDb2RlID0gKHg6IHN0cmluZykgPT4geC5jaGFyQ29kZUF0KDApO1xuY29uc3QgT0dHU19IRUFERVIgPSBCdWZmZXIuZnJvbShbLi4uJ09nZ1MnXS5tYXAoY2hhckNvZGUpKTtcbmNvbnN0IE9QVVNfSEVBRCA9IEJ1ZmZlci5mcm9tKFsuLi4nT3B1c0hlYWQnXS5tYXAoY2hhckNvZGUpKTtcbmNvbnN0IE9QVVNfVEFHUyA9IEJ1ZmZlci5mcm9tKFsuLi4nT3B1c1RhZ3MnXS5tYXAoY2hhckNvZGUpKTtcblxuLyoqXG4gKiBEZW11eGVzIGFuIE9nZyBzdHJlYW0gKGNvbnRhaW5pbmcgT3B1cyBhdWRpbykgdG8gb3V0cHV0IGFuIE9wdXMgc3RyZWFtLlxuICovXG5leHBvcnQgY2xhc3MgT2dnRGVtdXhlciBleHRlbmRzIFRyYW5zZm9ybSB7XG4gIHByaXZhdGUgX3JlbWFpbmRlcjogQnVmZmVyIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgX2hlYWQ6IEJ1ZmZlciB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIF9iaXRzdHJlYW06IG51bWJlciB8IG51bGwgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IE9nZ09wdXMgZGVtdXhlci5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBvcHRpb25zIHRoYXQgeW91IHdvdWxkIHBhc3MgdG8gYSByZWd1bGFyIFRyYW5zZm9ybSBzdHJlYW0uXG4gICAqIEBtZW1iZXJvZiBvcHVzXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbih7IHJlYWRhYmxlT2JqZWN0TW9kZTogdHJ1ZSB9LCBvcHRpb25zKSk7XG4gICAgdGhpcy5fcmVtYWluZGVyID0gbnVsbDtcbiAgICB0aGlzLl9oZWFkID0gbnVsbDtcbiAgICB0aGlzLl9iaXRzdHJlYW0gPSBudWxsO1xuICB9XG5cbiAgX3RyYW5zZm9ybShjaHVuazogQnVmZmVyLCBlbmNvZGluZzogQnVmZmVyRW5jb2RpbmcsIGRvbmU6IFRyYW5zZm9ybUNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuX3JlbWFpbmRlcikge1xuICAgICAgY2h1bmsgPSBCdWZmZXIuY29uY2F0KFt0aGlzLl9yZW1haW5kZXIsIGNodW5rXSk7XG4gICAgICB0aGlzLl9yZW1haW5kZXIgPSBudWxsO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICB3aGlsZSAoY2h1bmspIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fcmVhZFBhZ2UoY2h1bmspO1xuICAgICAgICBpZiAocmVzdWx0KSBjaHVuayA9IHJlc3VsdDtlbHNlXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBkb25lKGVycm9yIGFzIEVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9yZW1haW5kZXIgPSBjaHVuaztcbiAgICBkb25lKCk7XG4gIH1cblxuICAvKipcbiAgICogUmVhZHMgYSBwYWdlIGZyb20gYSBidWZmZXJcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGNodW5rIHRoZSBjaHVuayBjb250YWluaW5nIHRoZSBwYWdlXG4gICAqIEByZXR1cm5zIHtib29sZWFufEJ1ZmZlcn0gaWYgYSBidWZmZXIsIGl0IHdpbGwgYmUgYSBzbGljZSBvZiB0aGUgZXhjZXNzIGRhdGEgb2YgdGhlIG9yaWdpbmFsLCBvdGhlcndpc2UgaXQgd2lsbCBiZVxuICAgKiBmYWxzZSBhbmQgd291bGQgaW5kaWNhdGUgdGhhdCB0aGVyZSBpcyBub3QgZW5vdWdoIGRhdGEgdG8gZ28gYWhlYWQgd2l0aCByZWFkaW5nIHRoaXMgcGFnZS5cbiAgICovXG4gIF9yZWFkUGFnZShjaHVuazogQnVmZmVyKSB7XG4gICAgaWYgKGNodW5rLmxlbmd0aCA8IE9HR19QQUdFX0hFQURFUl9TSVpFKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghY2h1bmsuc3ViYXJyYXkoMCwgNCkuZXF1YWxzKE9HR1NfSEVBREVSKSkge1xuICAgICAgdGhyb3cgRXJyb3IoYGNhcHR1cmVfcGF0dGVybiBpcyBub3QgJHtPR0dTX0hFQURFUn1gKTtcbiAgICB9XG4gICAgaWYgKGNodW5rLnJlYWRVSW50OCg0KSAhPT0gU1RSRUFNX1NUUlVDVFVSRV9WRVJTSU9OKSB7XG4gICAgICB0aHJvdyBFcnJvcihgc3RyZWFtX3N0cnVjdHVyZV92ZXJzaW9uIGlzIG5vdCAke1NUUkVBTV9TVFJVQ1RVUkVfVkVSU0lPTn1gKTtcbiAgICB9XG5cbiAgICBpZiAoY2h1bmsubGVuZ3RoIDwgMjcpIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBwYWdlU2VnbWVudHMgPSBjaHVuay5yZWFkVUludDgoMjYpO1xuICAgIGlmIChjaHVuay5sZW5ndGggPCAyNyArIHBhZ2VTZWdtZW50cykgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHRhYmxlID0gY2h1bmsuc3ViYXJyYXkoMjcsIDI3ICsgcGFnZVNlZ21lbnRzKTtcbiAgICBjb25zdCBiaXRzdHJlYW0gPSBjaHVuay5yZWFkVUludDMyQkUoMTQpO1xuXG4gICAgY29uc3Qgc2l6ZXM6IG51bWJlcltdID0gW107XG4gICAgbGV0IHRvdGFsU2l6ZSA9IDA7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZ2VTZWdtZW50czspIHtcbiAgICAgIGxldCBzaXplID0gMCxcbiAgICAgICAgeCA9IDI1NTtcbiAgICAgIHdoaWxlICh4ID09PSAyNTUpIHtcbiAgICAgICAgaWYgKGkgPj0gdGFibGUubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHggPSB0YWJsZS5yZWFkVUludDgoaSk7XG4gICAgICAgIGkrKztcbiAgICAgICAgc2l6ZSArPSB4O1xuICAgICAgfVxuICAgICAgc2l6ZXMucHVzaChzaXplKTtcbiAgICAgIHRvdGFsU2l6ZSArPSBzaXplO1xuICAgIH1cblxuICAgIGlmIChjaHVuay5sZW5ndGggPCAyNyArIHBhZ2VTZWdtZW50cyArIHRvdGFsU2l6ZSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgbGV0IHN0YXJ0ID0gMjcgKyBwYWdlU2VnbWVudHM7XG4gICAgZm9yIChjb25zdCBzaXplIG9mIHNpemVzKSB7XG4gICAgICBjb25zdCBzZWdtZW50ID0gY2h1bmsuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgc2l6ZSk7XG4gICAgICBjb25zdCBoZWFkZXIgPSBzZWdtZW50LnN1YmFycmF5KDAsIDgpO1xuICAgICAgaWYgKHRoaXMuX2hlYWQpIHtcbiAgICAgICAgaWYgKGhlYWRlci5lcXVhbHMoT1BVU19UQUdTKSkgdGhpcy5lbWl0KCd0YWdzJywgc2VnbWVudCk7ZWxzZVxuICAgICAgICBpZiAodGhpcy5fYml0c3RyZWFtID09PSBiaXRzdHJlYW0pIHRoaXMucHVzaChzZWdtZW50KTtcbiAgICAgIH0gZWxzZSBpZiAoaGVhZGVyLmVxdWFscyhPUFVTX0hFQUQpKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnaGVhZCcsIHNlZ21lbnQpO1xuICAgICAgICB0aGlzLl9oZWFkID0gc2VnbWVudDtcbiAgICAgICAgdGhpcy5fYml0c3RyZWFtID0gYml0c3RyZWFtO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lbWl0KCd1bmtub3duU2VnbWVudCcsIHNlZ21lbnQpO1xuICAgICAgfVxuICAgICAgc3RhcnQgKz0gc2l6ZTtcbiAgICB9XG4gICAgcmV0dXJuIGNodW5rLnN1YmFycmF5KHN0YXJ0KTtcbiAgfVxuXG4gIF9kZXN0cm95KGVycjogRXJyb3IsIGNiOiAoZXJyb3I6IEVycm9yIHwgbnVsbCkgPT4gdm9pZCkge1xuICAgIHRoaXMuX2NsZWFudXAoKTtcbiAgICByZXR1cm4gY2IgPyBjYihlcnIpIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgX2ZpbmFsKGNiOiBUcmFuc2Zvcm1DYWxsYmFjaykge1xuICAgIHRoaXMuX2NsZWFudXAoKTtcbiAgICBjYigpO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFucyB1cCB0aGUgZGVtdXhlciB3aGVuIGl0IGlzIG5vIGxvbmdlciByZXF1aXJlZC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jbGVhbnVwKCkge1xuICAgIHRoaXMuX3JlbWFpbmRlciA9IG51bGw7XG4gICAgdGhpcy5faGVhZCA9IG51bGw7XG4gICAgdGhpcy5fYml0c3RyZWFtID0gbnVsbDtcbiAgfVxufSIsICIvLyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vYW1pc2hzaGFoL3ByaXNtLW1lZGlhL2Jsb2IvNGVmMWQ2ZjlmNTMwNDJjMDg1YzFmNjg2MjdlODg5MDAzZTI0OGQ3Ny9zcmMvb3B1cy9PcHVzLmpzXG5cbmltcG9ydCB7IFRyYW5zZm9ybSwgdHlwZSBUcmFuc2Zvcm1DYWxsYmFjayB9IGZyb20gJ25vZGU6c3RyZWFtJztcblxuZXhwb3J0IHR5cGUgSUVuY29kZXIgPSB7XG4gIG5ldyAocmF0ZTogbnVtYmVyLCBjaGFubmVsczogbnVtYmVyLCBhcHBsaWNhdGlvbjogbnVtYmVyKToge1xuICAgIGVuY29kZShidWZmZXI6IEJ1ZmZlcik6IEJ1ZmZlcjtcbiAgICBlbmNvZGUoYnVmZmVyOiBCdWZmZXIsIGZyYW1lU2l6ZTogbnVtYmVyKTogQnVmZmVyO1xuICAgIGVuY29kZShidWZmZXI6IEJ1ZmZlciwgZnJhbWVTaXplPzogbnVtYmVyKTogQnVmZmVyO1xuICAgIGRlY29kZShidWZmZXI6IEJ1ZmZlcik6IEJ1ZmZlcjtcbiAgICBkZWNvZGUoYnVmZmVyOiBCdWZmZXIsIGZyYW1lU2l6ZTogbnVtYmVyKTogQnVmZmVyO1xuICAgIGRlY29kZShidWZmZXI6IEJ1ZmZlciwgZnJhbWVTaXplPzogbnVtYmVyKTogQnVmZmVyO1xuICAgIGFwcGx5RW5jb2RlckNUTD8oY3RsOiBudW1iZXIsIHZhbHVlOiBudW1iZXIpOiB2b2lkO1xuICAgIGVuY29kZXJDVEw/KGN0bDogbnVtYmVyLCB2YWx1ZTogbnVtYmVyKTogdm9pZDtcbiAgICBkZWxldGU/KCk6IHZvaWQ7XG4gIH07XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gIEFwcGxpY2F0aW9uPzogYW55O1xufTtcblxudHlwZSBJTW9kID0gW1xuICBzdHJpbmcsXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gIChtb2Q6IGFueSkgPT4ge1xuICAgIEVuY29kZXI6IElFbmNvZGVyO1xuICB9XTtcblxuXG5jb25zdCBsb2FkTW9kdWxlID0gKFxubW9kdWxlczogSU1vZFtdKVxuOiB7XG4gIEVuY29kZXI6IElFbmNvZGVyO1xuICBuYW1lOiBzdHJpbmc7XG59ID0+IHtcbiAgY29uc3QgZXJyb3JzOiBzdHJpbmdbXSA9IFtdO1xuXG4gIGZvciAoY29uc3QgW25hbWUsIGZuXSBvZiBtb2R1bGVzKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdmFyLXJlcXVpcmVzXG4gICAgICAgIC4uLmZuKHJlcXVpcmUobmFtZSkpLFxuICAgICAgICBuYW1lXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVycm9ycy5wdXNoKGBGYWlsZWQgdG8gbG9hZCAke25hbWV9OiAke2V9YCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgYENvdWxkIG5vdCBsb2FkIG9wdXMgbW9kdWxlLCB0cmllZCAke21vZHVsZXMubGVuZ3RofSBkaWZmZXJlbnQgbW9kdWxlcy4gRXJyb3JzOiAke2Vycm9ycy5qb2luKCdcXG4nKX1gXG4gICk7XG59O1xuXG5leHBvcnQgY29uc3QgQ1RMID0ge1xuICBCSVRSQVRFOiAweGZhMixcbiAgRkVDOiAweGZhYyxcbiAgUExQOiAweGZhZVxufSBhcyBjb25zdDtcblxuY29uc3QgT1BVU19NT0RfUkVHSVNUUlk6IElNb2RbXSA9IFtcbltcbidtZWRpYXBsZXgnLFxuKG1vZCkgPT4ge1xuICBpZiAoIW1vZC5PcHVzRW5jb2RlcikgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBtZWRpYXBsZXggdmVyc2lvbicpO1xuICByZXR1cm4geyBFbmNvZGVyOiBtb2QuT3B1c0VuY29kZXIgfTtcbn1dLFxuXG5bJ0BkaXNjb3JkanMvb3B1cycsIChvcHVzKSA9PiAoeyBFbmNvZGVyOiBvcHVzLk9wdXNFbmNvZGVyIH0pXSxcblsnb3B1c3NjcmlwdCcsIChvcHVzKSA9PiAoeyBFbmNvZGVyOiBvcHVzIH0pXSxcbltcbidAZXZhbi9vcHVzJyxcbihvcHVzKSA9PiB7XG4gIGNvbnN0IHsgRW5jb2RlciwgRGVjb2RlciB9ID0gb3B1cyBhcyB0eXBlb2YgaW1wb3J0KCdAZXZhbi9vcHVzJyk7XG5cbiAgY2xhc3MgT3B1c0VuY29kZXIge1xuICAgIHByaXZhdGUgX2VuY29kZXIhOiBJbnN0YW5jZVR5cGU8dHlwZW9mIEVuY29kZXI+IHwgbnVsbDtcbiAgICBwcml2YXRlIF9kZWNvZGVyITogSW5zdGFuY2VUeXBlPHR5cGVvZiBEZWNvZGVyPiB8IG51bGw7XG5cbiAgICBwdWJsaWMgY29uc3RydWN0b3IocHJpdmF0ZSBfcmF0ZTogbnVtYmVyLCBwcml2YXRlIF9jaGFubmVsczogbnVtYmVyLCBwcml2YXRlIF9hcHBsaWNhdGlvbjogbnVtYmVyKSB7fVxuXG4gICAgcHJpdmF0ZSBfZW5zdXJlRW5jb2RlcigpIHtcbiAgICAgIGlmICh0aGlzLl9lbmNvZGVyKSByZXR1cm47XG4gICAgICB0aGlzLl9lbmNvZGVyID0gbmV3IEVuY29kZXIoe1xuICAgICAgICBjaGFubmVsczogdGhpcy5fY2hhbm5lbHMgYXMgMixcbiAgICAgICAgc2FtcGxlX3JhdGU6IHRoaXMuX3JhdGUgYXMgNDgwMDAsXG4gICAgICAgIGFwcGxpY2F0aW9uOiAoPGNvbnN0PiB7XG4gICAgICAgICAgMjA0ODogJ3ZvaXAnLFxuICAgICAgICAgIDIwNDk6ICdhdWRpbycsXG4gICAgICAgICAgMjA1MTogJ3Jlc3RyaWN0ZWRfbG93ZGVsYXknXG4gICAgICAgIH0pW3RoaXMuX2FwcGxpY2F0aW9uXVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfZW5zdXJlRGVjb2RlcigpIHtcbiAgICAgIGlmICh0aGlzLl9kZWNvZGVyKSByZXR1cm47XG4gICAgICB0aGlzLl9kZWNvZGVyID0gbmV3IERlY29kZXIoe1xuICAgICAgICBjaGFubmVsczogdGhpcy5fY2hhbm5lbHMgYXMgMixcbiAgICAgICAgc2FtcGxlX3JhdGU6IHRoaXMuX3JhdGUgYXMgNDgwMDBcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHB1YmxpYyBlbmNvZGUoYnVmZmVyOiBCdWZmZXIpIHtcbiAgICAgIHRoaXMuX2Vuc3VyZUVuY29kZXIoKTtcbiAgICAgIHJldHVybiBCdWZmZXIuZnJvbSh0aGlzLl9lbmNvZGVyIS5lbmNvZGUoYnVmZmVyKSk7XG4gICAgfVxuXG4gICAgcHVibGljIGRlY29kZShidWZmZXI6IEJ1ZmZlcikge1xuICAgICAgdGhpcy5fZW5zdXJlRGVjb2RlcigpO1xuICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHRoaXMuX2RlY29kZXIhLmRlY29kZShidWZmZXIpKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgYXBwbHlFbmNvZGVyQ1RMKGN0bDogbnVtYmVyLCB2YWx1ZTogbnVtYmVyKSB7XG4gICAgICB0aGlzLl9lbnN1cmVFbmNvZGVyKCk7XG4gICAgICB0aGlzLl9lbmNvZGVyIS5jdGwoY3RsLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgcHVibGljIGRlbGV0ZSgpIHtcbiAgICAgIHRoaXMuX2VuY29kZXIgPSBudWxsO1xuICAgICAgdGhpcy5fZGVjb2RlciA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHsgRW5jb2RlcjogT3B1c0VuY29kZXIgfTtcbn1dLFxuXG5bJ25vZGUtb3B1cycsIChvcHVzKSA9PiAoeyBFbmNvZGVyOiBvcHVzLk9wdXNFbmNvZGVyIH0pXV07XG5cblxubGV0IE9wdXM6IHtFbmNvZGVyPzogSUVuY29kZXI7bmFtZT86IHN0cmluZzt9ID0ge307XG5cbi8qKlxuICogQWRkIGEgbmV3IE9wdXMgcHJvdmlkZXIgdG8gdGhlIHJlZ2lzdHJ5LiBUaGlzIHdpbGwgYmUgdHJpZWQgdG8gbG9hZCBpbiBvcmRlciBhdCBydW50aW1lLlxuICogQHBhcmFtIHByb3ZpZGVyIC0gVGhlIHByb3ZpZGVyIHRvIGFkZFxuICovXG5leHBvcnQgY29uc3QgYWRkTGlib3B1c1Byb3ZpZGVyID0gKHByb3ZpZGVyOiBJTW9kKSA9PiB7XG4gIGlmIChPUFVTX01PRF9SRUdJU1RSWS5zb21lKChbLCBmbl0pID0+IGZuID09PSBwcm92aWRlclsxXSkpIHJldHVybjtcbiAgT1BVU19NT0RfUkVHSVNUUlkucHVzaChwcm92aWRlcik7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbiBPcHVzIHByb3ZpZGVyIGZyb20gdGhlIHJlZ2lzdHJ5LlxuICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcHJvdmlkZXIgdG8gcmVtb3ZlXG4gKi9cbmV4cG9ydCBjb25zdCByZW1vdmVMaWJvcHVzUHJvdmlkZXIgPSAobmFtZTogc3RyaW5nKSA9PiB7XG4gIGNvbnN0IGluZGV4ID0gT1BVU19NT0RfUkVHSVNUUlkuZmluZEluZGV4KChvKSA9PiBvWzBdID09PSBuYW1lKTtcbiAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuIGZhbHNlO1xuICBPUFVTX01PRF9SRUdJU1RSWS5zcGxpY2UoaW5kZXgsIDEpO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBPcHVzIHByb3ZpZGVyIHRvIHVzZS4gVGhpcyB3aWxsIG92ZXJyaWRlIHRoZSBhdXRvbWF0aWMgcHJvdmlkZXIgc2VsZWN0aW9uLlxuICogQHBhcmFtIHByb3ZpZGVyIC0gVGhlIHByb3ZpZGVyIHRvIHVzZVxuICovXG5leHBvcnQgY29uc3Qgc2V0TGlib3B1c1Byb3ZpZGVyID0gKHByb3ZpZGVyOiBJRW5jb2RlciwgbmFtZTogc3RyaW5nKSA9PiB7XG4gIE9wdXMgPSB7IEVuY29kZXI6IHByb3ZpZGVyLCBuYW1lIH07XG59O1xuXG5mdW5jdGlvbiBsb2FkT3B1cyhyZWZyZXNoID0gZmFsc2UpIHtcbiAgaWYgKE9wdXMuRW5jb2RlciAmJiAhcmVmcmVzaCkgcmV0dXJuIE9wdXM7XG5cbiAgT3B1cyA9IGxvYWRNb2R1bGUoT1BVU19NT0RfUkVHSVNUUlkpO1xuICByZXR1cm4gT3B1cztcbn1cblxuY29uc3QgY2hhckNvZGUgPSAoeDogc3RyaW5nKSA9PiB4LmNoYXJDb2RlQXQoMCk7XG5jb25zdCBPUFVTX0hFQUQgPSBCdWZmZXIuZnJvbShbLi4uJ09wdXNIZWFkJ10ubWFwKGNoYXJDb2RlKSk7XG5jb25zdCBPUFVTX1RBR1MgPSBCdWZmZXIuZnJvbShbLi4uJ09wdXNUYWdzJ10ubWFwKGNoYXJDb2RlKSk7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSU9wdXNTdHJlYW1Jbml0IHtcbiAgZnJhbWVTaXplOiBudW1iZXI7XG4gIGNoYW5uZWxzOiBudW1iZXI7XG4gIHJhdGU6IG51bWJlcjtcbiAgYXBwbGljYXRpb24/OiBudW1iZXI7XG59XG5cbi8vIGZyYW1lIHNpemUgPSAoY2hhbm5lbHMgKiByYXRlICogZnJhbWVfZHVyYXRpb24pIC8gMTAwMFxuXG4vKipcbiAqIFRha2VzIGEgc3RyZWFtIG9mIE9wdXMgZGF0YSBhbmQgb3V0cHV0cyBhIHN0cmVhbSBvZiBQQ00gZGF0YSwgb3IgdGhlIGludmVyc2UuXG4gKiAqKllvdSBzaG91bGRuJ3QgZGlyZWN0bHkgaW5zdGFudGlhdGUgdGhpcyBjbGFzcywgc2VlIG9wdXMuRW5jb2RlciBhbmQgb3B1cy5EZWNvZGVyIGluc3RlYWQhKipcbiAqIEBtZW1iZXJvZiBvcHVzXG4gKiBAZXh0ZW5kcyBUcmFuc2Zvcm1TdHJlYW1cbiAqIEBwcm90ZWN0ZWRcbiAqL1xuZXhwb3J0IGNsYXNzIE9wdXNTdHJlYW0gZXh0ZW5kcyBUcmFuc2Zvcm0ge1xuICBwdWJsaWMgZW5jb2RlcjogSW5zdGFuY2VUeXBlPElFbmNvZGVyPiB8IG51bGwgPSBudWxsO1xuICBwdWJsaWMgX29wdGlvbnM6IElPcHVzU3RyZWFtSW5pdDtcbiAgcHVibGljIF9yZXF1aXJlZDogbnVtYmVyO1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBPcHVzIHRyYW5zZm9ybWVyLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAbWVtYmVyb2Ygb3B1c1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIG9wdGlvbnMgdGhhdCB5b3Ugd291bGQgcGFzcyB0byBhIHJlZ3VsYXIgVHJhbnNmb3JtIHN0cmVhbVxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9IGFzIElPcHVzU3RyZWFtSW5pdCkge1xuICAgIGlmICghbG9hZE9wdXMoKS5FbmNvZGVyKSB7XG4gICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgYENvdWxkIG5vdCBmaW5kIGFuIE9wdXMgbW9kdWxlISBQbGVhc2UgaW5zdGFsbCBvbmUgb2YgJHtPUFVTX01PRF9SRUdJU1RSWS5tYXAoKG8pID0+IG9bMF0pLmpvaW4oJywgJyl9LmBcbiAgICAgICk7XG4gICAgfVxuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oeyByZWFkYWJsZU9iamVjdE1vZGU6IHRydWUgfSwgb3B0aW9ucykpO1xuXG4gICAgY29uc3QgbGliID0gT3B1cyBhcyBSZXF1aXJlZDx0eXBlb2YgT3B1cz47XG5cbiAgICBpZiAobGliLm5hbWUgPT09ICdvcHVzc2NyaXB0Jykge1xuICAgICAgb3B0aW9ucy5hcHBsaWNhdGlvbiA9IGxpYi5FbmNvZGVyLkFwcGxpY2F0aW9uIVtvcHRpb25zLmFwcGxpY2F0aW9uIV07XG4gICAgfVxuXG4gICAgdGhpcy5lbmNvZGVyID0gbmV3IGxpYi5FbmNvZGVyKG9wdGlvbnMucmF0ZSwgb3B0aW9ucy5jaGFubmVscywgb3B0aW9ucy5hcHBsaWNhdGlvbiEpO1xuXG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5fcmVxdWlyZWQgPSB0aGlzLl9vcHRpb25zLmZyYW1lU2l6ZSAqIHRoaXMuX29wdGlvbnMuY2hhbm5lbHMgKiAyO1xuICB9XG5cbiAgX2VuY29kZShidWZmZXI6IEJ1ZmZlcikge1xuICAgIGlmIChPcHVzLm5hbWUgPT09ICdvcHVzc2NyaXB0Jykge1xuICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlciEuZW5jb2RlKGJ1ZmZlciwgdGhpcy5fb3B0aW9ucy5mcmFtZVNpemUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmNvZGVyIS5lbmNvZGUoYnVmZmVyKTtcbiAgICB9XG4gIH1cblxuICBfZGVjb2RlKGJ1ZmZlcjogQnVmZmVyKSB7XG4gICAgaWYgKE9wdXMubmFtZSA9PT0gJ29wdXNzY3JpcHQnKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmNvZGVyIS5kZWNvZGUoYnVmZmVyLCB0aGlzLl9vcHRpb25zLmZyYW1lU2l6ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmVuY29kZXIhLmRlY29kZShidWZmZXIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBPcHVzIG1vZHVsZSBiZWluZyB1c2VkIC0gYG1lZGlhcGxleGAsIGBvcHVzc2NyaXB0YCwgYG5vZGUtb3B1c2AsIG9yIGBAZGlzY29yZGpzL29wdXNgLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAcmVhZG9ubHlcbiAgICogQGV4YW1wbGVcbiAgICogY29uc29sZS5sb2coYFVzaW5nIE9wdXMgbW9kdWxlICR7T3B1c0VuY29kZXIudHlwZX1gKTtcbiAgICovXG4gIHN0YXRpYyBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gT3B1cy5uYW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGJpdHJhdGUgb2YgdGhlIHN0cmVhbS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGJpdHJhdGUgdGhlIGJpdHJhdGUgdG8gdXNlIHVzZSwgZS5nLiA0ODAwMFxuICAgKiBAcHVibGljXG4gICAqL1xuICBzZXRCaXRyYXRlKGJpdHJhdGU6IG51bWJlcikge1xuICAgICh0aGlzLmVuY29kZXIhLmFwcGx5RW5jb2RlckNUTCEgfHwgdGhpcy5lbmNvZGVyIS5lbmNvZGVyQ1RMKS5hcHBseSh0aGlzLmVuY29kZXIhLCBbXG4gICAgQ1RMLkJJVFJBVEUsXG4gICAgTWF0aC5taW4oMTI4ZTMsIE1hdGgubWF4KDE2ZTMsIGJpdHJhdGUpKV1cbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEVuYWJsZXMgb3IgZGlzYWJsZXMgZm9yd2FyZCBlcnJvciBjb3JyZWN0aW9uLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZWQgd2hldGhlciBvciBub3QgdG8gZW5hYmxlIEZFQy5cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgc2V0RkVDKGVuYWJsZWQ6IGJvb2xlYW4pIHtcbiAgICAodGhpcy5lbmNvZGVyIS5hcHBseUVuY29kZXJDVEwhIHx8IHRoaXMuZW5jb2RlciEuZW5jb2RlckNUTCkuYXBwbHkodGhpcy5lbmNvZGVyISwgW0NUTC5GRUMsIGVuYWJsZWQgPyAxIDogMF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGV4cGVjdGVkIHBhY2tldCBsb3NzIG92ZXIgbmV0d29yayB0cmFuc21pc3Npb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbcGVyY2VudGFnZV0gYSBwZXJjZW50YWdlIChyZXByZXNlbnRlZCBiZXR3ZWVuIDAgYW5kIDEpXG4gICAqL1xuICBzZXRQTFAocGVyY2VudGFnZTogbnVtYmVyKSB7XG4gICAgKHRoaXMuZW5jb2RlciEuYXBwbHlFbmNvZGVyQ1RMISB8fCB0aGlzLmVuY29kZXIhLmVuY29kZXJDVEwpLmFwcGx5KHRoaXMuZW5jb2RlciEsIFtcbiAgICBDVEwuUExQLFxuICAgIE1hdGgubWluKDEwMCwgTWF0aC5tYXgoMCwgcGVyY2VudGFnZSAqIDEwMCkpXVxuICAgICk7XG4gIH1cblxuICBfZmluYWwoY2I6ICgpID0+IHZvaWQpIHtcbiAgICB0aGlzLl9jbGVhbnVwKCk7XG4gICAgY2IoKTtcbiAgfVxuXG4gIF9kZXN0cm95KGVycjogRXJyb3IgfCBudWxsLCBjYjogKGVycjogRXJyb3IgfCBudWxsKSA9PiB2b2lkKSB7XG4gICAgdGhpcy5fY2xlYW51cCgpO1xuICAgIHJldHVybiBjYiA/IGNiKGVycikgOiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYW5zIHVwIHRoZSBPcHVzIHN0cmVhbSB3aGVuIGl0IGlzIG5vIGxvbmdlciBuZWVkZWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jbGVhbnVwKCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5lbmNvZGVyPy5kZWxldGUgPT09ICdmdW5jdGlvbicpIHRoaXMuZW5jb2RlciEuZGVsZXRlISgpO1xuICAgIHRoaXMuZW5jb2RlciA9IG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBBbiBPcHVzIGVuY29kZXIgc3RyZWFtLlxuICpcbiAqIE91dHB1dHMgb3B1cyBwYWNrZXRzIGluIFtvYmplY3QgbW9kZS5dKGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvc3RyZWFtLmh0bWwjc3RyZWFtX29iamVjdF9tb2RlKVxuICogQGV4dGVuZHMgb3B1cy5PcHVzU3RyZWFtXG4gKiBAbWVtYmVyb2Ygb3B1c1xuICogQGV4YW1wbGVcbiAqIGNvbnN0IGVuY29kZXIgPSBuZXcgcHJpc20ub3B1cy5FbmNvZGVyKHsgZnJhbWVTaXplOiA5NjAsIGNoYW5uZWxzOiAyLCByYXRlOiA0ODAwMCB9KTtcbiAqIHBjbUF1ZGlvLnBpcGUoZW5jb2Rlcik7XG4gKiAvLyBlbmNvZGVyIHdpbGwgbm93IG91dHB1dCBPcHVzLWVuY29kZWQgYXVkaW8gcGFja2V0c1xuICovXG5leHBvcnQgY2xhc3MgT3B1c0VuY29kZXIgZXh0ZW5kcyBPcHVzU3RyZWFtIHtcbiAgX2J1ZmZlcjogQnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKDApO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IE9wdXMgZW5jb2RlciBzdHJlYW0uXG4gICAqIEBtZW1iZXJvZiBvcHVzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIG9wdGlvbnMgdGhhdCB5b3Ugd291bGQgcGFzcyB0byBhIHJlZ3VsYXIgT3B1c1N0cmVhbSwgcGx1cyBhIGZldyBtb3JlOlxuICAgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5mcmFtZVNpemUgdGhlIGZyYW1lIHNpemUgaW4gYnl0ZXMgdG8gdXNlIChlLmcuIDk2MCBmb3Igc3RlcmVvIGF1ZGlvIGF0IDQ4S0h6IHdpdGggYSBmcmFtZVxuICAgKiBkdXJhdGlvbiBvZiAyMG1zKVxuICAgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5jaGFubmVscyB0aGUgbnVtYmVyIG9mIGNoYW5uZWxzIHRvIHVzZVxuICAgKiBAcGFyYW0ge251bWJlcn0gb3B0aW9ucy5yYXRlIHRoZSBzYW1wbGluZyByYXRlIGluIEh6XG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30gYXMgSU9wdXNTdHJlYW1Jbml0KSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG4gIH1cblxuICBwdWJsaWMgX3RyYW5zZm9ybShuZXdDaHVuazogQnVmZmVyLCBlbmNvZGluZzogQnVmZmVyRW5jb2RpbmcsIGRvbmU6IFRyYW5zZm9ybUNhbGxiYWNrKTogdm9pZCB7XG4gICAgY29uc3QgY2h1bmsgPSBCdWZmZXIuY29uY2F0KFt0aGlzLl9idWZmZXIsIG5ld0NodW5rXSk7XG5cbiAgICBsZXQgaSA9IDA7XG4gICAgd2hpbGUgKGNodW5rLmxlbmd0aCA+PSBpICsgdGhpcy5fcmVxdWlyZWQpIHtcbiAgICAgIGNvbnN0IHBjbSA9IGNodW5rLnNsaWNlKGksIGkgKyB0aGlzLl9yZXF1aXJlZCk7XG4gICAgICBsZXQgb3B1czogQnVmZmVyIHwgdW5kZWZpbmVkO1xuICAgICAgdHJ5IHtcbiAgICAgICAgb3B1cyA9IHRoaXMuZW5jb2RlciEuZW5jb2RlKHBjbSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBkb25lKGVycm9yIGFzIEVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5wdXNoKG9wdXMpO1xuICAgICAgaSArPSB0aGlzLl9yZXF1aXJlZDtcbiAgICB9XG5cbiAgICBpZiAoaSA+IDApIHRoaXMuX2J1ZmZlciA9IGNodW5rLnNsaWNlKGkpO1xuICAgIGRvbmUoKTtcbiAgfVxuXG4gIF9kZXN0cm95KGVycjogRXJyb3IsIGNiOiAoZXJyOiBFcnJvciB8IG51bGwpID0+IHZvaWQpIHtcbiAgICBzdXBlci5fZGVzdHJveShlcnIsIGNiKTtcbiAgICB0aGlzLl9idWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMCk7XG4gIH1cbn1cblxuLyoqXG4gKiBBbiBPcHVzIGRlY29kZXIgc3RyZWFtLlxuICpcbiAqIE5vdGUgdGhhdCBhbnkgc3RyZWFtIHlvdSBwaXBlIGludG8gdGhpcyBtdXN0IGJlIGluXG4gKiBbb2JqZWN0IG1vZGVdKGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvc3RyZWFtLmh0bWwjc3RyZWFtX29iamVjdF9tb2RlKSBhbmQgc2hvdWxkIG91dHB1dCBPcHVzIHBhY2tldHMuXG4gKiBAZXh0ZW5kcyBvcHVzLk9wdXNTdHJlYW1cbiAqIEBtZW1iZXJvZiBvcHVzXG4gKiBAZXhhbXBsZVxuICogY29uc3QgZGVjb2RlciA9IG5ldyBPcHVzRGVjb2Rlcih7IGZyYW1lU2l6ZTogOTYwLCBjaGFubmVsczogMiwgcmF0ZTogNDgwMDAgfSk7XG4gKiBpbnB1dC5waXBlKGRlY29kZXIpO1xuICogLy8gZGVjb2RlciB3aWxsIG5vdyBvdXRwdXQgUENNIGF1ZGlvXG4gKi9cbmV4cG9ydCBjbGFzcyBPcHVzRGVjb2RlciBleHRlbmRzIE9wdXNTdHJlYW0ge1xuICBfdHJhbnNmb3JtKGNodW5rOiBCdWZmZXIsIGVuY29kaW5nOiBCdWZmZXJFbmNvZGluZywgZG9uZTogKGU/OiBFcnJvciB8IG51bGwsIGNodW5rPzogQnVmZmVyKSA9PiB2b2lkKSB7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gY2h1bmsuc2xpY2UoMCwgOCk7XG4gICAgaWYgKGNodW5rLmxlbmd0aCA+PSA4ICYmIHNpZ25hdHVyZS5lcXVhbHMoT1BVU19IRUFEKSkge1xuICAgICAgdGhpcy5lbWl0KCdmb3JtYXQnLCB7XG4gICAgICAgIGNoYW5uZWxzOiB0aGlzLl9vcHRpb25zLmNoYW5uZWxzLFxuICAgICAgICBzYW1wbGVSYXRlOiB0aGlzLl9vcHRpb25zLnJhdGUsXG4gICAgICAgIGJpdERlcHRoOiAxNixcbiAgICAgICAgZmxvYXQ6IGZhbHNlLFxuICAgICAgICBzaWduZWQ6IHRydWUsXG4gICAgICAgIHZlcnNpb246IGNodW5rLnJlYWRVSW50OCg4KSxcbiAgICAgICAgcHJlU2tpcDogY2h1bmsucmVhZFVJbnQxNkxFKDEwKSxcbiAgICAgICAgZ2FpbjogY2h1bmsucmVhZFVJbnQxNkxFKDE2KVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZG9uZSgpO1xuICAgIH1cbiAgICBpZiAoY2h1bmsubGVuZ3RoID49IDggJiYgc2lnbmF0dXJlLmVxdWFscyhPUFVTX1RBR1MpKSB7XG4gICAgICB0aGlzLmVtaXQoJ3RhZ3MnLCBjaHVuayk7XG4gICAgICByZXR1cm4gZG9uZSgpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgdGhpcy5wdXNoKHRoaXMuX2RlY29kZShjaHVuaykpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBkb25lKGUgYXMgRXJyb3IpO1xuICAgIH1cbiAgICByZXR1cm4gZG9uZSgpO1xuICB9XG59IiwgIi8vIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9hbWlzaHNoYWgvcHJpc20tbWVkaWEvYmxvYi80ZWYxZDZmOWY1MzA0MmMwODVjMWY2ODYyN2U4ODkwMDNlMjQ4ZDc3L3NyYy9jb3JlL1dlYm1CYXNlLmpzXG5cbmltcG9ydCB7IFRyYW5zZm9ybSwgVHJhbnNmb3JtQ2FsbGJhY2sgfSBmcm9tICdub2RlOnN0cmVhbSc7XG5cbmV4cG9ydCBjbGFzcyBXZWJtQmFzZURlbXV4ZXIgZXh0ZW5kcyBUcmFuc2Zvcm0ge1xuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFRBR1MgPSB7XG4gICAgLy8gdmFsdWUgaXMgdHJ1ZSBpZiB0aGUgZWxlbWVudCBoYXMgY2hpbGRyZW5cbiAgICAnMWE0NWRmYTMnOiB0cnVlLCAvLyBFQk1MXG4gICAgJzE4NTM4MDY3JzogdHJ1ZSwgLy8gU2VnbWVudFxuICAgICcxZjQzYjY3NSc6IHRydWUsIC8vIENsdXN0ZXJcbiAgICAnMTY1NGFlNmInOiB0cnVlLCAvLyBUcmFja3NcbiAgICBhZTogdHJ1ZSwgLy8gVHJhY2tFbnRyeVxuICAgIGQ3OiBmYWxzZSwgLy8gVHJhY2tOdW1iZXJcbiAgICAnODMnOiBmYWxzZSwgLy8gVHJhY2tUeXBlXG4gICAgYTM6IGZhbHNlLCAvLyBTaW1wbGVCbG9ja1xuICAgICc2M2EyJzogZmFsc2VcbiAgfTtcblxuICBwdWJsaWMgc3RhdGljIHJlYWRvbmx5IFRPT19TSE9SVCA9IFN5bWJvbCgnVE9PX1NIT1JUJyk7XG5cbiAgcHJpdmF0ZSBfcmVtYWluZGVyOiBCdWZmZXIgfCBudWxsID0gbnVsbDtcbiAgcHJpdmF0ZSBfbGVuZ3RoID0gMDtcbiAgcHJpdmF0ZSBfY291bnQgPSAwO1xuICBwcml2YXRlIF9za2lwVW50aWw6IG51bWJlciB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIF90cmFjazoge251bWJlcjogbnVtYmVyO3R5cGU6IG51bWJlcjt9IHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgX2luY29tcGxldGVUcmFjazoge251bWJlcj86IG51bWJlcjt0eXBlPzogbnVtYmVyO30gPSB7fTtcbiAgcHJpdmF0ZSBfZWJtbEZvdW5kID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgV2VibSBkZW11eGVyLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIG9wdGlvbnMgdGhhdCB5b3Ugd291bGQgcGFzcyB0byBhIHJlZ3VsYXIgVHJhbnNmb3JtIHN0cmVhbS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oeyByZWFkYWJsZU9iamVjdE1vZGU6IHRydWUgfSwgb3B0aW9ucykpO1xuICAgIHRoaXMuX3JlbWFpbmRlciA9IG51bGw7XG4gICAgdGhpcy5fbGVuZ3RoID0gMDtcbiAgICB0aGlzLl9jb3VudCA9IDA7XG4gICAgdGhpcy5fc2tpcFVudGlsID0gbnVsbDtcbiAgICB0aGlzLl90cmFjayA9IG51bGw7XG4gICAgdGhpcy5faW5jb21wbGV0ZVRyYWNrID0ge307XG4gICAgdGhpcy5fZWJtbEZvdW5kID0gZmFsc2U7XG4gIH1cblxuICBwdWJsaWMgX2NoZWNrSGVhZChkYXRhOiBCdWZmZXIpIHtcbiAgICB2b2lkIGRhdGE7XG4gIH1cblxuICBfdHJhbnNmb3JtKGNodW5rOiBCdWZmZXIsIGVuY29kaW5nOiBCdWZmZXJFbmNvZGluZywgZG9uZTogVHJhbnNmb3JtQ2FsbGJhY2spIHtcbiAgICB0aGlzLl9sZW5ndGggKz0gY2h1bmsubGVuZ3RoO1xuICAgIGlmICh0aGlzLl9yZW1haW5kZXIpIHtcbiAgICAgIGNodW5rID0gQnVmZmVyLmNvbmNhdChbdGhpcy5fcmVtYWluZGVyLCBjaHVua10pO1xuICAgICAgdGhpcy5fcmVtYWluZGVyID0gbnVsbDtcbiAgICB9XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgaWYgKHRoaXMuX3NraXBVbnRpbCAmJiB0aGlzLl9sZW5ndGggPiB0aGlzLl9za2lwVW50aWwpIHtcbiAgICAgIG9mZnNldCA9IHRoaXMuX3NraXBVbnRpbCAtIHRoaXMuX2NvdW50O1xuICAgICAgdGhpcy5fc2tpcFVudGlsID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3NraXBVbnRpbCkge1xuICAgICAgdGhpcy5fY291bnQgKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgZG9uZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCByZXN1bHQ7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHdoaWxlIChyZXN1bHQgIT09IFdlYm1CYXNlRGVtdXhlci5UT09fU0hPUlQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuX3JlYWRUYWcoY2h1bmssIG9mZnNldCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBkb25lKGVycm9yIGFzIEVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdCA9PT0gV2VibUJhc2VEZW11eGVyLlRPT19TSE9SVCkgYnJlYWs7XG4gICAgICBpZiAocmVzdWx0Ll9za2lwVW50aWwpIHtcbiAgICAgICAgdGhpcy5fc2tpcFVudGlsID0gcmVzdWx0Ll9za2lwVW50aWw7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdC5vZmZzZXQpIG9mZnNldCA9IHJlc3VsdC5vZmZzZXQ7ZWxzZVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHRoaXMuX2NvdW50ICs9IG9mZnNldDtcbiAgICB0aGlzLl9yZW1haW5kZXIgPSBjaHVuay5zdWJhcnJheShvZmZzZXQpO1xuICAgIGRvbmUoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvKipcbiAgICogUmVhZHMgYW4gRUJNTCBJRCBmcm9tIGEgYnVmZmVyLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gY2h1bmsgdGhlIGJ1ZmZlciB0byByZWFkIGZyb20uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgdGhlIG9mZnNldCBpbiB0aGUgYnVmZmVyLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fFN5bWJvbH0gY29udGFpbnMgYW4gYGlkYCBwcm9wZXJ0eSAoYnVmZmVyKSBhbmQgdGhlIG5ldyBgb2Zmc2V0YCAobnVtYmVyKS5cbiAgICogUmV0dXJucyB0aGUgVE9PX1NIT1JUIHN5bWJvbCBpZiB0aGUgZGF0YSB3YXNuJ3QgYmlnIGVub3VnaCB0byBmYWNpbGl0YXRlIHRoZSByZXF1ZXN0LlxuICAgKi9cbiAgX3JlYWRFQk1MSWQoY2h1bms6IEJ1ZmZlciwgb2Zmc2V0OiBudW1iZXIpIHtcbiAgICBjb25zdCBpZExlbmd0aCA9IHZpbnRMZW5ndGgoY2h1bmssIG9mZnNldCk7XG4gICAgaWYgKGlkTGVuZ3RoID09PSBXZWJtQmFzZURlbXV4ZXIuVE9PX1NIT1JUKSByZXR1cm4gV2VibUJhc2VEZW11eGVyLlRPT19TSE9SVDtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IGNodW5rLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgaWRMZW5ndGgpLFxuICAgICAgb2Zmc2V0OiBvZmZzZXQgKyBpZExlbmd0aFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUmVhZHMgYSBzaXplIHZhcmlhYmxlLWludGVnZXIgdG8gY2FsY3VsYXRlIHRoZSBsZW5ndGggb2YgdGhlIGRhdGEgb2YgYSB0YWcuXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBjaHVuayB0aGUgYnVmZmVyIHRvIHJlYWQgZnJvbS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCB0aGUgb2Zmc2V0IGluIHRoZSBidWZmZXIuXG4gICAqIEByZXR1cm5zIHtPYmplY3R8U3ltYm9sfSBjb250YWlucyBwcm9wZXJ0eSBgb2Zmc2V0YCAobnVtYmVyKSwgYGRhdGFMZW5ndGhgIChudW1iZXIpIGFuZCBgc2l6ZUxlbmd0aGAgKG51bWJlcikuXG4gICAqIFJldHVybnMgdGhlIFRPT19TSE9SVCBzeW1ib2wgaWYgdGhlIGRhdGEgd2Fzbid0IGJpZyBlbm91Z2ggdG8gZmFjaWxpdGF0ZSB0aGUgcmVxdWVzdC5cbiAgICovXG4gIF9yZWFkVGFnRGF0YVNpemUoY2h1bms6IEJ1ZmZlciwgb2Zmc2V0OiBudW1iZXIpIHtcbiAgICBjb25zdCBzaXplTGVuZ3RoID0gdmludExlbmd0aChjaHVuaywgb2Zmc2V0KTtcbiAgICBpZiAoc2l6ZUxlbmd0aCA9PT0gV2VibUJhc2VEZW11eGVyLlRPT19TSE9SVCkgcmV0dXJuIFdlYm1CYXNlRGVtdXhlci5UT09fU0hPUlQ7XG4gICAgY29uc3QgZGF0YUxlbmd0aCA9IGV4cGFuZFZpbnQoY2h1bmssIG9mZnNldCwgb2Zmc2V0ICsgc2l6ZUxlbmd0aCk7XG4gICAgcmV0dXJuIHsgb2Zmc2V0OiBvZmZzZXQgKyBzaXplTGVuZ3RoLCBkYXRhTGVuZ3RoLCBzaXplTGVuZ3RoIH07XG4gIH1cblxuICAvKipcbiAgICogVGFrZXMgYSBidWZmZXIgYW5kIGF0dGVtcHRzIHRvIHJlYWQgYW5kIHByb2Nlc3MgYSB0YWcuXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBjaHVuayB0aGUgYnVmZmVyIHRvIHJlYWQgZnJvbS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCB0aGUgb2Zmc2V0IGluIHRoZSBidWZmZXIuXG4gICAqIEByZXR1cm5zIHtPYmplY3R8U3ltYm9sfSBjb250YWlucyB0aGUgbmV3IGBvZmZzZXRgIChudW1iZXIpIGFuZCBvcHRpb25hbGx5IHRoZSBgX3NraXBVbnRpbGAgcHJvcGVydHksXG4gICAqIGluZGljYXRpbmcgdGhhdCB0aGUgc3RyZWFtIHNob3VsZCBpZ25vcmUgYW55IGRhdGEgdW50aWwgYSBjZXJ0YWluIGxlbmd0aCBpcyByZWFjaGVkLlxuICAgKiBSZXR1cm5zIHRoZSBUT09fU0hPUlQgc3ltYm9sIGlmIHRoZSBkYXRhIHdhc24ndCBiaWcgZW5vdWdoIHRvIGZhY2lsaXRhdGUgdGhlIHJlcXVlc3QuXG4gICAqL1xuICBfcmVhZFRhZyhjaHVuazogQnVmZmVyLCBvZmZzZXQ6IG51bWJlcikge1xuICAgIGNvbnN0IGlkRGF0YSA9IHRoaXMuX3JlYWRFQk1MSWQoY2h1bmssIG9mZnNldCk7XG4gICAgaWYgKGlkRGF0YSA9PT0gV2VibUJhc2VEZW11eGVyLlRPT19TSE9SVCkgcmV0dXJuIFdlYm1CYXNlRGVtdXhlci5UT09fU0hPUlQ7XG4gICAgY29uc3QgZWJtbElEID0gaWREYXRhLmlkLnRvU3RyaW5nKCdoZXgnKTtcbiAgICBpZiAoIXRoaXMuX2VibWxGb3VuZCkge1xuICAgICAgaWYgKGVibWxJRCA9PT0gJzFhNDVkZmEzJykgdGhpcy5fZWJtbEZvdW5kID0gdHJ1ZTtlbHNlXG4gICAgICB0aHJvdyBFcnJvcignRGlkIG5vdCBmaW5kIHRoZSBFQk1MIHRhZyBhdCB0aGUgc3RhcnQgb2YgdGhlIHN0cmVhbScpO1xuICAgIH1cbiAgICBvZmZzZXQgPSBpZERhdGEub2Zmc2V0O1xuICAgIGNvbnN0IHNpemVEYXRhID0gdGhpcy5fcmVhZFRhZ0RhdGFTaXplKGNodW5rLCBvZmZzZXQpO1xuICAgIGlmIChzaXplRGF0YSA9PT0gV2VibUJhc2VEZW11eGVyLlRPT19TSE9SVCkgcmV0dXJuIFdlYm1CYXNlRGVtdXhlci5UT09fU0hPUlQ7XG4gICAgY29uc3QgeyBkYXRhTGVuZ3RoIH0gPSBzaXplRGF0YTtcbiAgICBvZmZzZXQgPSBzaXplRGF0YS5vZmZzZXQ7XG4gICAgLy8gSWYgdGhpcyB0YWcgaXNuJ3QgdXNlZnVsLCB0ZWxsIHRoZSBzdHJlYW0gdG8gc3RvcCBwcm9jZXNzaW5nIGRhdGEgdW50aWwgdGhlIHRhZyBlbmRzXG4gICAgaWYgKHR5cGVvZiBXZWJtQmFzZURlbXV4ZXIuVEFHU1tlYm1sSUQgYXMga2V5b2YgKHR5cGVvZiBXZWJtQmFzZURlbXV4ZXIpWydUQUdTJ11dID09PSAndW5kZWZpbmVkJykge1xuICAgICAgaWYgKGNodW5rLmxlbmd0aCA+IG9mZnNldCArIChkYXRhTGVuZ3RoIGFzIG51bWJlcikpIHtcbiAgICAgICAgcmV0dXJuIHsgb2Zmc2V0OiBvZmZzZXQgKyAoZGF0YUxlbmd0aCBhcyBudW1iZXIpIH07XG4gICAgICB9XG4gICAgICByZXR1cm4geyBvZmZzZXQsIF9za2lwVW50aWw6IHRoaXMuX2NvdW50ICsgKG9mZnNldCBhcyBudW1iZXIpICsgKGRhdGFMZW5ndGggYXMgbnVtYmVyKSB9O1xuICAgIH1cblxuICAgIGNvbnN0IHRhZ0hhc0NoaWxkcmVuID0gV2VibUJhc2VEZW11eGVyLlRBR1NbZWJtbElEIGFzIGtleW9mICh0eXBlb2YgV2VibUJhc2VEZW11eGVyKVsnVEFHUyddXTtcbiAgICBpZiAodGFnSGFzQ2hpbGRyZW4pIHtcbiAgICAgIHJldHVybiB7IG9mZnNldCB9O1xuICAgIH1cblxuICAgIGlmICgob2Zmc2V0IGFzIG51bWJlcikgKyAoZGF0YUxlbmd0aCBhcyBudW1iZXIpID4gY2h1bmsubGVuZ3RoKSByZXR1cm4gV2VibUJhc2VEZW11eGVyLlRPT19TSE9SVDtcbiAgICBjb25zdCBkYXRhID0gY2h1bmsuc3ViYXJyYXkob2Zmc2V0LCAob2Zmc2V0IGFzIG51bWJlcikgKyAoZGF0YUxlbmd0aCBhcyBudW1iZXIpKTtcbiAgICBpZiAoIXRoaXMuX3RyYWNrKSB7XG4gICAgICBpZiAoZWJtbElEID09PSAnYWUnKSB0aGlzLl9pbmNvbXBsZXRlVHJhY2sgPSB7fTtcbiAgICAgIGlmIChlYm1sSUQgPT09ICdkNycpIHRoaXMuX2luY29tcGxldGVUcmFjay5udW1iZXIgPSBkYXRhWzBdO1xuICAgICAgaWYgKGVibWxJRCA9PT0gJzgzJykgdGhpcy5faW5jb21wbGV0ZVRyYWNrLnR5cGUgPSBkYXRhWzBdO1xuICAgICAgaWYgKHRoaXMuX2luY29tcGxldGVUcmFjay50eXBlID09PSAyICYmIHR5cGVvZiB0aGlzLl9pbmNvbXBsZXRlVHJhY2subnVtYmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHRoaXMuX3RyYWNrID0gdGhpcy5faW5jb21wbGV0ZVRyYWNrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZWJtbElEID09PSAnNjNhMicpIHtcbiAgICAgIHRoaXMuX2NoZWNrSGVhZChkYXRhKTtcbiAgICAgIHRoaXMuZW1pdCgnaGVhZCcsIGRhdGEpO1xuICAgIH0gZWxzZSBpZiAoZWJtbElEID09PSAnYTMnKSB7XG4gICAgICBpZiAoIXRoaXMuX3RyYWNrKSB0aHJvdyBFcnJvcignTm8gYXVkaW8gdHJhY2sgaW4gdGhpcyB3ZWJtIScpO1xuICAgICAgaWYgKChkYXRhWzBdICYgMHhmKSA9PT0gdGhpcy5fdHJhY2subnVtYmVyKSB7XG4gICAgICAgIHRoaXMucHVzaChkYXRhLnN1YmFycmF5KDQpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgb2Zmc2V0OiAob2Zmc2V0IGFzIG51bWJlcikgKyAoZGF0YUxlbmd0aCBhcyBudW1iZXIpIH07XG4gIH1cblxuICBfZGVzdHJveShlcnI6IEVycm9yLCBjYjogKGVycm9yOiBFcnJvciB8IG51bGwpID0+IHZvaWQpIHtcbiAgICB0aGlzLl9jbGVhbnVwKCk7XG4gICAgcmV0dXJuIGNiID8gY2IoZXJyKSA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIF9maW5hbChjYjogVHJhbnNmb3JtQ2FsbGJhY2spIHtcbiAgICB0aGlzLl9jbGVhbnVwKCk7XG4gICAgY2IoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhbnMgdXAgdGhlIGRlbXV4ZXIgd2hlbiBpdCBpcyBubyBsb25nZXIgcmVxdWlyZWQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY2xlYW51cCgpIHtcbiAgICB0aGlzLl9yZW1haW5kZXIgPSBudWxsO1xuICAgIHRoaXMuX2luY29tcGxldGVUcmFjayA9IHt9O1xuICB9XG59XG5cbmZ1bmN0aW9uIHZpbnRMZW5ndGgoYnVmZmVyOiBCdWZmZXIsIGluZGV4OiBudW1iZXIpIHtcbiAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+IGJ1ZmZlci5sZW5ndGggLSAxKSB7XG4gICAgcmV0dXJuIFdlYm1CYXNlRGVtdXhlci5UT09fU0hPUlQ7XG4gIH1cbiAgbGV0IGkgPSAwO1xuICBmb3IgKDsgaSA8IDg7IGkrKykgaWYgKDEgPDwgNyAtIGkgJiBidWZmZXJbaW5kZXhdKSBicmVhaztcbiAgaSsrO1xuICBpZiAoaW5kZXggKyBpID4gYnVmZmVyLmxlbmd0aCkge1xuICAgIHJldHVybiBXZWJtQmFzZURlbXV4ZXIuVE9PX1NIT1JUO1xuICB9XG4gIHJldHVybiBpO1xufVxuXG5mdW5jdGlvbiBleHBhbmRWaW50KGJ1ZmZlcjogQnVmZmVyLCBzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcikge1xuICBjb25zdCBsZW5ndGggPSB2aW50TGVuZ3RoKGJ1ZmZlciwgc3RhcnQpO1xuICBpZiAoZW5kID4gYnVmZmVyLmxlbmd0aCB8fCBsZW5ndGggPT09IFdlYm1CYXNlRGVtdXhlci5UT09fU0hPUlQpIHJldHVybiBXZWJtQmFzZURlbXV4ZXIuVE9PX1NIT1JUO1xuICAvLyBAdHMtaWdub3JlXG4gIGNvbnN0IG1hc2sgPSAoMSA8PCA4IC0gbGVuZ3RoKSAtIDE7XG4gIGxldCB2YWx1ZSA9IGJ1ZmZlcltzdGFydF0gJiBtYXNrO1xuICBmb3IgKGxldCBpID0gc3RhcnQgKyAxOyBpIDwgZW5kOyBpKyspIHtcbiAgICB2YWx1ZSA9ICh2YWx1ZSA8PCA4KSArIGJ1ZmZlcltpXTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59IiwgIi8vIGJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9hbWlzaHNoYWgvcHJpc20tbWVkaWEvYmxvYi80ZWYxZDZmOWY1MzA0MmMwODVjMWY2ODYyN2U4ODkwMDNlMjQ4ZDc3L3NyYy9vcHVzL1dlYm1EZW11eGVyLmpzXG5cbmltcG9ydCB7IFdlYm1CYXNlRGVtdXhlciB9IGZyb20gJy4vV2VibUJhc2UnO1xuXG5jb25zdCBPUFVTX0hFQUQgPSBCdWZmZXIuZnJvbShbLi4uJ09wdXNIZWFkJ10ubWFwKCh4KSA9PiB4LmNoYXJDb2RlQXQoMCkpKTtcblxuLyoqXG4gKiBEZW11eGVzIGEgV2VibSBzdHJlYW0gKGNvbnRhaW5pbmcgT3B1cyBhdWRpbykgdG8gb3V0cHV0IGFuIE9wdXMgc3RyZWFtLlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcbiAqIGNvbnN0IGZpbGUgPSBmcy5jcmVhdGVSZWFkU3RyZWFtKCcuL2F1ZGlvLndlYm0nKTtcbiAqIGNvbnN0IGRlbXV4ZXIgPSBuZXcgV2VibURlbXV4ZXIoKTtcbiAqIGNvbnN0IG9wdXMgPSBmaWxlLnBpcGUoZGVtdXhlcik7XG4gKiAvLyBvcHVzIGlzIG5vdyBhIFJlYWRhYmxlU3RyZWFtIGluIG9iamVjdCBtb2RlIG91dHB1dHRpbmcgT3B1cyBwYWNrZXRzXG4gKi9cbmV4cG9ydCBjbGFzcyBXZWJtRGVtdXhlciBleHRlbmRzIFdlYm1CYXNlRGVtdXhlciB7XG4gIF9jaGVja0hlYWQoZGF0YTogQnVmZmVyKSB7XG4gICAgaWYgKCFkYXRhLnN1YmFycmF5KDAsIDgpLmVxdWFscyhPUFVTX0hFQUQpKSB7XG4gICAgICB0aHJvdyBFcnJvcignQXVkaW8gY29kZWMgaXMgbm90IE9wdXMhJyk7XG4gICAgfVxuICB9XG59IiwgIlxuXG5cblxuXG5cbmV4cG9ydCBjb25zdCB2ZXJzaW9uID0gLyogQF9fTUFDUk9fXyBnZXRWZXJzaW9uICovXCI3LjAuMFwiOyJdLAogICJtYXBwaW5ncyI6ICI7Ozs7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QUssSUFBSTtBQUM1QixXQUFTLElBQUksUUFBUSxHQUFHLElBQUksS0FBSyxLQUFLO0FBQ3BDLGFBQVMsU0FBUyxLQUFLLE9BQU8sQ0FBQztBQUFBLEVBQ2pDO0FBQ0EsU0FBTztBQUNUO0FBVlM7OztBQzdNVCxJQUFNQyxhQUFZLE9BQU8sS0FBSyxDQUFDLEdBQUcsVUFBVSxFQUFFLElBQUksQ0FBQyxNQUFNLEVBQUUsV0FBVyxDQUFDLENBQUMsQ0FBQztBQVdsRSxJQUFNLGVBQU4sTUFBTSxxQkFBb0IsZ0JBQWdCO0FBQUEsRUFDL0MsV0FBVyxNQUFjO0FBQ3ZCLFFBQUksQ0FBQyxLQUFLLFNBQVMsR0FBRyxDQUFDLEVBQUUsT0FBT0EsVUFBUyxHQUFHO0FBQzFDLFlBQU0sTUFBTSwwQkFBMEI7QUFBQSxJQUN4QztBQUFBLEVBQ0Y7QUFDRjtBQU5pRDtBQUExQyxJQUFNLGNBQU47OztBQ1RBLElBQU07QUFBQTtBQUFBLEVBQXFDO0FBQUE7IiwKICAibmFtZXMiOiBbImltcG9ydF9ub2RlX3N0cmVhbSIsICJfT3B1c0VuY29kZXIiLCAiT3B1c0VuY29kZXIiLCAiY2hhckNvZGUiLCAiT1BVU19IRUFEIiwgIk9QVVNfVEFHUyIsICJpbXBvcnRfbm9kZV9zdHJlYW0iLCAiT1BVU19IRUFEIl0KfQo=