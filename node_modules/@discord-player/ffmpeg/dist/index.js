"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  FFmpeg: () => FFmpeg,
  createFFmpegArgs: () => createFFmpegArgs,
  version: () => version
});
module.exports = __toCommonJS(src_exports);

// src/FFmpeg.ts
var import_node_child_process = require("child_process");
var import_node_stream = require("stream");
var VERSION_REGEX = /version (.+) Copyright/im;
var validatePathParam = /* @__PURE__ */ __name((path, displayName) => {
  if (!path) throw new Error(`Failed to resolve ${displayName}`);
  return path;
}, "validatePathParam");
var _FFmpeg = class _FFmpeg extends import_node_stream.Duplex {
  /**
   * Create FFmpeg duplex stream
   * @param options Options to initialize ffmpeg
   * @example ```typescript
   * const ffmpeg = new FFmpeg({
   *   args: [
   *     '-analyzeduration', '0',
   *     '-loglevel', '0',
   *     '-f', 's16le',
   *     '-ar', '48000',
   *     '-ac', '2',
   *     '-af', 'bass=g=10,acompressor'
   *   ]
   * });
   *
   * const pcm = input.pipe(ffmpeg);
   *
   * pcm.pipe(fs.createWriteStream('./audio.pcm'));
   * ```
   */
  constructor(options = {}) {
    super(options);
    /**
     * Current FFmpeg process
     */
    __publicField(this, "process");
    this.process = _FFmpeg.spawn(options);
    const EVENTS = {
      readable: this._reader,
      data: this._reader,
      end: this._reader,
      unpipe: this._reader,
      finish: this._writer,
      drain: this._writer
    };
    this._readableState = this._reader._readableState;
    this._writableState = this._writer._writableState;
    this._copy(["write", "end"], this._writer);
    this._copy(["read", "setEncoding", "pipe", "unpipe"], this._reader);
    for (const method of ["on", "once", "removeListener", "removeAllListeners", "listeners"]) {
      this[method] = (ev, fn) => (
        // @ts-expect-error
        EVENTS[ev] ? EVENTS[ev][method](ev, fn) : import_node_stream.Duplex.prototype[method].call(this, ev, fn)
      );
    }
    const processError = /* @__PURE__ */ __name((error) => this.emit("error", error), "processError");
    this._reader.on("error", processError);
    this._writer.on("error", processError);
  }
  /**
   * Checks if FFmpeg is loaded.
   */
  static isLoaded() {
    return _FFmpeg.cached != null;
  }
  /**
   * Adds a new FFmpeg source.
   * @param source FFmpeg source
   */
  static addSource(source) {
    if (_FFmpeg.sources.some((s) => s.name === source.name)) return false;
    _FFmpeg.sources.push(source);
    return true;
  }
  /**
   * Removes a FFmpeg source.
   * @param source FFmpeg source
   */
  static removeSource(source) {
    const index = _FFmpeg.sources.findIndex((s) => s.name === source.name);
    if (index === -1) return false;
    _FFmpeg.sources.splice(index, 1);
    return true;
  }
  /**
   * Resolves FFmpeg path. Throws an error if it fails to resolve.
   * @param force if it should relocate the command
   */
  static resolve(force = false) {
    if (!force && _FFmpeg.cached) return _FFmpeg.cached;
    const errors = [];
    for (const source of _FFmpeg.sources) {
      try {
        let path;
        if (source.module) {
          const mod = require(source.name);
          path = validatePathParam(mod.default?.path || mod.path || mod, source.name);
        } else {
          path = source.name;
        }
        const result = (0, import_node_child_process.spawnSync)(path, ["-v"], { windowsHide: true });
        const resolved = {
          result: result.stdout.toString(),
          command: path,
          module: source.module,
          name: source.name,
          path,
          version: VERSION_REGEX.exec(result.stderr.toString())?.[1] ?? "unknown"
        };
        _FFmpeg.cached = resolved;
        errors.length = 0;
        return resolved;
      } catch (e) {
        const err = e && e instanceof Error ? e.message : `${e}`;
        const msg = `Failed to load ffmpeg using ${source.module ? `require('${source.name}')` : `spawn('${source.name}')`}. Error: ${err}`;
        errors.push(msg);
      }
    }
    throw new Error(`Could not load ffmpeg. Errors:
${errors.join("\n")}`);
  }
  /**
   * Resolves FFmpeg path safely. Returns null if it fails to resolve.
   * @param force if it should relocate the command
   */
  static resolveSafe(force = false) {
    try {
      return _FFmpeg.resolve(force);
    } catch {
      return null;
    }
  }
  /**
   * Spawns ffmpeg process
   * @param options Spawn options
   */
  static spawn({ args = [], shell = false } = {}) {
    if (!args.includes("-i")) args.unshift("-i", "-");
    return (0, import_node_child_process.spawn)(_FFmpeg.resolve().command, args.concat(["pipe:1"]), { windowsHide: true, shell });
  }
  get _reader() {
    return this.process.stdout;
  }
  get _writer() {
    return this.process.stdin;
  }
  _copy(methods, target) {
    for (const method of methods) {
      this[method] = target[method].bind(target);
    }
  }
  _destroy(err, cb) {
    this._cleanup();
    if (cb) return cb(err);
  }
  _final(cb) {
    this._cleanup();
    cb();
  }
  _cleanup() {
    if (this.process) {
      this.once("error", () => {
      });
      this.process.kill("SIGKILL");
      this.process = null;
    }
  }
};
__name(_FFmpeg, "FFmpeg");
/**
 * Cached FFmpeg source.
 */
__publicField(_FFmpeg, "cached", null);
/**
 * Supported FFmpeg sources.
 */
__publicField(_FFmpeg, "sources", [
  // paths
  { name: "ffmpeg", module: false },
  { name: "./ffmpeg", module: false },
  { name: "avconv", module: false },
  { name: "./avconv", module: false },
  // modules
  { name: "ffmpeg-static", module: true },
  { name: "@ffmpeg-installer/ffmpeg", module: true },
  { name: "@node-ffmpeg/node-ffmpeg-installer", module: true },
  { name: "ffmpeg-binaries", module: true }
]);
var FFmpeg = _FFmpeg;

// src/version.ts
var version = (
  /* @__MACRO__ getVersion */
  "7.0.0"
);

// src/index.ts
var createFFmpegArgs = /* @__PURE__ */ __name((input, post) => {
  const args = [];
  for (const [key, value] of Object.entries(input)) {
    args.push(`-${key}`, String(value));
  }
  if (post) {
    Array.isArray(post) ? args.push(...post) : args.push(post);
  }
  return args;
}, "createFFmpegArgs");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  FFmpeg,
  createFFmpegArgs,
  version
});
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vc3JjL2luZGV4LnRzIiwgIi4uL3NyYy9GRm1wZWcudHMiLCAiLi4vc3JjL3ZlcnNpb24udHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbImV4cG9ydCAqIGZyb20gJy4vRkZtcGVnJztcblxuZXhwb3J0IHR5cGUgQXJnUHJpbWl0aXZlID0gc3RyaW5nIHwgbnVtYmVyO1xuXG4vKipcbiAqIENyZWF0ZSBGRm1wZWcgYXJndW1lbnRzIGZyb20gYW4gb2JqZWN0LlxuICogQHBhcmFtIGlucHV0IFRoZSBpbnB1dCBvYmplY3QuXG4gKiBAcmV0dXJucyBUaGUgRkZtcGVnIGFyZ3VtZW50cy5cbiAqIEBleGFtcGxlIGNyZWF0ZUZGbXBlZ0FyZ3MoeyBpOiAnaW5wdXQubXAzJywgYWY6IFsnYmFzcz1nPTEwJywnYWNvbXByZXNzb3InXSB9LCAnLi9vdXQubXAzJyk7XG4gKiAvLyA9PiBbJy1pJywgJ2lucHV0Lm1wMycsICctYWYnLCAnYmFzcz1nPTEwLGFjb21wcmVzc29yJywgJy4vb3V0Lm1wMyddXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVGRm1wZWdBcmdzID0gKFxuaW5wdXQ6IFJlY29yZDxzdHJpbmcsIEFyZ1ByaW1pdGl2ZSB8IEFyZ1ByaW1pdGl2ZVtdPixcbnBvc3Q/OiBzdHJpbmcgfCBzdHJpbmdbXSlcbjogc3RyaW5nW10gPT4ge1xuICBjb25zdCBhcmdzID0gW107XG5cbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoaW5wdXQpKSB7XG4gICAgYXJncy5wdXNoKGAtJHtrZXl9YCwgU3RyaW5nKHZhbHVlKSk7XG4gIH1cblxuICBpZiAocG9zdCkge1xuICAgIEFycmF5LmlzQXJyYXkocG9zdCkgPyBhcmdzLnB1c2goLi4ucG9zdCkgOiBhcmdzLnB1c2gocG9zdCk7XG4gIH1cblxuICByZXR1cm4gYXJncztcbn07XG5cbmV4cG9ydCB7IHZlcnNpb24gfSBmcm9tICcuL3ZlcnNpb24nOyIsICJpbXBvcnQgeyBDaGlsZFByb2Nlc3NXaXRob3V0TnVsbFN0cmVhbXMsIHNwYXduLCBzcGF3blN5bmMgfSBmcm9tICdub2RlOmNoaWxkX3Byb2Nlc3MnO1xuaW1wb3J0IHsgRHVwbGV4LCBEdXBsZXhPcHRpb25zIH0gZnJvbSAnbm9kZTpzdHJlYW0nO1xuXG5leHBvcnQgdHlwZSBGRm1wZWdMaWIgPVxuJ2ZmbXBlZycgfFxuJy4vZmZtcGVnJyB8XG4nYXZjb252JyB8XG4nLi9hdmNvbnYnIHxcbidmZm1wZWctc3RhdGljJyB8XG4nQGZmbXBlZy1pbnN0YWxsZXIvZmZtcGVnJyB8XG4nQG5vZGUtZmZtcGVnL25vZGUtZmZtcGVnLWluc3RhbGxlcicgfFxuJ2ZmbXBlZy1iaW5hcmllcyc7XG5cbmV4cG9ydCB0eXBlIEZGbXBlZ0NhbGxiYWNrPEFyZ3MgZXh0ZW5kcyBBcnJheTx1bmtub3duPj4gPSAoLi4uYXJnczogQXJncykgPT4gdW5rbm93bjtcblxuZXhwb3J0IGludGVyZmFjZSBGRm1wZWdTb3VyY2Uge1xuICBuYW1lOiBGRm1wZWdMaWI7XG4gIG1vZHVsZTogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZXNvbHZlZEZGbXBlZ1NvdXJjZSBleHRlbmRzIEZGbXBlZ1NvdXJjZSB7XG4gIHBhdGg6IHN0cmluZztcbiAgdmVyc2lvbjogc3RyaW5nO1xuICBjb21tYW5kOiBzdHJpbmc7XG4gIHJlc3VsdDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZGbXBlZ09wdGlvbnMgZXh0ZW5kcyBEdXBsZXhPcHRpb25zIHtcbiAgYXJncz86IHN0cmluZ1tdO1xuICBzaGVsbD86IGJvb2xlYW47XG59XG5cbmNvbnN0IFZFUlNJT05fUkVHRVggPSAvdmVyc2lvbiAoLispIENvcHlyaWdodC9pbTtcblxuY29uc3QgdmFsaWRhdGVQYXRoUGFyYW0gPSAocGF0aDogc3RyaW5nLCBkaXNwbGF5TmFtZTogc3RyaW5nKSA9PiB7XG4gIGlmICghcGF0aCkgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcmVzb2x2ZSAke2Rpc3BsYXlOYW1lfWApO1xuICByZXR1cm4gcGF0aDtcbn07XG5cbmV4cG9ydCBjbGFzcyBGRm1wZWcgZXh0ZW5kcyBEdXBsZXgge1xuICAvKipcbiAgICogQ2FjaGVkIEZGbXBlZyBzb3VyY2UuXG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyBjYWNoZWQ6IFJlc29sdmVkRkZtcGVnU291cmNlIHwgbnVsbCA9IG51bGw7XG4gIC8qKlxuICAgKiBTdXBwb3J0ZWQgRkZtcGVnIHNvdXJjZXMuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHNvdXJjZXM6IEZGbXBlZ1NvdXJjZVtdID0gW1xuICAvLyBwYXRoc1xuICB7IG5hbWU6ICdmZm1wZWcnLCBtb2R1bGU6IGZhbHNlIH0sXG4gIHsgbmFtZTogJy4vZmZtcGVnJywgbW9kdWxlOiBmYWxzZSB9LFxuICB7IG5hbWU6ICdhdmNvbnYnLCBtb2R1bGU6IGZhbHNlIH0sXG4gIHsgbmFtZTogJy4vYXZjb252JywgbW9kdWxlOiBmYWxzZSB9LFxuICAvLyBtb2R1bGVzXG4gIHsgbmFtZTogJ2ZmbXBlZy1zdGF0aWMnLCBtb2R1bGU6IHRydWUgfSxcbiAgeyBuYW1lOiAnQGZmbXBlZy1pbnN0YWxsZXIvZmZtcGVnJywgbW9kdWxlOiB0cnVlIH0sXG4gIHsgbmFtZTogJ0Bub2RlLWZmbXBlZy9ub2RlLWZmbXBlZy1pbnN0YWxsZXInLCBtb2R1bGU6IHRydWUgfSxcbiAgeyBuYW1lOiAnZmZtcGVnLWJpbmFyaWVzJywgbW9kdWxlOiB0cnVlIH1dO1xuXG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBGRm1wZWcgaXMgbG9hZGVkLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBpc0xvYWRlZCgpIHtcbiAgICByZXR1cm4gRkZtcGVnLmNhY2hlZCAhPSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBuZXcgRkZtcGVnIHNvdXJjZS5cbiAgICogQHBhcmFtIHNvdXJjZSBGRm1wZWcgc291cmNlXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGFkZFNvdXJjZShzb3VyY2U6IEZGbXBlZ1NvdXJjZSkge1xuICAgIGlmIChGRm1wZWcuc291cmNlcy5zb21lKChzKSA9PiBzLm5hbWUgPT09IHNvdXJjZS5uYW1lKSkgcmV0dXJuIGZhbHNlO1xuICAgIEZGbXBlZy5zb3VyY2VzLnB1c2goc291cmNlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgRkZtcGVnIHNvdXJjZS5cbiAgICogQHBhcmFtIHNvdXJjZSBGRm1wZWcgc291cmNlXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlbW92ZVNvdXJjZShzb3VyY2U6IEZGbXBlZ1NvdXJjZSkge1xuICAgIGNvbnN0IGluZGV4ID0gRkZtcGVnLnNvdXJjZXMuZmluZEluZGV4KChzKSA9PiBzLm5hbWUgPT09IHNvdXJjZS5uYW1lKTtcbiAgICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm4gZmFsc2U7XG4gICAgRkZtcGVnLnNvdXJjZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNvbHZlcyBGRm1wZWcgcGF0aC4gVGhyb3dzIGFuIGVycm9yIGlmIGl0IGZhaWxzIHRvIHJlc29sdmUuXG4gICAqIEBwYXJhbSBmb3JjZSBpZiBpdCBzaG91bGQgcmVsb2NhdGUgdGhlIGNvbW1hbmRcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgcmVzb2x2ZShmb3JjZSA9IGZhbHNlKSB7XG4gICAgaWYgKCFmb3JjZSAmJiBGRm1wZWcuY2FjaGVkKSByZXR1cm4gRkZtcGVnLmNhY2hlZDtcblxuICAgIGNvbnN0IGVycm9yczogc3RyaW5nW10gPSBbXTtcblxuICAgIGZvciAoY29uc3Qgc291cmNlIG9mIEZGbXBlZy5zb3VyY2VzKSB7XG4gICAgICB0cnkge1xuICAgICAgICBsZXQgcGF0aDogc3RyaW5nO1xuXG4gICAgICAgIGlmIChzb3VyY2UubW9kdWxlKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby12YXItcmVxdWlyZXNcbiAgICAgICAgICBjb25zdCBtb2QgPSByZXF1aXJlKHNvdXJjZS5uYW1lKTtcbiAgICAgICAgICBwYXRoID0gdmFsaWRhdGVQYXRoUGFyYW0obW9kLmRlZmF1bHQ/LnBhdGggfHwgbW9kLnBhdGggfHwgbW9kLCBzb3VyY2UubmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGF0aCA9IHNvdXJjZS5uYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gc3Bhd25TeW5jKHBhdGgsIFsnLXYnXSwgeyB3aW5kb3dzSGlkZTogdHJ1ZSB9KTtcblxuICAgICAgICBjb25zdCByZXNvbHZlZDogUmVzb2x2ZWRGRm1wZWdTb3VyY2UgPSB7XG4gICAgICAgICAgcmVzdWx0OiByZXN1bHQuc3Rkb3V0LnRvU3RyaW5nKCksXG4gICAgICAgICAgY29tbWFuZDogcGF0aCxcbiAgICAgICAgICBtb2R1bGU6IHNvdXJjZS5tb2R1bGUsXG4gICAgICAgICAgbmFtZTogc291cmNlLm5hbWUsXG4gICAgICAgICAgcGF0aCxcbiAgICAgICAgICB2ZXJzaW9uOiBWRVJTSU9OX1JFR0VYLmV4ZWMocmVzdWx0LnN0ZGVyci50b1N0cmluZygpKT8uWzFdID8/ICd1bmtub3duJ1xuICAgICAgICB9O1xuXG4gICAgICAgIEZGbXBlZy5jYWNoZWQgPSByZXNvbHZlZDtcblxuICAgICAgICBlcnJvcnMubGVuZ3RoID0gMDtcblxuICAgICAgICByZXR1cm4gcmVzb2x2ZWQ7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnN0IGVyciA9IGUgJiYgZSBpbnN0YW5jZW9mIEVycm9yID8gZS5tZXNzYWdlIDogYCR7ZX1gO1xuICAgICAgICBjb25zdCBtc2cgPSBgRmFpbGVkIHRvIGxvYWQgZmZtcGVnIHVzaW5nICR7XG4gICAgICAgIHNvdXJjZS5tb2R1bGUgPyBgcmVxdWlyZSgnJHtzb3VyY2UubmFtZX0nKWAgOiBgc3Bhd24oJyR7c291cmNlLm5hbWV9JylgfS4gRXJyb3I6ICR7XG4gICAgICAgIGVycn1gO1xuXG4gICAgICAgIGVycm9ycy5wdXNoKG1zZyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgbG9hZCBmZm1wZWcuIEVycm9yczpcXG4ke2Vycm9ycy5qb2luKCdcXG4nKX1gKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNvbHZlcyBGRm1wZWcgcGF0aCBzYWZlbHkuIFJldHVybnMgbnVsbCBpZiBpdCBmYWlscyB0byByZXNvbHZlLlxuICAgKiBAcGFyYW0gZm9yY2UgaWYgaXQgc2hvdWxkIHJlbG9jYXRlIHRoZSBjb21tYW5kXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIHJlc29sdmVTYWZlKGZvcmNlID0gZmFsc2UpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEZGbXBlZy5yZXNvbHZlKGZvcmNlKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTcGF3bnMgZmZtcGVnIHByb2Nlc3NcbiAgICogQHBhcmFtIG9wdGlvbnMgU3Bhd24gb3B0aW9uc1xuICAgKi9cbiAgcHVibGljIHN0YXRpYyBzcGF3bih7IGFyZ3MgPSBbXSBhcyBzdHJpbmdbXSwgc2hlbGwgPSBmYWxzZSB9ID0ge30pIHtcbiAgICBpZiAoIWFyZ3MuaW5jbHVkZXMoJy1pJykpIGFyZ3MudW5zaGlmdCgnLWknLCAnLScpO1xuICAgIHJldHVybiBzcGF3bihGRm1wZWcucmVzb2x2ZSgpLmNvbW1hbmQsIGFyZ3MuY29uY2F0KFsncGlwZToxJ10pLCB7IHdpbmRvd3NIaWRlOiB0cnVlLCBzaGVsbCB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDdXJyZW50IEZGbXBlZyBwcm9jZXNzXG4gICAqL1xuICBwdWJsaWMgcHJvY2VzczogQ2hpbGRQcm9jZXNzV2l0aG91dE51bGxTdHJlYW1zO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgRkZtcGVnIGR1cGxleCBzdHJlYW1cbiAgICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyB0byBpbml0aWFsaXplIGZmbXBlZ1xuICAgKiBAZXhhbXBsZSBgYGB0eXBlc2NyaXB0XG4gICAqIGNvbnN0IGZmbXBlZyA9IG5ldyBGRm1wZWcoe1xuICAgKiAgIGFyZ3M6IFtcbiAgICogICAgICctYW5hbHl6ZWR1cmF0aW9uJywgJzAnLFxuICAgKiAgICAgJy1sb2dsZXZlbCcsICcwJyxcbiAgICogICAgICctZicsICdzMTZsZScsXG4gICAqICAgICAnLWFyJywgJzQ4MDAwJyxcbiAgICogICAgICctYWMnLCAnMicsXG4gICAqICAgICAnLWFmJywgJ2Jhc3M9Zz0xMCxhY29tcHJlc3NvcidcbiAgICogICBdXG4gICAqIH0pO1xuICAgKlxuICAgKiBjb25zdCBwY20gPSBpbnB1dC5waXBlKGZmbXBlZyk7XG4gICAqXG4gICAqIHBjbS5waXBlKGZzLmNyZWF0ZVdyaXRlU3RyZWFtKCcuL2F1ZGlvLnBjbScpKTtcbiAgICogYGBgXG4gICAqL1xuICBwdWJsaWMgY29uc3RydWN0b3Iob3B0aW9uczogRkZtcGVnT3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG5cbiAgICB0aGlzLnByb2Nlc3MgPSBGRm1wZWcuc3Bhd24ob3B0aW9ucyk7XG5cbiAgICBjb25zdCBFVkVOVFMgPSB7XG4gICAgICByZWFkYWJsZTogdGhpcy5fcmVhZGVyLFxuICAgICAgZGF0YTogdGhpcy5fcmVhZGVyLFxuICAgICAgZW5kOiB0aGlzLl9yZWFkZXIsXG4gICAgICB1bnBpcGU6IHRoaXMuX3JlYWRlcixcbiAgICAgIGZpbmlzaDogdGhpcy5fd3JpdGVyLFxuICAgICAgZHJhaW46IHRoaXMuX3dyaXRlclxuICAgIH0gYXMgY29uc3Q7XG5cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZSA9IHRoaXMuX3JlYWRlci5fcmVhZGFibGVTdGF0ZTtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZSA9IHRoaXMuX3dyaXRlci5fd3JpdGFibGVTdGF0ZTtcblxuICAgIHRoaXMuX2NvcHkoWyd3cml0ZScsICdlbmQnXSwgdGhpcy5fd3JpdGVyKTtcbiAgICB0aGlzLl9jb3B5KFsncmVhZCcsICdzZXRFbmNvZGluZycsICdwaXBlJywgJ3VucGlwZSddLCB0aGlzLl9yZWFkZXIpO1xuXG4gICAgZm9yIChjb25zdCBtZXRob2Qgb2YgWydvbicsICdvbmNlJywgJ3JlbW92ZUxpc3RlbmVyJywgJ3JlbW92ZUFsbExpc3RlbmVycycsICdsaXN0ZW5lcnMnXSBhcyBjb25zdCkge1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgdGhpc1ttZXRob2RdID0gKGV2LCBmbikgPT5cbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgIEVWRU5UU1tldl0gPyBFVkVOVFNbZXZdW21ldGhvZF0oZXYsIGZuKSA6IER1cGxleC5wcm90b3R5cGVbbWV0aG9kXS5jYWxsKHRoaXMsIGV2LCBmbik7XG4gICAgfVxuXG4gICAgY29uc3QgcHJvY2Vzc0Vycm9yID0gKGVycm9yOiBFcnJvcikgPT4gdGhpcy5lbWl0KCdlcnJvcicsIGVycm9yKTtcblxuICAgIHRoaXMuX3JlYWRlci5vbignZXJyb3InLCBwcm9jZXNzRXJyb3IpO1xuICAgIHRoaXMuX3dyaXRlci5vbignZXJyb3InLCBwcm9jZXNzRXJyb3IpO1xuICB9XG5cbiAgZ2V0IF9yZWFkZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvY2VzcyEuc3Rkb3V0O1xuICB9XG4gIGdldCBfd3JpdGVyKCkge1xuICAgIHJldHVybiB0aGlzLnByb2Nlc3MhLnN0ZGluO1xuICB9XG5cbiAgcHJpdmF0ZSBfY29weShtZXRob2RzOiBzdHJpbmdbXSwgdGFyZ2V0OiB1bmtub3duKSB7XG4gICAgZm9yIChjb25zdCBtZXRob2Qgb2YgbWV0aG9kcykge1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgdGhpc1ttZXRob2RdID0gdGFyZ2V0W21ldGhvZF0uYmluZCh0YXJnZXQpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBfZGVzdHJveShlcnI6IEVycm9yIHwgbnVsbCwgY2I6IEZGbXBlZ0NhbGxiYWNrPFtFcnJvciB8IG51bGxdPikge1xuICAgIHRoaXMuX2NsZWFudXAoKTtcbiAgICBpZiAoY2IpIHJldHVybiBjYihlcnIpO1xuICB9XG5cbiAgcHVibGljIF9maW5hbChjYjogRkZtcGVnQ2FsbGJhY2s8W10+KSB7XG4gICAgdGhpcy5fY2xlYW51cCgpO1xuICAgIGNiKCk7XG4gIH1cblxuICBwcml2YXRlIF9jbGVhbnVwKCkge1xuICAgIGlmICh0aGlzLnByb2Nlc3MpIHtcbiAgICAgIHRoaXMub25jZSgnZXJyb3InLCAoKSA9PiB7XG5cbiAgICAgICAgLy9cbiAgICAgIH0pO3RoaXMucHJvY2Vzcy5raWxsKCdTSUdLSUxMJyk7XG4gICAgICB0aGlzLnByb2Nlc3MgPSBudWxsIGFzIHVua25vd24gYXMgQ2hpbGRQcm9jZXNzV2l0aG91dE51bGxTdHJlYW1zO1xuICAgIH1cbiAgfVxufSIsICJcblxuXG5cblxuXG5leHBvcnQgY29uc3QgdmVyc2lvbiA9IC8qIEBfX01BQ1JPX18gZ2V0VmVyc2lvbiAqL1wiNy4wLjBcIjsiXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOzs7QUNBQSxnQ0FBaUU7QUFDakUseUJBQXNDO0FBK0J0QyxJQUFNLGdCQUFnQjtBQUV0QixJQUFNLG9CQUFvQix3QkFBQyxNQUFjLGdCQUF3QjtBQUMvRCxNQUFJLENBQUMsS0FBTSxPQUFNLElBQUksTUFBTSxxQkFBcUIsV0FBVyxFQUFFO0FBQzdELFNBQU87QUFDVCxHQUgwQjtBQUtuQixJQUFNLFVBQU4sTUFBTSxnQkFBZSwwQkFBTztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFB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